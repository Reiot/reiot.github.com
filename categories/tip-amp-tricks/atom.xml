<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tip &amp; Tricks | Social Reiot]]></title>
  <link href="http://reiot.com/categories/tip-amp-tricks/atom.xml" rel="self"/>
  <link href="http://reiot.com/"/>
  <updated>2012-01-22T10:06:24+09:00</updated>
  <id>http://reiot.com/</id>
  <author>
    <name><![CDATA[Ray Yun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Google App Engine Tips]]></title>
    <link href="http://reiot.com/2010/08/13/google-app-engine-tips/"/>
    <updated>2010-08-13T00:15:00+09:00</updated>
    <id>http://reiot.com/2010/08/13/google-app-engine-tips</id>
    <content type="html"><![CDATA[<p><a href="http://boxcatstudio.files.wordpress.com/2010/08/20100413120411_38823.png"><img src="http://boxcatstudio.files.wordpress.com/2010/08/20100413120411_38823.png"></a>구글 앱 엔진으로 개발하면서 학습한 내용을 정리합니다. 이론적으로 혹은 실제 서비스할 때 잘못되거나 틀린 부분이 있을 수 있음을 미리 알려 드립니다.</p>

<p><strong>검증 및 마이그레이션의 책임은 '프로그래머'가 진다.</strong></p>

<p>관계형 데이터베이스의 경우, 스키마 및 그 정합성을 검증할 책임이 데이터베이스 엔진에 있는 반면, 구글 데이터스토어는 분산 및 속도 향상을 위해, 스키마와 검증의 책임이 프로그램 쪽으로 넘어와 있다. 이게 무슨 뜻이냐 하면, 같은 모델(테이블)에 서로 다른 필드로 구성된 객체(Entity,열)가 들어갈 수 있다는 뜻이다. 따라서 데이터스토어는 임의의 데이터 집합을 쿼리해서 읽어왔을 때, 그 안에 어떤 데이터가 들어가 있을지 모르기 때문에, 마이그레이션 역시 프로그램이 책임지고 구현해야 한다. 새로 속성(Property,컬럼)을 추가하거나, 삭제하려면 해당 모델에 속한 모든 객체들을 찾아서 하나씩 변경해줘야 한다.</p>

<p>예를 들어, 어떤 모델의 속성이 더이상 필요없어져서 삭제하려면, 무려 <a href="http://code.google.com/intl/ko-KR/appengine/articles/update_schema.html">소스 코드에서 모델의 부모 클래스를 바꿔서 저장한 후, 서버에 터미널을 열고 수동으로 해당 속성들을 지우고 다시 돌아와서 코드를 롤백하는 등의 수고로움</a>이 필요하다.</p>

<p>이런 이유로, 가급적이면 앱엔진에서 서비스중에, 모델의 특정 속성 이름을 바꾸는 일은 피해야 한다.</p>

<p><strong>트랜잭션으로 묶을 객체들은 '생성' 시점에 부모를 지정해야 한다.</strong></p>

<p>관계형 데이터베이스에서는 서비스 이후에도 적당히 쿼리 최적화와 마이그레이션을 통해서 새로 트랜잭션을 추가할 수 있다. 그런데, 데이터스토어는 좀 다르다. 왜냐하면 일단 만들어진 객체의 키값은 절대 변경될 수 없는데, 트랜젹션으로 묶을 객체들은 생성 시점에 미리 같은 부모 객체를 지정해서, 같은 엔티티 그룹으로 만들어 줘야 하기 때문이다. 아마도 분산 트랜잭션을 피하기 위해서, 같은 그룹에 속한 객체들을 동일한(또는, 가급적 가까운?) 물리적인 노드에 두기 위함일테다.</p>

<p>또한 동시에 여러 명이 같은 데이터를 변경하는 등의 충돌을 방지하려면, 주의깊게 부모 엔티티를 고르거나 아예 이런 일이 없도록 설계하는 것이 중요하다. 이런 제약으로 인해, 개발 시점에 어떤 트랜잭션이 필요할 것인지를 미리 예측하고, 코드 레벨에서 부모 객체를 미리 만들어둬야 한다. 구체적인 예를 들자면, 어떤 플레이어에 속한 모든 아이템, 도전과제, 퀘스트 같은 하위 객체들은 플레이어를 부모로 가지는 게 정신 건강에 좋다는 정도가 되겠다.</p>

<p>이처럼 앱엔진 개발은 유지 보수의 책임이 데이터베이스가 아니라 프로그래머의 영역이 된다는 점을 항상 염두에 둬야 한다.</p>

<p><strong>키 이름(key_name), 아이디(id)의 용도를 잘 구분해야 한다.</strong></p>

<p>모든 객체는 시스템에서 유일한 키 값을 가진다는 점은 비교적 이해하기가 쉽다. 그런데, 키 이름(문자열)과 아이디(정수) 중 하나만을 가져야 한다는 점은 처음에 좀 헷갈렸다. 과연 어떤 객체에는 키 이름을 쓰고, 어디에는 아이디를 자동 생성해야 하는지가 할까? 처음엔, 해석을 잘못해서 키 이름이 시스템 전체에서 유일한 줄 알아서 많이 헤맸었는데, 알고보니 같은 모델(정확하게는 엔티티 그룹)안에서만 유일하면 된다는 것을 늦게서야 알게 되었다.</p>

<p>결론부터 말하자면, 내가 맞게 쓰고 있는 건지는 모르지만, 개발 시점에 미리 생성해둬야 하는 정적인 객체들(아이템 정보, 맵 정보, 밸런싱 데이터 등 유일성을 개발 시점에 파악할 수 있는 객체들)에게는 유일한 키 이름을 할당해서, 향후 빠른 변경 및 접근을 할 수 있게 하고, 런타임에 생성하기 때문에 유일성을 미리 파악하기 힘든 다른 수많은 객체들(계정, 플레이어, 아이템 인스턴스, 도전 과제 인스턴스 등)은 자동으로 아이디를 할당받게 하는 게 좋다.</p>

<p>그런데, 개발을 위해서 동일한 코드를 기반으로 서로 다른 app-id를 가진 구글 앱엔진 서버(Development - Test - Production)를 운영할 경우, 자동으로 만들어져서 아이디를 가진 객체들 - 특히나 ReferenceProperty 로 관계가 맺어진 넘들-을 다른 서버로 옮기는 것이 거의 불가능하다는 점에 유의해야 한다. 왜냐하면 객체의 키값에 이미 app-id 가 들어가 있기 때문에 CSV 등으로 백업해서 복원할 경우, 만약  기존에 동일한 id 를 가진 객체가 존재하면 그냥 덮어써버리기 때문이다. :(</p>

<p><strong>쿼리(datastore_v3.RunQuery)와 읽기(datastore_v3.Get)의 차이를 이해해야 한다.</strong></p>

<p>ReferenceProperty 를 이용하면, 1:N 의 관계를 표현할 수 있다. 아래의 코드처럼</p>

<p>[code language="python"]
class Player(db.Model):
  pass
class Item(db.Model):
  player = db.ReferenceProperty(Player,collection_name="items")
```</p>

<p>과 같이 정의된 경우, player.items 라는 역참조가 자동적으로 만들어진다. 문제는 이게 코드를 읽을 때에는 왠지 캐싱이 될 것처럼 보이지만, 내부적으로 datastore_v3.RunQuery 라는 RPC가 호출되기 때문에 매번마다 다시 데이터스토어에서 읽어온다는 점이다. 무조건 <a href="http://code.google.com/intl/ko-KR/appengine/docs/python/tools/appstats.html">appstat</a> 을 활성화시켜 두고, 조금이라도 반응 속도가 느린 요청이 있으면 항상 확인하는 버릇을 길러야 한다.</p>

<p>반대로 이미 키값을 알고 있는 item 의 소유자 이름을 읽어오려면, item.player.name 처럼만 하면 된다. 그런데 내부적으로 datastore_v3.Get 요청은 특정 필드만 읽어오는 기능을 지원하지 않기 때문에, 항상 모든 속성들이 다 읽어지게 된다. 더욱 무서운 점은 그냥 item.player 나 item.player.key() 라고만 해도 Get 요청이 이루어진다는 거다. 만약 참조하는 객체의 하위 속성이 아니라 오직 키값만 알고 있으면 되는 경우에는 model_name.reference_prop.get_value_for_datastore(entity) 를 이용하면, 코드는 더러워지지만 불필요한 요청을 피할 수 있다.</p>

<p>특히 루프 안에서 참조키의 하위 속성을 읽는 짓은 가급적 피하는 것을 권장한다.</p>

<p>[code language="python"]
for item in Item.all().filter():
  if item.player.hp == 0: # bad bad
  pass
```</p>

<p>계속 추가할 예정입니다 :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Client Network Utility]]></title>
    <link href="http://reiot.com/2005/09/23/client-network-utility/"/>
    <updated>2005-09-23T20:48:01+09:00</updated>
    <id>http://reiot.com/2005/09/23/client-network-utility</id>
    <content type="html"><![CDATA[<p>Enterprise Manager 로 접속해야 할 DB 가 custom port 를 사용하거나 VPN, 공유기 등의 문제로 name 기반의 접근이 안될 경우,
이 툴에서 TCP/IP 기반의 alias 를 만들어 두면 EM에 등록해서 연결할 수 있다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cwRsync 를 이용한 클라이언트 배포]]></title>
    <link href="http://reiot.com/2005/09/07/client-distribution-with-cwrsync/"/>
    <updated>2005-09-07T06:22:00+09:00</updated>
    <id>http://reiot.com/2005/09/07/client-distribution-with-cwrsync</id>
    <content type="html"><![CDATA[<h2>Overview</h2>

<p>한동안 메신저 + zip 파일 기반의 배포 시스템을 고집하다가 더 이상 참을 수가 없어서 결국 <a href="http://www.itefix.no/cwrsync/">cwRsync </a>라는 툴을 테스트 해보게 되었다. Cygwin + rsync + openssh 를 NullSoft 인스톨러로 깔끔하게 패키징한 이 유틸리티는 약간의 삽질 만으로 간편하면서도 공짜 파일 배포 시스템을 구축할 수 있게 해준다. 당연히 호스트 접근 제어도 가능하고, SSH 를 통해서만 배포할 수도 있다.</p>

<p>이전 프로젝트에서도 <a href="http://www.dillobits.com/insync.html">InSync </a>를 이용해서 팀 내부에 클라이언트를 배포했었다. 클라이언트 프로그래머가 최신 파일들을 특정 공유 폴더에다가 업데이트하면, 각자가 로컬에 설치된 프로그램을 실행해서 변경된 파일들을 받아오는 방식인데, 가끔 동시에 많은 사람이 업데이트를 받을 경우 문제가 있었고, 무엇보다도 shareware 여서 어둠과자를 사용해야만 했다.</p>

<h2>Install</h2>

<p>이번에 테스트한 것은 '안전하지 않은' no-ssh 배포 방식. 간단히 삽질한 내용을 정리해보면...</p>

<ul>
<li>우선 cwRsync 서버를 설치하고 rsyncd.conf 를 열어 모듈을 설정하라. 모듈은 rsync 로 파일을 받아갈 때의 대표 이름으로 CVS 의 그것과 같다. 일반적으로 서버측의 파일을 클라이언트에서 받아가므로 read only 는 true 로 설정할 것.</li>
</ul>


<p>[모듈명]
path = /cygdrive/드라이브/배포폴더
read only = true
transfer logging = yes</p>

<ul>
<li>prepare a directory for upload 명령을 실행해서 rsync 서버가 제대로 폴더를 읽고 쓸 수 있게 하라.</li>
<li>서비스는 기본적으로 꺼져 있는 상태. 자동 실행으로 만든 다음 서비스를 시작하라. 또한 방화벽에서 TCP 873 포트를 열어주는 것을 잊지 말 것.</li>
<li>클라이언트를 설치하고 배치 파일을 작성하라. 기본적으로 제공하는 cwrsync.cmd 파일을 복사한 다음 적절히 수정해주면 된다. 특정 rsync 서버의 모듈을 recursive 로 받아오려면 다음과 같이 하면 된다.</li>
</ul>


<p>rsync -avr 서버::모듈 /cygdrive/드라이브/다운받을폴더</p>

<ul>
<li>물론 로컬 파일을 업로드하려면 순서를 뒤집으면 된다. 이때 서버측에서 read only = false 여야만 가능하다.</li>
</ul>


<p>rsync -avr /cygdrive/드라이브/업로드할폴더 서버::모듈</p>

<h2>Filter</h2>

<p>rsync 는 강력한 파일 필터링 기능을 제공한다. 물론 커맨드라인으로 지정할 수도 있지만 수정을 쉽게 하려면 필터 파일을 만들어 두는 것을 권장.  자세한 도움말은 <a href="http://rsync.samba.org/ftp/rsync/rsync.html">rsync 도움말</a>을 참조할 것. 아래의 필터 파일 예제는 log/ upload/ 폴더 및 로그 파일, VSS 관련 파일들을 무시한다는 의미이다.</p>

<ul>
<li>log/</li>
<li>upload/</li>
<li>*.log</li>
<li>*.scc</li>
</ul>


<p>필터 파일을 지정하려면 '--exclude-from=필터파일명' 을 지정해주면 된다.</p>

<h2>마치며</h2>

<p>사실 내부 테스트를 위해서도 패치 시스템을 구축하는 것이 가장 좋겠지만, 보유중인 패치 시스템의 인터페이스가 간편하지 않다면 오히려 낭패... 차라리 부담없이 GNU 툴들을 도입해 보는 것이 정신 건강상 더 나을 듯하다.</p>

<p>그리고, 아무래도 안정적으로 파일을 배포하려면,
개발 머신 --(rsync)--> 패치 서버 --(rsync)--> 팀 배포
 의 2단계를 거치는 것이 좋은데, 이를 위해서는 서버에 같은 폴더를 나타내는 upload 모듈과 download 모듈을 만들어 둬야 한다. 또한 실행 파일만을 배포할 경우를 위한 배치 파일도 따로 만드는 것을 권장한다. (아무래도 recursive 로 검색을 하면 시간이 좀 걸린다)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[맨티스에 custom severity 추가!]]></title>
    <link href="http://reiot.com/2005/07/13/custom-severity-for-mantis-bt/"/>
    <updated>2005-07-13T00:05:56+09:00</updated>
    <id>http://reiot.com/2005/07/13/custom-severity-for-mantis-bt</id>
    <content type="html"><![CDATA[<p><img src="http://manual.mantisbt.org/mantis_logo.gif" title="mantis" ></p>

<p>오래전부터 맨티스에다가 중요도나 우선순위 상수를 추가해달라는 요청이 있었으나, 소스를 고쳐야 하기 때문에 방법이 없다고 모른 척 했었다가, 이번에 잠시 짬을 내어 추가를 해 보았다. 관련 자료를 아래에 정리했으니 심심할 때 한번 읽어보시길. :)</p>

<p>see also : <a href="http://reiot.cafe24.com/wiki/MantisCustomize">MantisCustomize </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MoniWiki Tips]]></title>
    <link href="http://reiot.com/2004/11/26/moniwiki-tips/"/>
    <updated>2004-11-26T23:21:26+09:00</updated>
    <id>http://reiot.com/2004/11/26/moniwiki-tips</id>
    <content type="html"><![CDATA[<h2>Security</h2>

<blockquote><p>$security_class="needtologin";</p></blockquote>

<h2>RcsLite</h2>

<blockquote><p>$version_class='RcsLite';</p></blockquote>

<h2>Disable Theme</h2>

<p>테마와 CSS 모두 강제 지정하려면 아래와 같이 할 것.</p>

<blockquote><p>$theme='...';</p>

<p>$theme_css=1;</p></blockquote>

<h2>MoinMoin Migration(?)</h2>

<p>MoinMoin 위키에서 MoniWiki 로 이전한 경우, 구글 등의 검색 엔진이나 지인들의 링크가 이전 주소로 되어 있는 경우, fake moin.cgi 를 만들어서 링크를 계속 유지시킬 필요가 있다.  특히 apache 환경에서는 .htaccess 설정을 이용해서 손쉽게 fake moin.cgi 를 만들 수 있다.  일단 아래와 같이 moin.cgi 를 만든다. 특별히 실행권한을 주지 않아도 무방하다.</p>

<blockquote><p>&lt;?php</p>

<p>chdir("/path/to/moniwiki");</p>

<p>include("wiki.php");</p>

<p>?></p></blockquote>

<ul>
<li>.htaccess 에 moin.cgi 를 php 가 핸들링하도록 다음과 같이 추가한다.</li>
</ul>


<blockquote><p><Files moin.cgi></p>

<p>SetHandler application/x-httpd-php</p>

<p></Files></p></blockquote>

<h2>파일 업로드 크기 제한</h2>

<p>이것은 모니위키의 문제가 아닌 php 의 문제이다. php.ini 에서 업로드 및 POST 크기 제한을 적절하게 수정해야 한다.</p>

<h2>xls 파일 업로드</h2>

<p>UploadFiles.php 에서 기본적으로 정의된 확장자가 아닐 경우 업로드가 금지된다. 따라서, 여기에 xls 확장자를 추가할 것.</p>

<blockquote><p>// plugin/UploadFile.php:71</p>

<p>$pds_exts="png|jpg|jpeg|gif|mp3|zip|tgz|gz|txt|css|exe|hwp|xls";</p></blockquote>

<h2>external link 제거</h2>

<p>한글로 된 외부 링크의 경우 URL 이 너무 길어져서 화면 크기를 넘어서는 경우가 있다. 아예 URL 표시를 제거하는 편이 더 좋을 듯?</p>

<blockquote><p>// wiki.php:1440</p>

<p>$external=$this->ex_bra.$url.$this->ex_ket;</p>

<p>$external=''; //  <link rel="icon" href="http://reiot.com/reiot.png" type="image/png" /></p></blockquote>

<p>see also:</p>

<ul>
<li>http://en.wikipedia.org/wiki/Favicon</li>
</ul>

]]></content>
  </entry>
  
</feed>
