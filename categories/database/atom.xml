<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: database | Social Reiot]]></title>
  <link href="http://reiot.com/categories/database/atom.xml" rel="self"/>
  <link href="http://reiot.com/"/>
  <updated>2012-01-22T10:06:24+09:00</updated>
  <id>http://reiot.com/</id>
  <author>
    <name><![CDATA[Ray Yun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Three Rules for Database Work]]></title>
    <link href="http://reiot.com/2008/11/15/three-rules-for-database-work/"/>
    <updated>2008-11-15T18:52:46+09:00</updated>
    <id>http://reiot.com/2008/11/15/three-rules-for-database-work</id>
    <content type="html"><![CDATA[<p><a href="http://www.openmaru.com/273"><img src="http://www.openmaru.com/attach/1/1046597520.jpg"></a>
<em><a href="http://www.openmaru.com/273">하루에 10만을 채우는 게임</a>은 이런 게 이벤트가 되는구나.</em></p>

<p>오늘자 코드 프로젝트에 올라온 <a href="http://www.codeproject.com/KB/architecture/DBTool.aspx">DBTool</a>의 근간이 된, <a href="http://odetocode.com/Blogs/scott/archive/2008/01/30/11702.aspx">데이터베이스를 갖고 놀 때의 세가지 룰</a>은 생각보다 간단했다.</p>

<h3>Never use a shared database server for development work.</h3>

<p>예전에는 (rails 스타일의) development-test-production 의 3단계 구분법을 사용했다. DBA와 서버 프로그래머는 dev DB에서 열심히 뒤집어 엎어도, test DB에 연결된 다른 프로그래머들이나 테스터들은 안정적으로 사용할 수 있고, 실제 서비스는 production 데이터베이스를 쓰게 된다는 거다.</p>

<h3>Always Have a Single, Authoritative Source For Your Schema</h3>

<p>DB 에 짧지만 단순한 나의 지론은, 레파지토리 어딘가에 무조건 전체 스키마+초기데이터를 담은 SQL 파일을 두고 버전 관리를 해야 한다는 거다. 소스 코드, 애셋들은 과거의 특정 시점의 스냅샷을 꺼내올 수 있는데, 유독 데이터베이스가 열외일 수는 없다고 본다.</p>

<p>또한 어차피 데이터베이스 패치를 해야 할 테니, create, alter로 가득찬 DB 패치 스크립트도 버전 관리해야 한다. test -> production 를 업그레이드할 때 모두 지우고 새로 만드는 만행을 할 수 없을테니, 아예 dev -> test 에서부터 미리 스크립트를 만들어서 테스트하면 정신 건강에 좋지 않겠냔 말이다. 처음에 언급한 DBTool 이 이런 걸 자동화해주는 모양이다.</p>

<h3>Always Version Your Database</h3>

<p>보통은 Config 테이블에다가 문자열로 데이터베이스 스키마 최종 변경일을 넣어두는 걸로 해결하고 있다. 그런데 아직 뭔가 변경이 잘 되었는지를 체크할 만한 테스트를 만들 능력은 안된다. 대체로 alter 든 drop 이든 서버가 뜰 때까지는 잘 모를것 같아서.. :)</p>

<p>이 외에도 무시무시하게 긴 <a href="http://www.ssw.com.au/ssw/Standards/Rules/RulesToBetterSQLServerDatabases.aspx">Better SQL Server Databases</a> 라는 규칙도 있는데 이건 좀 귀찮구나....</p>

<p>추가:</p>

<pre><code>- 다른 글을 찾아 보니, 프로시저나 테이블 각각을 서로 다른 파일에 저장해서 관리하라는 말도 있다. 은근히 그럴듯한데?
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Apps]]></title>
    <link href="http://reiot.com/2008/07/02/google-apps/"/>
    <updated>2008-07-02T06:26:04+09:00</updated>
    <id>http://reiot.com/2008/07/02/google-apps</id>
    <content type="html"><![CDATA[<p><img src="http://www.google.com/a/help/intl/ko/images/150x55.gif"></p>

<p>회사 법인 카드를 빌려서 냉큼 <a href="http://google.com/a">google apps</a>를 신청했다. 비용은 고작 도메인값 $10/year.</p>

<p>예전에 이 서비스가 처음 나왔을 때 .com 이름으로 하려다가 <a href="http://whois.co.kr/">whois.co.kr</a>에서 CName 레코드 편집을 지원해주지 않아서 포기했다가, N모사에서 <a href="http://google.com/a">google apps</a>로 거의 마이그레이션했다는 이야기를 듣고 용기를 내서, 오늘자로 .net 이름을 구글에서 바로 등록해버렸다.</p>

<p>우리 회사의 경우 미국 본사랑 한국 지사 2군데에서 동시 접근 가능한 솔루션이 필요한데, 본사에다 설치하면 우리는 방화벽 + VPN 을 통해서 접근해야 해서 속도도 느리고, 또 주기적으로 시스템 보안 체크도 해줘야 하는 부담이 있다. (패스워드 1234로 쓰는 사람 정말 싫다..) 반대로 우리 인트라넷을 본사의 누군가가 접근하도록 포트를 열어주는 일도 생각보다 피곤한 일이다. 이걸 구글로 옮기면 속도도 빠르고 보안 관리도 신경쓰지 않아도 되니, <a href="http://news.cnet.com/8301-10784_3-9875714-7.html">쿠웨이트에서 발생한 ISP 캐시 문제</a> 같은 일만 안생기면 진짜 편할텐데... 회사 자산을 외부에 둔다는 걸 설득하는 일이 만만치 않아서 포기하고 있는 상태다.</p>

<p>게다가, 일전에 <a href="http://www.37signals.com/">37signals</a> 의 <a href="http://www.basecamphq.com/">basecamp</a> 서비스를 전사적으로 도입했다가 특유의 느린 반응 속도 때문에, 서서히 용도폐기되어 가는 걸 직접 겪었기 때문에, 이번에는 큰 욕심 없이 우리 회사 DBA랑 단둘이서 <a href="http://docs.google.com">google docs</a>랑 캘린더 위주로 테스트 삼아 써볼 계획이다. 쓰다가 효용성을 깨닫게 되면 어떻게든 누군가에게 전파되려니 하고 '긍정적'으로 생각중이다. 흘흘.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[데드락 추적하기]]></title>
    <link href="http://reiot.com/2006/12/19/%E1%84%83%E1%85%A6%E1%84%83%E1%85%B3%E1%84%85%E1%85%A1%E1%86%A8-%E1%84%8E%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5/"/>
    <updated>2006-12-19T07:22:28+09:00</updated>
    <id>http://reiot.com/2006/12/19/데드락-추적하기</id>
    <content type="html"><![CDATA[<ul>
<li>원문 : <a href="http://support.microsoft.com/kb/832524">How to resolve a deadlock</a></li>
</ul>


<p>SQL 서버에서 데드락이 걸리면 락 매니저는 그 중 하나를 victim 으로 삼아서 죽이게 된다. 문제는 기본 설정 만으로는 어떤 SQL문끼리의 충돌인지를 확인할 수 없다는 점인데, SQL Server 에러 로그를 이용해서 이를 쉽게 알아낼 수 있다.</p>

<h2>normal deadlock</h2>

<p>dbcc traceon(1204,3605,-1) 를 이용하면, 데드락 이벤트(1204)가 발생할 경우 에러 로그에 남길 수 있다. -1 은 세션 설정이 아닌 서버 전역 설정을 의미한다. 가장 좋은 방법은 시스템 시작 파라미터에다가 -T1204 를 넘겨주는 방식. 단 성능에 문제가 있을 수 있으므로, 데드락을 잡고 나서 끄는 것을 잊지 말도록.</p>

<p>주기적으로 sp_readerrorlog 또는 엔터프라이즈 매니저에서 확인해보다 보면 아래와 같은 로그가 나올 때가 있다.</p>

<p>```</p>

<p>Deadlock encountered .... Printing deadlock information 0
2006-12-13 14:31:13.11 spid4    0
2006-12-13 14:31:13.11 spid4  Wait-for graph    0
2006-12-13 14:31:13.11 spid4    0
2006-12-13 14:31:13.11 spid4  Node:1    0
2006-12-13 14:31:13.11 spid4  RID: 8:1:3534:228  CleanCnt:1 Mode: X Flags: 0x2  0
2006-12-13 14:31:13.11 spid4  Grant List 2::    0
2006-12-13 14:31:13.11 spid4  Owner:0x4ae74ca0 Mode: X  Flg:0x0 Ref:0 Life:02000000 SPID:64 ECID:0  0
2006-12-13 14:31:13.11 spid4  SPID: 64 ECID: 0 Statement Type: UPDATE Line #: 12    0
2006-12-13 14:31:13.11 spid4  Input Buf: Language Event: insert into take_time_table (type, name, userID, takeTime) values (4, 'PickupServerApp', 50780, 6493)  0
2006-12-13 14:31:13.11 spid4  Requested By:     0
2006-12-13 14:31:13.11 spid4  ResType:LockOwner Stype:'OR' Mode: S SPID:58 ECID:0 Ec:(0x778C9508) Value:0x7321ac20 Cost:(0/1BC) 0
2006-12-13 14:31:13.11 spid4    0
2006-12-13 14:31:13.11 spid4  Node:2    0
2006-12-13 14:31:13.11 spid4  RID: 8:1:3535:117  CleanCnt:1 Mode: X Flags: 0x2  0
2006-12-13 14:31:13.11 spid4  Grant List 1::    0
2006-12-13 14:31:13.11 spid4  Owner:0x3e54c7c0 Mode: X  Flg:0x0 Ref:0 Life:02000000 SPID:58 ECID:0  0
2006-12-13 14:31:13.11 spid4  SPID: 58 ECID: 0 Statement Type: CONDITIONAL Line #: 8    0
2006-12-13 14:31:13.11 spid4  Input Buf: Language Event: insert into take_time_table (type, name, userID, takeTime) values (2, 'GatewayServerApp', 50977, 0)    0
2006-12-13 14:31:13.11 spid4  Requested By:     0
2006-12-13 14:31:13.11 spid4  ResType:LockOwner Stype:'OR' Mode: U SPID:64 ECID:0 Ec:(0x611CD508) Value:0x4ae74e20 Cost:(0/134) 0
2006-12-13 14:31:13.11 spid4  Victim Resource Owner:    0
2006-12-13 14:31:13.11 spid4  ResType:LockOwner Stype:'OR' Mode: U SPID:64 ECID:0 Ec:(0x611CD508) Value:0x4ae74e20 Cost:(0/134) 0</p>

<p>```</p>

<p>위 로그에 의하면 single insert statement 2개를 동시에 실행할 때 데드락이 걸렸다. 처음에는 legacy 서버에서 스토어드 프로시저 대신 raw SQL을 실행했기 때문에 발생된 것으로 추측했는데, 논리적으로 이 둘이 데드락을 유발시키기는 좀 힘든 상황이었다. 이 경우 dbcc page 명령을 이용하면, 구체적으로 어떤 메모리 페이지에서 락이 걸렸는지를 확인해볼 수 있다. 위 로그에서 RID 부분을 찾아서 넘겨주면 끝. (단 이 명령을 실행하면 역시나 에러 로그에 남기 때문에, 나중에 보고 놀래지 말 것!)</p>

<p>[sql]
dbcc page(8,1,3534,3)
dbcc page(8,1,3535,3)
[/sql]</p>

<p>결국 문제는 저 테이블에는 <strong>다른 테이블로 또다시 select &amp; insert 하는 무지몽매한 트리거(-_-)</strong>가 걸려 있어서 생긴 문제였다. 하아.</p>

<h2>Key deadlock</h2>

<p>이번엔 키 데드락 로그를 살펴보자. 이 경우 RID 대신 KEY 라고 나오는데, SELECT OBJECT_NAME(KeyID) 를 이용해서 어떤 오브젝트에서 락이 걸렸는지를 알아낼 수 있다.</p>

<p>```</p>

<p>Deadlock encountered .... Printing deadlock information 0
2006-12-20 20:37:35.73 spid4    0
2006-12-20 20:37:35.73 spid4  Wait-for graph    0
2006-12-20 20:37:35.73 spid4    0
2006-12-20 20:37:35.73 spid4  Node:1    0
2006-12-20 20:37:35.73 spid4  KEY: 8:612197231:1 (5000dcb808b7) CleanCnt:1 Mode: Range-S-U Flags: 0x0   0
2006-12-20 20:37:35.73 spid4  Grant List 1::    0
2006-12-20 20:37:35.73 spid4  Grant List 3::    0
2006-12-20 20:37:35.73 spid4  Owner:0x25bdf860 Mode: Range-S-S Flg:0x0 Ref:0 Life:02000000 SPID:69 ECID:0   0
2006-12-20 20:37:35.73 spid4  SPID: 69 ECID: 0 Statement Type: EXECUTE Line #: 0    0
2006-12-20 20:37:35.73 spid4  Input Buf: RPC Event: sp_cursoropen;1 0
2006-12-20 20:37:35.73 spid4  Requested By:     0
2006-12-20 20:37:35.73 spid4  ResType:LockOwner Stype:'OR' Mode: X SPID:57 ECID:0 Ec:(0x39939508) Value:0x5223ee00 Cost:(0/1070)    0
2006-12-20 20:37:35.73 spid4    0
2006-12-20 20:37:35.73 spid4  Node:2    0
2006-12-20 20:37:35.73 spid4  KEY: 8:612197231:1 (d000bebebbe4) CleanCnt:2 Mode: X Flags: 0x0   0
2006-12-20 20:37:35.73 spid4  Wait List:    0
2006-12-20 20:37:35.73 spid4  Owner:0x3dc49b20 Mode: S  Flg:0x0 Ref:1 Life:00000000 SPID:65 ECID:0  0
2006-12-20 20:37:35.73 spid4  SPID: 65 ECID: 0 Statement Type: SELECT Line #: 1 0
2006-12-20 20:37:35.73 spid4  Input Buf: Language Event: select b.charid from user_table a join char_table b on a.userid=b.userid where b.disable=0 and b.usertype=2 and a.username='throwrocks@me.com' 0
2006-12-20 20:37:35.73 spid4  Requested By:     0
2006-12-20 20:37:35.73 spid4  ResType:LockOwner Stype:'OR' Mode: Range-S-S SPID:69 ECID:0 Ec:(0x3A7A1548) Value:0x68dded80 Cost:(0/0)   0
2006-12-20 20:37:35.73 spid4    0
2006-12-20 20:37:35.73 spid4  Node:3    0
2006-12-20 20:37:35.73 spid4  KEY: 8:612197231:1 (d000bebebbe4) CleanCnt:2 Mode: X Flags: 0x0   0
2006-12-20 20:37:35.73 spid4  Grant List 1::    0
2006-12-20 20:37:35.73 spid4  Owner:0x4f336b40 Mode: X  Flg:0x0 Ref:0 Life:02000000 SPID:57 ECID:0  0
2006-12-20 20:37:35.73 spid4  SPID: 57 ECID: 0 Statement Type: UPDATE Line #: 135   0
2006-12-20 20:37:35.73 spid4  Input Buf: RPC Event: U_CharacterSaveLocker;1 0
2006-12-20 20:37:35.73 spid4  Requested By:     0
2006-12-20 20:37:35.73 spid4  ResType:LockOwner Stype:'OR' Mode: S SPID:65 ECID:0 Ec:(0x74FA7548) Value:0x3dc49b20 Cost:(0/0)   0
2006-12-20 20:37:35.73 spid4  Victim Resource Owner:    0
2006-12-20 20:37:35.73 spid4  ResType:LockOwner Stype:'OR' Mode: S SPID:65 ECID:0 Ec:(0x74FA7548) Value:0x3dc49b20 Cost:(0/0)   0
2006-12-20 20:37:40.73 spid4    0
```</p>

<h2>DBCC PSS</h2>

<p>DBCC PSS(uid [, spid]) 를 통해서 특정 pid 의 다양한 속성들을 알 수 있다. uid 는 select * from sysusers 로 체크하고, 프로세스는 sp_who2 로 알아내면 된다. 물론 spid 를 생략하면 해당 유저의 모든 프로세스의 정보가 뜬다.</p>

<p>```</p>

<h2>PSS @0x1B9E71E0</h2>

<p>pspid = 53  m_dwLoginFlags = 0x03e0  plsid = 1827921760
pbackground = 0</p>

<h2>pbSid</h2>

<p>81ee3246 10030a4a 8c19c980 f40a127f  ..2F...J........
sSecFlags = 0x2  pdeadlockpri = 0  poffsets = 0x0
pss_stats = 0x0  ptickcount = 905625531
pcputickcount = 2711581261636168  ploginstamp = 313917
ptimestamp = 2006-12-18 03:18:26.550  plangid = 0
pdateformat = 1  pdatefirst = 7  Language = us_english
UserName = ubo_game  poptions = 0x28400020  poptions2 = 0x3f438
pline = 1  pcurstepno = 0  prowcount = 1
pstatlist = 0  pcurcmd = 253  pseqstat = 0
ptextsize = 2147483647  pretstat = 0  CNestLevel = 0
@@procid = 0  pslastbatchstarttime = 2006-12-21 23:36:14.363
pmemusage = -2095  hLicense = 0  tpFlags = 0x1
isolation_level = 0  fips_flag = 0x0  sSaveSecFlags = 0x0
psavedb = 0  pfetchstat = 0  pcrsrows = 0
pslastbatchtime = 2006-12-21 23:36:14.363  pubexecdb = 0
fInReplicatedProcExec = 0 pMsqlXact = 0x6D6AD038  presSemCount = [0]0
presSemCount = [0]0  pcputot = 5182694  pcputotstart = 5182694
pcpucmdstart = 5182694  pbufread = 346  pbufreadstart = 346
plogbufread = 11300361  plogbufreadstart = 11300354
pbufwrite = 6374  pbufwritestart = 6374  pLockTimeout = 4294967295
pUtilResultSet = 0x00000000
```</p>

<p>[sql]
SET SHOWPLAN_ALL ON
SET STATISTICS PROFILE ON
[/sql]
DB에 문제가 생기면 언제나 무료로 컨설팅해주시는 <a href="http://changaya.tistory.com">자칭 초보 DBA 창아군</a>에게 Special Thanks를 보낸다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Online SQL beautifier]]></title>
    <link href="http://reiot.com/2006/11/16/online-sql-beautifier/"/>
    <updated>2006-11-16T08:40:15+09:00</updated>
    <id>http://reiot.com/2006/11/16/online-sql-beautifier</id>
    <content type="html"><![CDATA[<p><img src="http://www.wangz.net/gsqlparser/sqlpp/sqlpponline.gif" title="sqlpponline" ></p>

<p>어제 갑자기 DB에 문제가 생겨서 여러 사람이 손댄 프로시저를 읽다가 도저히 적응이 안되어서 <a href="http://www.google.co.kr/search?q=SQL+beautifier">구글로 SQL Beautifier를 검색</a>해 보았다. 그 중에서 무료이면서 가장 쓸만한 웹 기반의 SQL beautifier가 바로 <a href="http://www.wangz.net/cgi-bin/pp/gsqlparser/sqlpp/sqlformat.tpl">Instant SQL Formatter</a> 이었다. 물론 Visual Studio 나 Query Analyzer에 연동하려면 클라이언트 버전도 있지만, 40 달러 정도 돈을 내야 한다.</p>

<p>혹시나 이 보다 더 좋은 넘이 있다면 리플을 달아주시기 바란다. MS는 왜 이런 걸 기본으로 내장하지 않나 몰라.</p>

<ul>
<li>빈태님이 <a href="http://www.red-gate.com/products/SQL_Refactor/index.htm">SQL refactor</a>를 추천해주셨다. 감사..</li>
<li>오늘 어떤 프로시저에서 또다른 프로시저를 호출하다가 @@transcount 가 0 -> 1 로 변하는 에러를 처음 발견했다. 아직 정확한 이유는 모르지만, 이런 에러 처음이야~</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OTL Tips]]></title>
    <link href="http://reiot.com/2006/09/20/otl-tips/"/>
    <updated>2006-09-20T16:52:38+09:00</updated>
    <id>http://reiot.com/2006/09/20/otl-tips</id>
    <content type="html"><![CDATA[<p><strong><em>[공지사항] 이 글은 더이상 업데이트되지 않으며, 최신 버전은<a href="http://reiot.springnote.com/pages/87217"> http://reiot.springnote.com/pages/87217</a>에서 읽으실 수 있습니다. </em></strong></p>

<p><a href="http://otl.sourceforge.net/">OTL</a>은 ODBC를 잘 래핑한 오픈소스 DB 쿼리 라이브러리이다. 헤더 파일 하나만 있으면, 굳이 ODBC 래퍼 클래스를 만들지 않아도 충분히 안심하고 쓸 수 있으며, MYSQL, MSSQL, ORACLE 모두에 사용될 수 있다. 꽤 여러 곳에서 사용되고 있고, 평판도 좋다고 알려져 있어서 써봤는데, 대략 반년동안 사용해본 경험으로는, 차라리 OLE DB 를 쓰거나, ODBC 래핑 라이브러리를 어딘가에서 갖다 쓰는 게 더 개발기간을 단축시킬 수 있다고 판단된다. OTL 만의 미묘한 버그스러움이 너무 많기에... '''비추천'''이었다. 그러나 최근에 legacy code를 손보면서 raw ODBC 코드를 만지다가 결국 포기하고 다시 OTL을 도입한 적도 있어서, 뭐라고 표현하기는 난감하지만 하나 확실한 건, ODBC를 직접 만지는 것보다는 백만배 정도 나으므로, 한번 써보기를 권한다.</p>

<h3>data binding</h3>

<p>OTL type 과 ODBC type 과의 대응표를 잘못 기억했다가는 마감 시간에 낭패를 보는 경우가 있다. 특히 헷갈리는 타입들을 적어본다.</p>

<table>
<thead>
<th>ODBC</th>
<th>OTL</th>
<td>bit</td>
<td>int</td>
<td>tinyint</td>
<td>int</td>

<tr>
<td>smallint</td>
<td>short</td>
</tr>
<tr>
<td>datetime/smalldatetime</td>
<td>char[N] (only for explicit-binding select)</td>
</tr>
</thead></table>


<p>implicit_select 에서는 datetime -> string 바인딩은 지원되지 않으므로, convert() 등으로 변환해서 string 으로 받아야 한다. 그런데, explicit binding select 에서는 웬지 지원이 된다. 이유는....모른다... <img src="http://boxcatstudio.files.wordpress.com/2009/07/icon_sad.gif" title="(" ></p>

<p>timestamp 타입을 받으려면 아무래도 otl_datetime 을 사용하는 편이 좋을 것 같다. 그리고, built-in type 으로 바인딩을 하는 것보다는, otl_value<T>를 쓰면 NULL 체크도 되니깐 추천.</p>

<h3>output parameter + implicit_select</h3>

<p>잘 되던 프로시저의 output 파라미터의 값이 이상해진다든지 꼬일 경우, 새로 추가된 로직에 select 가 들어가있는지를 확인할 것. (ODBC의 한계는 아닌 듯한데) OTL에서의 프로시저는 output 파라미터만을 가지든, implicit_select 만을 하든, 둘 중 하나만 해야 한다. 아래와 같이 둘 다 할 경우 바보가 된다.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">procedure</span> <span class="n">test_proc</span>
</span><span class='line'><span class="o">@</span><span class="n">param</span> <span class="nb">int</span> <span class="k">output</span>
</span><span class='line'><span class="k">AS</span>
</span><span class='line'><span class="p">....</span>
</span><span class='line'><span class="k">SELECT</span> <span class="n">something</span> <span class="k">FROM</span> <span class="n">tbl</span>
</span><span class='line'><span class="n">IF</span> <span class="o">@@</span><span class="n">error</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&gt;</span> <span class="mi">0</span> <span class="k">OR</span> <span class="o">@@</span><span class="n">rowcount</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&gt;</span> <span class="n">N</span>
</span><span class='line'><span class="p">....</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>위와 같은 코드들은 assignment select 로 해결하면 된다.</p>

<h3>otl_implicit_select</h3>

<p>output parameter 가 아닌, 내부에서 select 를 하는 프로시저의 경우 이 옵션을 명시해줘야 한다. 주의할 점은, datetime 이나 smalldatetime 을 내부에서 select 하고, OTL 에서 스트링으로 받으면 incompatible datatype 예외가 던져진다. 이때에는 varchar(N)으로 cast/convert 하는 것을 권장한다.</p>

<h3>SET NOCOUNT ON/OFF</h3>

<p>OTL/ODBC 의 가장 극악한 버그(?) 중의 하나이다.</p>

<p>OTL 은 @@rowcount 와 다른 output parameter 또는 select 결과를 구분할 수 없다고 한다. 그래서, SET NOCOUNT 를 설정해야만 프로시저에서 값을 제대로 읽어올 수 있다. (이 문제 때문에 얼마나 많은 시간을 날려버렸던가!! 만약 OTL 에서 프로시저를 제대로 실행할 수 없다면 90% 는 이 문제라고 보면 된다.)</p>

<p>주의할 점은, 프로시저 내부에서 다른 프로시저를 호출할 때 하위 프로시저에서 SET NOCOUNT OFF 를 해 버리면 그 뒤의 결과값 역시 꼬여버리게 된다는 점이다. 따라서, '''OTL 에서 직접 호출하는 프로시저의 시작과 끝에만 SET NOCOUNT 를 설정하고, 다른 프로시저에서는 절대 사용하지 말 것을 권장한다.'''</p>

<h3>Multiple ResultSet</h3>

<p>OTL/ODBC 에서는 공식 지원하지 않는다. 실제로 해보면 첫번째 result set 은 잘 받지만 두번째 이후부터는 eof() 가 되어 버린다. 결국, 해킹을 하거나 포기하는 수 밖에 없는데... 그래도 강제 실행을 시도해보겠다면 대략 다음과 같이 해 보기를... (내부 구조가 복잡해서 결국 포기했지만...)</p>

<p>otl_stream stmt(1,
"{CALL get_multi_resultset(:p&lt;int,in>)}",
conn,
otl_implicit_select);
stmt &lt;&lt;(int)1;
otl_cur &amp; s = (**stmt.ss).cursor_struct;
SQLRETURN result = SQLMoreResults( s.cda );</p>

<h3>Binding varchar</h3>

<p>문자열 바인딩시 NULL 을 위한 공간을 2바이트씩 예비해두어야 한다. 예를 들면, otl_statement 로 바인딩시 VARCHAR(10) 컬럼의 값을 읽거나 쓰려면 :XXX&lt;char[12]> 를 사용해야 한다는 뜻이다.</p>

<h3>Constant SQL Statements</h3>

<p>dynamic binding 이 필요없을 경우 otl_cursor::direct_exec() 를 사용해야 한다. '''반대로 말하면 otl_stream 에 static sql 을 사용하지 말라!''' rpc 를 알고 싶다면 otl_cursor::direct_exec() 의 리턴값을 사용하면 된다.</p>

<h3>otl_connect::auto_commit_on()</h3>

<p>otl_cursor::direct_exec() 를 이용해서 insert/delete 를 호출할 경우, 암시적인 트랜잭션이 발생해서 관련된 테이블이나 row 에 IX 를 걸게 된다. 따라서 다른 커넥션(otl_connect)에서 관련 테이블에 쿼리를 하게 되면 블로킹되는 불상사가 발생할 수 있다. 또는 아예 처음부터 커넥션 자체에 auto_commit_on()를 설정해서, 매 쿼리 실행마다 자동적으로 commit 를 하도록 하면 좋다.</p>

<p>otl_stmt::set_commit()도 비슷한 역할을 하는 게 아닐까 추측한다.  그런데, 이 옵션을 켰을 때 동일 커넥션에 대해서 여러번 쿼리를 하는 경우 이미 사용중이라는 에러 메시지가 나온다. 도대체.... ㅠㅠ</p>

<h3>ODBC Connection Pooling 기능 추가하기</h3>

<p>OTL을 ThreadPooling 과 함께 사용하기 위해서는 Connection Pooling 이 필수적이다. (그렇지 않으면 Thread Local Storage를 사용해야 하는데, 이는 권장하지 않는다고 빌게이츠가 말했다 ㅎㅎ)</p>

<p>테스트삼아, 단순한 SELECT COUNT(*) FROM XXX를 ThreadPooling 을 이용해서 로컬랜에 설치된 MSSQL 서버에 N번 쿼리를 큐잉하고 GetTickCount()로 시간을 체크해보았다. 이때, 풀링을 사용할 경우 평균 쿼리 시간이 5ms 정도 낮게 나왔으며 최소 쿼리 시간이 0 인 횟수가 꽤 많이 나왔다. 풀링을 하지 않을 경우에는 99% 의 확률로 10ms 이상의 시간이 소모되었다.</p>

<pre><code>- 주의사항 i. shared environment 생성 전, 즉 rlogin() 전에 풀링을 설정해야 한다!! i. env 즉 프로세스당 풀링 대신 시스템 전체에서 연결을 풀링하고 싶다면 SQL_CP_ONE_PER_DRIVER(?)를 사용하면 된다.
</code></pre>

<p>inline
bool SQL_OK ( SQLRETURN nResult )
{
return nResult == SQL_SUCCESS || nResult == SQL_SUCCESS_WITH_INFO;
}</p>

<p>void EnableConnectionPooling()
{
// enable connection pooling per environment
SQLRETURN ret = SQLSetEnvAttr(SQL_NULL_HANDLE,
SQL_ATTR_CONNECTION_POOLING,
(LPVOID)SQL_CP_ONE_PER_HENV,
0);
BOOST_REQUIRE( SQL_OK(ret) );
}</p>

<p>void DisableConnectionPooling()
{
SQLRETURN ret = SQLSetEnvAttr(SQL_NULL_HANDLE,
SQL_ATTR_CONNECTION_POOLING,
(LPVOID)SQL_CP_OFF,
0);
BOOST_REQUIRE( SQL_OK(ret) );
}</p>

<p>bool IsConnectionPooling()
{
DWORD value;
SQLRETURN ret = SQLGetEnvAttr(SQL_NULL_HANDLE,
SQL_ATTR_CONNECTION_POOLING,
&amp;value,
0,
NULL);
BOOST_REQUIRE( SQL_OK(ret) );</p>

<p>if ( value == SQL_CP_ONE_PER_HENV || value == SQL_CP_ONE_PER_DRIVER )
{
return true;
}
else if ( value == SQL_CP_OFF )
{
return false;
}
else
{
BOOST_ERROR( "error" );
}
return false;
}</p>

<h3>precreated handle 사용하기</h3>

<p>Connection Pooling 을 사용할 때, otl_connect::rlogin()을 쓰게 되면 매번마다 id/passwd 를 파싱하고 environment handle 을 생성하는 등 불필요한 부하가 있다. 따라서 미리 shared environment handle 을 하나 할당하고, hdbc handle 도 만들어서 객체를 생성하면 비교적 나을 것이다.</p>

<h3>스트림 풀링</h3>

<p>스트림의 풀이 otl_connect 객체 내부에 존재하므로, 이 객체를 항상적으로 유지해야만 풀링의 효과를 볼 수 있다.</p>

<h3>테스트 결과</h3>

<p>1000개의 단순쿼리(SELECT COUNT(*) FROM XXX)를 ThreadPooling을 이용해서 처리, 그 시간을 살펴보았다. 첫번째를 제외하고는 모든 상황에서</p>

<pre><code>- NO_POOLING : 매 작업마다 재연결 시도
- POOLING : 단지 ODBC Connection Pooling 옵션만 설정하고 위와 같음
- ODBC_POOLING : 미리 env 1개를 생성하고 매 작업마다 hdbc handle 만 생성해서 쿼리하기
- OTL_POOLING : 아예 otl_connect 객체를 자체 풀링시킴
- OTL_POOLING_NO_STREAM_POOLING : 위와 같지만 ODBC 풀링과 스트림 풀링을 끈 상태
</code></pre>

<table>
<thead>
<th>Query Type</th>
<th>minTick</th>
<th>maxTick</th>
<th>avgTick</th>
<th>#threads</th>
<td>NO_POOLING</td>
<td>0</td>
<td>47</td>
<td>12</td>
<td>4</td>
<td>POOLING</td>
<td>0</td>
<td>47</td>
<td>10</td>
<td>4</td>

<tr>
<td>ODBC_POOLING</td>
<td>0</td>
<td>78</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>OTL_POOLING_NO_STREAM_POOLING</td>
<td>0</td>
<td>78</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>OTL_POOLING</td>
<td>0</td>
<td>32</td>
<td>0</td>
<td>2</td>
</tr>
</thead></table>


<p>결론적으로 otl_connect 객체를 자체적으로 풀링하는 방법이 가장 빨랐다. 그러나, 스트림 풀링을 끄면 2위인 ODBC_POOLING과 비슷한 걸로 봐서 스트림 풀링의 비용이 꽤 높다는 것을 알 수 있다. (쿼리 자체를 좀더 복잡하게 해서 테스트해야 나을 거 같다.)</p>

<p>see also:</p>

<pre><code>- http://snaiper80.cafe24.com/wiki/wiki.cgi?OTL
</code></pre>
]]></content>
  </entry>
  
</feed>
