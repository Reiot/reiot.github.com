<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Social Game Developer wandering strange dungeon...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	<div class="row">
		<div class="span9">
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/06/01/stl-tips/">STL Tips</a> <small>2006-06-01</small></h1>
	</div>
	<div><pre><code></code></pre>

<pre><code>***이 페이지는 더이상 업데이트되지 않으며, 최신 버전은 http://reiot.springnote.com/pages/87168에서 보실 수 있습니다.***```
</code></pre>

<pre><code>## dll + STL

dll 에서 hash_set 을 멤버로 가진 클래스를 만들려다가 nested class 인 _Hash 라든지 hash_compare 등등을 모두 dllexport 하라길래 포기하고 PIMPL 패턴으로 해결해야만 했다.

    - [How To Exporting STL Components Inside &amp; Outside of a Class](http://support.microsoft.com/default.aspx?scid=kb;EN-US;168958)

## boost::lambda

아래의 mem_fun_if 류와 비슷한 역할을 하는 것이 바로 boost::lambda 라이브러리다. 일단 아래처럼 포인터 컨테이너를 순회하면서 NOT NULL 일 경우에 특정 멤버 함수를 호출하는 예제를 살펴보자.

</code></pre>

<p>for_each( l.begin(), l.end(),<br />
if_then( _1 != constant((A*)NULL), bind( &amp;A::print, _1 ) ) );</p>
<pre><code>lambda 라이브러리를 사용하면 위와 같이 간단한 코드로 표현이 가능하다. 대신 컴파일 속도는... ㅠㅠ
## mem_fun_if

일반적으로 포인터 컨테이너를 순회하면서 특정 조건을 만족할 경우 멤버 함수를 호출하는 패턴을 위한 자작 adapter function 이다. (물론 const 버전과 파라미터 1개를 받는 버전, 합쳐서 총 4개의 클래스와 4개의 함수를 만들어야 하지만... 시간상 생략)

</code></pre>

<dl>
<dt>template<class _Pred, class _Result, class _Ty></dt>
<dt>class mem_fun_if_t : public unary_function&lt;_Ty *, _Result&gt;</dt>
<dt>{</dt>
<dt>public:</dt>
<dt>explicit mem_fun_if_t( _Pred pred, _Result (_Ty::*_Pm)())</dt>
<dd>_pred(pred), _Pmemfun(_Pm), _count(0)<br />
  {<br />
  }</dd>
</dl>
<p>// 단점이라면 멤버함수의 리턴값은... 도무지 캐치불가능...<br />
  bool operator()(_Ty <em>_Pleft) const<br />
  {<br />
  if ( _pred(_Pleft) )<br />
  {<br />
  ((_Pleft-&gt;</em>_Pmemfun)());<br />
_count++;<br />
  return true;<br />
  }<br />
  return false;<br />
  }</p>
<p>int count() const { return _count; }</p>
<p>private:<br />
_Pred _pred;  // predicate<br />
_Result (_Ty::*_Pmemfun)(); // the member function pointer<br />
mutable int _count;<br />
};</p>
<p>template<class _Pred, class _Result, class _Ty><br />
inline<br />
mem_fun_if_t&lt;_Pred,_Result, _Ty&gt;<br />
mem_fun_if(_Pred pred,_Result (_Ty::*_Pm)())<br />
{<br />
  return (mem_fun_if_t&lt;_Pred,_Result, _Ty&gt;(pred,_Pm));<br />
}</p>
<pre><code>이를 이용한 샘플이다.

</code></pre>

<p>using namespace std;</p>
<p>class A<br />
{<br />
public :<br />
  explicit A( const string &amp; s ): str(s) {}<br />
  void print() { cout &lt;&lt;str &lt;&lt;endl; }<br />
string str;<br />
};</p>
<h1>define not_null(T) bind2nd( not_equal_to<T*>(), (T*)0)</h1>
<p>int _tmain(int argc, _TCHAR* argv[])<br />
{<br />
list<A*> l;<br />
l.push_back( new A("Hello") );<br />
l.push_back( NULL );<br />
l.push_back( new A("World") );<br />
l.push_back( NULL );<br />
l.push_back( new A("!") );</p>
<p>for_each( l.begin(), l.end(), mem_fun_if( bind2nd( not_equal_to<A*>(), (A*)0 ), &amp;A::print ) );<br />
for_each( l.begin(), l.end(), mem_fun_if( not_null(A), &amp;A::print ) );</p>
<p>return 0;<br />
}```</p>
<h2>if_not_null</h2>
<p>다음은 포인터 컨테이너에서 NOT NULL 인 갯수를 찾는 코드이다.</p>
<pre><code>
count_if( l.begin(), l.end(),
bind2nd( not_equal_to&lt;A*&gt;(), (A*)0 ) );
</code></pre>

<h2>ptr_fun and not1, not2</h2>
<p>ptr_fun 은 말 그대로 pointer to function 이다.</p>
<pre><code>
template&lt;class Arg, class Result&gt;
pointer_to_unary_function&lt;Arg, Result&gt;
ptr_fun(Result (_*pfunc)(Arg));

template&lt;class Arg1, class Arg2, class Result&gt;
pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;
ptr_fun(Result (_*pfunc)(Arg1, Arg2));

not1 은 unary_function 의 negate 이며, not2 는 binary_function 의 negate 이다.

template&lt;class UnaryPredicate&gt;
unary_negate&lt;UnaryPredicate&gt; not1(
const UnaryPredicate&amp; _Pred
);

template&lt;class Predicate&gt;
class unary_negate
: public unary_function&lt;
typename Predicate::argument_type,
bool&gt;
{
public:
explicit unary_negate(
const Predicate&amp; _Func
);
bool operator()(
const typename Predicate::argument_type&amp; _Left ) const;
};

template&lt;class BinaryPredicate&gt;
binary_negate&lt;BinaryPredicate&gt; not2(
const BinaryPredicate&amp; _Func
);

template&lt;class Operation&gt;
class binary_negate
: public binary_function &lt;
typename Operation::first_argument_type,
typename Operation::second_argument_type,
bool&gt;
{
public:
explicit binary_negate(
const Operation&amp; _Func
);
bool operator()(
const typename Operation::first_argument_type&amp; _Left,
const typename Operation::second_argument_type&amp; _Right
) const;
};
</code></pre>

<p>그럼 그동안 배운 것을 토대로 다음 MSDN 샘플을 살펴보자.</p>
<p>not1( bind2nd( ptr_fun(strcmp), "pearly" ) )</p>
<p>만약 1초만에 strcmp(X,"pearly")==0 임을 인지해 냈다면 당신은 STL의 고수... ㅠㅠ</p>
<h2>mem_fun vs. mem_fun_ref</h2>
<p>EffectiveSTL 에도 나오는 이야기이니, 책을 가지신 분은 43 아이템을 참고하라.</p>
<p>나를 비롯한 대부분의 프로그래머들은 이런 코드를 사랑한다.</p>
<p>for ( list<GameObject*>::iterator itr = gameObjects.begin() ; itr != gameObjects.end() ; itr ++ )<br />
{<br />
GameObject * pObject = *itr;<br />
__ASSERT(pObject!=NULL); /// be a paranoid!!!<br />
pObject-&gt;Update();<br />
}</p>
<p>너무나도 직관적인 코드이지만, 사실 mem_fun 을 사용하면 한 줄로 해결이 가능하다.</p>
<p>for_each( gameObjects.begin(), gameObject.end(), mem_fun(&amp;GameObject::Update) );</p>
<p>코드는 간단해졌지만 익숙하지 않은 관계로 팀원들이 싫어할 지도 모른다. 그러나, 타이핑하는 글자수도 적으면서 성능도 훨씬 더 좋다는데... 그 누가 안 쓸수 있으랴? (대신 디버깅할 때에는 멤버함수에다가 breakpoint 를 걸어야 하는 단점이 있을 수도 있다 <img alt=";)" src="http://boxcatstudio.files.wordpress.com/2009/07/icon_wink.gif" />  )</p>
<p>포인터의 컨테이너일 경우에는 mem_fun 을, 객체의 컨테이너라면 mem_fun_ref 를 사용하면 된다. 만약 멤버함수에 파라미터를 넘겨야 한다면, 아래와 같이 bind 함수를 사용할 것.</p>
<p>for_each( gameObjects.begin(), gameObject.end(), bind2nd( mem_fun(&amp;GameObject::SetHP),100) );</p>
<h2>bind1st vs. bind2nd</h2>
<p>우선 bind 함수를 알아보기에 앞서, unary_function 과 binary_function 에 대해서 알아보자. 이들은 단지 파라미터와 리턴타입에 대한 typedef 만을 담는 template structure 일 뿐이다. 즉 이들은 혼자서는 아무런 기능도 하지 않지만, 이를 상속받은 하위 클래스에서 타입 정보를 적절히 참조하기 좋도록 디자인된 베이스 클래스라는 뜻이다.</p>
<p>template<class Arg, class Result><br />
struct unary_function {<br />
typedef Arg argument_type;<br />
typedef Result result_type;<br />
};</p>
<p>template<class Arg1, class Arg2, class Result><br />
struct binary_function {<br />
typedef Arg1 first_argument_type;<br />
typedef Arg2 second_argument_type;<br />
typedef Result result_type;<br />
};</p>
<p>기본적으로 STL 알고리즘에서 사용되는 Predicate 등의 함수들은 unary_function 의 형태를 띄어야 한다. 쉽게 말하면, find(), for_each(), count() 의 마지막 인자가 해당 컨테이너 내부의 객체 하나만을 인자로 받는 함수 객체라는 뜻이다.</p>
<p>가령 list<int> 에서 10보다 큰 객체를 찾으려면 대략 다음과 같은 predicate 을 작성해야 한다.</p>
<p>class GreaterThan10<br />
{<br />
public :<br />
bool operator() ( int i ) { return i&gt;= 10; }<br />
};</p>
<p>사실 이렇게 짜면 너무 코드가 범용적이지 못하므로, 대부분의 경우에는 이렇게 구현할 것이다.</p>
<p>class GreaterThanN<br />
{<br />
public :<br />
GreaterThenN( int N ) : m_N(N) {}<br />
bool operator() ( int i ) { return i&gt;= m_N; }<br />
private :<br />
int m_N;<br />
};</p>
<p>이걸 STL 적인 생각으로 다시 구현한 것이 바로 bind 함수들이다. bindN(A,B) 은 binary_function A 의 N 번째 파라미터로 parameter B 을 바인딩해서, unary_function 을 만들어주는 놈이다. 얘네들을 잘 활용하면 단순 함수들은 간단히 한줄로 구현할 수 있게 된다.</p>
<pre><code>- bind1st( BINARY_FUNC, PARAM ) : PARAM 을 BINARY_FUNC의 1st 파라미터로 바인딩한다.

- ex&gt; bind1st( greater, 10 ) --&gt; 10 &gt; N

- bind2nd( BINARY_FUNC, PARAM ) : PARAM 을 BINARY_FUNC의 2nd 파라미터로 바인딩한다.

- bind2nd( greater, 10 ) --&gt; N &gt; 10
</code></pre>
<p>bind1st( greater, 10 ) 이 어떻게 10 &gt; N 이라는 함수로 바뀌는지 자세히 살펴본다면...</p>
<pre><code>- greater는 binary_function 이다.
</code></pre>
<p>template<class Type><br />
struct greater : public binary_function <Type, Type, bool><br />
{<br />
bool operator()(<br />
const Type&amp; _Left,<br />
const Type&amp; _Right<br />
) const;<br />
};</p>
<pre><code>- bind1st(A,B) 는 binder1st 객체를 리턴한다.
</code></pre>
<p>template<class Operation, class Type><br />
binder1st <Operation> bind1st(<br />
const Operation&amp; _Func,<br />
const Type&amp; _Left<br />
);</p>
<pre><code>- binder1st&lt;A&gt; 는 A의 두번째 파라미터를 파라미터로 받고, A의 리턴값을 리턴하는 함수 객체이다. 이때 이 클래스의 생성자의 인자 목록을 유심히 살펴보면, binary_function 하나와 이놈의 하나의 파라미터는 받고 있다. (나머지 하나는 당연히 container 에서 받게 된다.)
</code></pre>
<dl>
<dt>template<class Operation></dt>
<dt>class binder1st</dt>
<dd>public unary_function &lt;<br />
typename Operation::second_argument_type,<br />
typename Operation::result_type&gt;<br />
{<br />
public:<br />
typedef typename Operation::second_argument_type argument_type;<br />
typedef typename Operation::result_type result_type;<br />
binder1st(<br />
const Operation &amp; _Func,<br />
const typename Operation::first_argument_type&amp; _Left<br />
);<br />
result_type operator()(<br />
const argument_type&amp; _Right<br />
);<br />
result_type operator()(<br />
const argument_type&amp; _Right<br />
) const;<br />
protected:<br />
Operation op;<br />
typename Operation::first_argument_type value;<br />
};</dd>
</dl>
<h2>SafeDeleter</h2>
<p>템플릿 클래스 버전을 사용할 경우, 매번마다 타입을 지정해줘야 하지만, 템플릿 멤버함수 버전을 사용하면 타입 없이도 사용할 수 있다. 아직까지 이걸 몰랐다니.. ㅠㅠ 쑥갓군 땡큐~</p>
<p>/// template class version<br />
template <class T><br />
class SafeDeleter<br />
{<br />
public :<br />
void operator () ( T * &amp; ptr ) const<br />
{<br />
SAFE_DELETE(ptr);<br />
}<br />
};</p>
<p>for_each( a.begin(), a.end(), SafeDeleter<A>() );</p>
<p>/// template member function version<br />
class SafeDeleter2<br />
{<br />
public :<br />
template <class T><br />
void operator () ( T * &amp; ptr ) const<br />
{<br />
SAFE_DELETE(ptr);<br />
}<br />
};</p>
<p>for_each( a.begin(), a.end(), SafeDeleter2() );</p>
<h2>Static Key vs. Dynamic Key</h2>
<p>class Object<br />
{<br />
KeyType_t Key;<br />
....;<br />
};<br />
map<KeyType_t,Obj*> orderedObjects;</p>
<p>위와 같이 객체의 특정 필드의 값으로 정렬된 map이 있다고 하자. 일단 map에 객체를 넣고 난 다음에 Key 값을 변경하면 map 내부의 트리가 깨지므로 바꿔서는 곤란해진다. 그러나, 때로는 Key 값이 바뀌어야 할 필요가 있다. 언제나 실시간으로 바꿔주려면 map 에서 객체를 빼낸 다음 Key 값을 바꾸고 다시 넣어야 하는데, 항상 넣었다 뺐다 하기에는 성능적인 부분이 걱정되는데...</p>
<p>이럴 경우에는 외부에서 필요할 때마다 새로운 키를 저장한 다음, 적당히 바꿀 타이밍이 되면 객체를 map 에서 빼낸 다음 키값을 업데이트해주면 된다. 특히 아래와 같이, 정적인 메인 키의 맵으로 구성된 객체의 매니저가 내부에 특정 순서로 정렬된 서브 키의 맵을 가진 경우, 위와 같은 패턴을 사용하면 꽤 편하다.</p>
<p>class Object<br />
{<br />
StaticKeyType_t MainKey;<br />
DynamicKeyType_t SubKey;<br />
DynamicKeyType_t NewSubKey;<br />
....;<br />
};</p>
<p>class ObjectManager : public map<StaticKeyType_t,Object*><br />
{<br />
map<DynamicKeyType_t,Object*> orderedObjects;<br />
void ChangeSubKey( StaticKeyType_t mainKey, DynamicKeyType_t newSubKey );<br />
void UpdateSubMap();<br />
};</p>
<p><strong>어쨌든, map 의 키값을 외부에서 바꿨다가는 큰 낭패를 볼 것이다.</strong></p>
<p>see also:</p>
<pre><code>- [Boost Multi-index Containers Library](http://boost.org/libs/multi_index/doc/index.html)
</code></pre>
<h2>multixxx::erase(key_type)</h2>
<p>일반적인 erase()는 iterator/const_iterator 를 파라미터로 받아서 그 넘을 지우는 역할을 한다. 그런데, multimap/multiset 에서는 key_type 만 넘겨서 해당 값을 지우는 메쏘드를 제공한다. 대체로 이는 잘 동작하지만 predicate 가 명시된 multimap/multiset 에서는 생각대로 동작하지 않는다. 다음 예를 보자.</p>
<p>class TeamInfo<br />
{<br />
public :<br />
TeamInfo ( int point = 0 )  : TeamPoint(point) {}<br />
int TeamPoint;<br />
};</p>
<p>class GreaterTeam<br />
{<br />
public :<br />
bool operator () (const TeamInfo<em> l, const TeamInfo</em> r) const<br />
{<br />
return l-&gt;TeamPoint&gt; r-&gt;TeamPoint;<br />
}<br />
};</p>
<p>void<br />
test_multiset()<br />
{<br />
typedef multiset<TeamInfo*,GreaterTeam> TEAMS;</p>
<p>TEAMS teams;</p>
<p>TeamInfo t1(1);<br />
TeamInfo t2(1);<br />
TeamInfo t3(0);<br />
TeamInfo t4(2);</p>
<p>teams.insert( &amp;t1 );<br />
teams.insert( &amp;t2 );<br />
teams.insert( &amp;t3 );<br />
teams.insert( &amp;t4 );</p>
<p>// erase by key test <br />
teams.erase( &amp;t4 ); assert( teams.size() == 3 );<br />
teams.erase( &amp;t1 ); assert( teams.size() == 1 );  // t1 과 t2 를 지운다. 낭패~</p>
<p>// erase with iterator test<br />
teams.clear();<br />
teams.insert( &amp;t1 );<br />
teams.insert( &amp;t2 );<br />
teams.insert( &amp;t3 );<br />
teams.insert( &amp;t4 );</p>
<p>pair<TEAMS::iterator,TEAMS::iterator> itrs = teams.equal_range(&amp;t1);<br />
teams.erase( find( itrs.first, itrs.second, &amp;t1 ) );<br />
assert( teams.size() == 3 );</p>
<p>assert( <em>(teams.find(&amp;t1)) == &amp;t2 ); // t1 을 찾으면 t2 가 나온다는 놀라운 사실!<br />
assert( </em>(teams.find(&amp;t2)) == &amp;t2 );<br />
assert( <em>(teams.find(&amp;t3)) == &amp;t3 );<br />
assert( </em>(teams.find(&amp;t4)) == &amp;t4 );<br />
}</p>
<p>여기서 배울 수 있는 교훈은</p>
<pre><code>- 코드상으로는 equal_range(&amp;t1)이라는 것이 t1을 찾는 것처럼 보이지만, 실제로는 key_type과 무관하며 오직 predicate 를 이용해서 검색을 한다!
- multi 시리즈에서는 find()나 erase()에 있어서 항상 동일한 값이 존재할 수 있다!
- predicate 의 비교문에서 &gt;= 을 사용하면 다른 결과가 나온다!
- predicate 관련 변수(m_TeamPoint)와 같이, 비교 로직에 영향을 주는 무언가를 외부에서 바꾸게 되면 multixxx 내부의 트리가 깨지게 된다. 너무나 당연한 사실이지만, Key 를 바꾸는게 아니라서 안전할 거 같아 보이는 것도 사실이다. 이를 방지하려면 일단 container 에서 해당 값을 erase한 다음 값을 수정하고 다시 insert 하는 것을 권장한다.
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/06/01/queueuserworkitem/">QueueUserWorkItem()</a> <small>2006-06-01</small></h1>
	</div>
	<div><p>Windows 에서 제공하는 ThreadPooling API인 QueueUserWorkItem()에 대해서 알아보자.</p>
<h2>QueueUserWorkItem()</h2>
<p>Programming Application for Microsoft Windows 에 의하면 ThreadPooling 시 새로운 쓰레드가 추가되기 위한 factor 에는 아래와 같은 것이 있다.</p>
<ul>
<li>쓰레드가 추가된 지 몇 초가 지나면, 한번 고민해본다</li>
<li>WT_EXECUTELONGFUNCTION 이 사용될 경우, 한번 고민해본다</li>
<li>큐잉된 작업의 개수가 일정 threadhold 를 넘어설 경우, 한번 고민해본다.</li>
</ul>
<p>그러나, 상세한 파라미터는 알려져 있지 않아서.. 테스트를 해 보았다.</p>
<pre><code>
const int MAX_WORK = 1000;
LONG WorkCounter = 0;
int add_time = 1;
int work_time = 10;
int nloop = 1;
bool bPreQueue = false;
int pre_queue_time = 1000;
bool bMiddleSleep = false;
int middle_sleep_time = 1000;

DWORD WINAPI MyWorkThreadProc(PVOID pParam)
{
    MyWork* pWork = (MyWork*)pParam;

    Sleep(pWork-&gt;workTime);

    pWork-&gt;threadID = ::GetCurrentThreadId();
    pWork-&gt;output = pWork-&gt;input * 2;

    InterlockedIncrement( &amp;WorkCounter );

    return 0;
}

void
thread_pool_test_fixture::test_really_pooling()
{
    for ( int k = 0 ; k  0 )
            {
                Sleep(pre_queue_time);
            }
        }

        MyWork works[MAX_WORK];
        for (int i=0; i 0 )
            {
                Sleep(add_time);
            }

            if ( i == 500 &amp;&amp; bMiddleSleep &amp;&amp; middle_sleep_time &gt; 0 )
            {
                Sleep( middle_sleep_time );
            }
        }

        while ( WorkCounter  threads;
        for (int i=0; i::iterator itr = threads.begin() ; itr != threads.end() ; itr ++ )
        {
            BOOST_MESSAGE( *itr  처리 시간 |
| 10 | 10 | 1  | 큐잉되는 시간 == 처리 시간 |
| 10 | 20 | 3  | 큐잉되는 시간
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/05/28/boostis_base_of/">boost::is_base_of</a> <small>2006-05-28</small></h1>
	</div>
	<div><p>템플릿 프로그래밍을 하다 보면, 문자열이나 사용자 정의 클래스(UDT) 같은 특정 타입에 대한 특수화(specializaiton)를 할 경우가 있다. 그 중에서 가장 헷갈리는 부분이 바로 특정 클래스의 포인터를 템플릿 인자로 받아서 특수화해야 하는 경우인데, boost typetraits 중 하나인 boost::is_base_of를 사용하면 손쉽게 해결할 수 있다.</p>
<pre><code>
template
void old_algorithm ( const T &amp; value )
{
  // do generic something
}
</code></pre>

<p>위와 같은 함수 템플릿에 대해서 Base 클래스의 하위 클래스 포인터를 받았을 때를 위한 특수화를 해야 할 경우, 다음과 같은 패턴을 사용하라. 핵심은 is_base_of::type 이 true_type 또는 false_type 이라는 2 개의 서로 다른 타입을 리턴하며, 이 값을 이용해서 특수화를 한다는 것이다.</p>
<pre><code>
template
void new_algorithm ( const T &amp; value )
{
  typedef typename boost::is_base_of::type is_derived_class;

  // call impl
  new_algorithm_impl(value,is_derived_class());
}

template
void new_algorithm_impl ( const T &amp; value, const boost::true_type&amp; )
{
  // do specialized for Base class
}

template
void new_algorithm_impl ( const T &amp; value, const boost::false_type&amp; )
{
  // do generic something
}

</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/05/25/boostany/">boost::any</a> <small>2006-05-25</small></h1>
	</div>
	<div><p>게임 개발을 하다 보면, 가끔 서로 다른 타입의 객체들을 하나의 컨테이너에서 다루어야 할 때가 있다. 만약 이 컨테이너로 하는 일이 간단하다면야 인터페이스 상속을 쓰면 되지만, 상속을 할 수 없을 정도로 타입이 다를 때도 있다. 이럴 때 사용하는 것이 바로 boost::any 클래스이다.</p>
<p>boost::any는 이름 그대로 어떤(any) 것도 담을 수 있는 클래스로, void * 와 비슷한 역할을 한다. (더욱 자세한 설명은 <a href="http://boost.org/doc/html/any.html">boost 온라인 매뉴얼</a>을 참고)</p>
<p>이번에 boost::any 의 코드를 참조해서 작업을 하다 보니 몇 가지 장단점들이 눈에 띄었다.</p>
<ul>
<li>미리 any 의 내부값의 타입을 파악하고 있어야 한다. 즉, type() 을 이용해서 if-else 방식으로 비교하는 수 밖에 없다.</li>
<li>any_cast(value) 는 생각보다 타이핑하기가 귀찮다. 꺽쇠와 괄호를 다 타이핑한다고 생각해보라...</li>
<li>디버깅시 any 내부의 placeholder 에 들어 있는 값을 찾기가 곤란하다.</li>
</ul>
<p>이번 주는 영식군이 한 달 동안 쇼핑하면서 작업한 <a href="http://reiot.cafe24.com/archives/395">객체 복제 프레임워크</a>를 이틀 동안 인수인계 받은 후, 복제의 최소 단위인 replication value 클래스를 boost::any 의 코드를 참조해서 고치고 있다. 미리 2000라인 정도의 테스트 코드를 만들어둔 덕택에 <del datetime="2006-05-25T14:14:00+00:00">코드 학습</del> 리팩토링이 겨우 4일 만에 거의 끝낼 수 있었다. 물론 영식군이 계속 지나가면서 어차피 기능이 똑같다면 왜 사서 삽질을 하냐고 갈구고 있지만 그냥 못들은 척하고 중이다. 흐흐.</p></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/05/16/p2p-tips/">P2P Tips</a> <small>2006-05-16</small></h1>
	</div>
	<div><p>P2P 프로그래밍에 있어서 주의해야 할 항목들을 정리해 보았다. 입문자에게 많은 도움이 되었으면 한다. (참고로 본인은 직접 P2P를 개발하기보단 동료가 삽질하는 걸 지켜본 쪽이라서, 정확하지 않은 내용이 있을 수 있음을 먼저 밝힌다)</p>
<h1>분석 및 검토</h1>
<h2>게임성 분석</h2>
<p>만들고자 하는 게임의 다양한 속성들에 대한 분석이 최우선 단계이다. 다음 질문에 자신의 게임이 어떤 쪽인지를 잘 따져보기 바란다.</p>
<pre><code>- 최대접속자는 얼마인가? (4-8, 16-32, 64-256, Massive)
- 카운터 스트라이크처럼 사용자들에게 핑이 빠른 서버를 선택할 수 있도록 할 것인가?
- NPC 또는 몹이 존재하는가? 만약 그렇다면 누가 그들을 움직이게 할 것인가?
- 승패 또는 타격 판정, 이동에 대한 검증은 누가 할 것인가?
- dedicated server 를 지원할 것인가? 또는 클라이언트 중에서 UDP 서버를 선택할 것인가?
</code></pre>
<h2>토폴로지의 선택</h2>
<p>어떤 토폴로지를 선택하느냐에 따라서 최대 대역폭, 최대 접속자가 결정되므로, 위에서 조사한 결과에 따라서 적합한 토폴로지를 선택해야 한다. 아래의 문서를 참고하기 바란다.</p>
<p>see also : <a href="http://reiot.cafe24.com/2006/02/18/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%95%a1%ec%85%98-%ea%b2%8c%ec%9e%84%ec%9d%98-%eb%b6%84%eb%a5%98/">네트워크 액션 게임의 분류</a></p>
<h2>UDP 라이브러리의 선택</h2>
<p>토폴로지를 선택했다면 이제 UDP 라이브러리를 선택할 단계이다.</p>
<p>단지 위치 정보만을 보내는 게 아닌 이상, 순수 UDP 만으로 네트워크 게임을 개발하기란 쉽지 않다. 결국은 reliable UDP 를 지원하는 외부 라이브러리를 사용하거나 직접 구현하게 될텐데, 직접 구현하는 것은 시간이 많거나 자신이 천재가 아닌 이상 그다지 좋은 선택은 아니다. 반면 어떤 라이브러리를 선택해도 깊은 이해 없이는 잘 사용하기가 힘든 것이 사실이다.</p>
<p>가능하면 Unreal, Source Engine 등 네트워크 모듈이 포함된 게임 엔진을 구매하는 것을 권장하며, 그럴 수 없다면 충분한 검토 기간 하에 RakNet, OpenTNL, udt, enet 중에서 하나를 선택하기 바란다.</p>
<h1>디자인 및 구현, 테스트</h1>
<h2>네트워크 모듈의 통합</h2>
<p>많은 UDP 라이브러리들은 보다 빠른 반응성을 위해 자체적으로 쓰레드를 사용한다. 그러나 dedicated server 가 아닌 이상, 서버쪽은 무작정 쓰레드를 남발해서는 곤란하다. 하나의 서버가 여러 개의 게임을 동시 처리해야 할 경우가 많으므로, 이럴 때에는 소스를 수정해야 할 수 있다.</p>
<pre><code>- polling vs. event-driven
- single thread vs. multithread
</code></pre>
<p>이때 폴링 방식의 클라이언트는 로딩 혹은 렌더링으로 인해 네트워크 업데이트를 방해하는 일이 없도록 주의해야 한다.</p>
<h2>NAT와 홀펀칭</h2>
<dl> <dt>하드웨어의 구비</dt> <dd>하드웨어가 없는 상태에서의 NAT 프로그래밍은 장님 코끼리 다리 만지기와 같다.</dd> <dt>SNAT</dt> <dd>SNAT-SNAT 간에는 홀펀칭이 통하지 않는다는 사실만 기억하면 된다. 중국이 아닌 이상 SNAT를 만나기란 쉽지 않다. 정 귀찮다면 C/S구조로 가는 것도 나쁘지 않다. GPGStudy 포럼을 잘 검색하면 어떤 라우터가 SNAT인지를 찾을 수 있다.</dd> <dt>N+1</dt> <dd>어떤 NAT는 새로운 매핑을 위해 포트 번호를 점차 증가시키기도 한다. 그러나 라우터 제조 업체마다 다르므로 일반적으로는 알 수 없다고 봐야 한다.</dd> <dt>Timeout</dt> <dd>30-40초마다 패킷을 밖으로 쏘지 않을 경우 매핑을 삭제하는 공유기가 존재한다.</dd> <dt>패킷 릴레이</dt> <dd>직접적인 통신이 되지 않는 peer 에게 패킷을 보낼 수 있는 유일한 방법이다. 문제는 릴레이는 핑이 2배 느려지는 것이 보통이므로 데드 레커닝 및 보간 기능으로 잘 극복해야 한다. 릴레이가 끊기는 경우 실시간으로 다른 루트를 찾아주면 금상첨화.</dd> <dt>사설 네트워크</dt> <dd>같은 네트워크에 있는 사용자들 끼리는 굳이 public 주소로 접속할 필요는 없다. 상대방의 (public,private) 모두로 핑을 쏜 다음, 응답이 오면 그 중 빠른 넘을 실제 주소로 선택하라. 이때 둘 다 될 경우라면 대체로 private를 사용하는 편이 좋다. 물론 **본인 확인**은 필수. 방화벽 내부에 있는 사람들끼리 플레이할 경우 public 으로 통신하면 괴로워진다.</dd> <dt>다단계 NAT</dt> <dd>중국은 다단계 NAT로 악명이 높다. 최소한 2단계로 NAT를 배치한 후 각 노드마다 클라이언트를 두고 내부/외부와 통신이 잘 되는지를 확인할 것. 그렇게 열심히 테스트해도 안되는 환경이 분명 존재하므로, 처음부터 릴레이를 기본 기능으로 포함시킬 것.</dd> <dt>사용자 서버</dt> <dd>네트워크 비용을 줄이려면 특정 클라이언트가 서버 역할을 하도록 하라. 단 Drop-out시 게임을 중단하고 새 서버를 찾는 기능을 구현해야 한다. 물론 보안 문제는 책임질 수 없다;;</dd> </dl>

<h2>대역폭 관리</h2>
<dl> <dt>모뎀 지원</dt> <dd>해외에는 아직도 모뎀을 많이 사용하고 있다. 따라서 모뎀 유저가 방에 들어올 경우 최대 접속자를 줄이든가 대역폭에 맞게 데이터를 실시간 관리하는 기능이 필요하다.</dd> <dt>MTU</dt> <dd>게임에서의 최대 패킷 크기를 항상 알고 있을 것. 특히 리스트 방식으로 전송되는 데이터들(방 목록, 사람 목록, 게임 목록)을 유의할 것.</dd> <dt>순간 대역폭 체크</dt> <dd>어떤 공유기(D-Link)는 순간 대역폭을 초과할 경우 reset 되기도 한다.</dd> </dl>

<h2>공유기, 방화벽, 포트 포워딩</h2>
<dl> <dt>(D)DOS 공격</dt> <dd>어떤 공유기는 외부로부터 갑자기 연결이 많이 들어올 경우 DOS 혹은 DDOS 로 간주해서 연결을 차단하기도 한다.</dd> <dt>XP 방화벽</dt> <dd>Windows XP의 방화벽에 자동 등록하기는 필수. 단 사용자에게 허가를 받지 않고 몰래 방화벽을 끌 경우 해외에서는 고소당할 수 있다.</dd> <dt>백신 호환성 체크</dt> <dd>일부 백신들은 정상적인 어플리케이션도 바이러스나 웜으로 간주하기도 한다. 따라서 유명 백신들을 설치한 상태에서 툴과의 호환성을 체크한 후 문제가 있다면 매뉴얼을 홈페이지에 등록해야 한다.</dd> <dt>포트 포워딩</dt> <dd>portforward.com이나 [WOW](http://www.blizzard.com/support/wow/?id=aww01154p)처럼 공유기에서 포트포워딩을 하는 방법을 홈페이지에 기술할 것. 가능하면 클라이언트에 네트워크 진단 도구를 탑재하거나, 웹 기반 진단 페이지를 만들기를 권장한다.</dd> <dt>주의 깊은 포트의 선택</dt> <dd>해외의 일부 회선 업체는 자신들의 자체 서비스(VoIP)를 위해 특정 UDP 포트를 임의로 막기도 한다. 가능한한 다른 게임 및 어플리케이션과 충돌하지 않는 포트를 선택할 것.</dd> <dt>서버 방화벽</dt> <dd>네트워크 관리자에게 사용하는 포트에 대한 문서를 넘기고 수시로 업데이트 해줄 것. (특히 해외 서비스일 경우는 필수) 허용된 포트의 끝언저리에서 실수로 인한 문제가 종종 생기곤 한다.</dd> </dl>

<h2>기타</h2>
<pre><code>- 공유기의 타입 찾기 : STUN
- Drop-In : 게임 도중 새로운 접속자가 들어올 때
- 연결 끊김 감지 : 게임 도중 연결이 끊길 경우 얼마나 빨리 감지할 수 있을까?
- 데이터 복제, 보안, 통계 수집
</code></pre></div>
	
</article>
			
			<ul class="pager">
			
			  	<li class="previous">
			    	<a href="/page/32/">&larr; Older</a>
			  	</li>
		  	
		  	
				<li class="next">
					<a href="/page/32">Newer &rarr;</a>
				</li>
		  	
			</ul>
		</div>
		<div class="span3">
			<ul class="nav nav-list well">
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2006/06/01/stl-tips/">STL Tips</a>
	</li>
	
	<li>
		<a href="/2006/06/01/queueuserworkitem/">QueueUserWorkItem()</a>
	</li>
	
	<li>
		<a href="/2006/05/28/boostis_base_of/">boost::is_base_of</a>
	</li>
	
	<li>
		<a href="/2006/05/25/boostany/">boost::any</a>
	</li>
	
	<li>
		<a href="/2006/05/16/p2p-tips/">P2P Tips</a>
	</li>
	
</ul>
		</div>
	</div>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
	

  </body>
</html>