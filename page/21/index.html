<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Social Game Developer wandering strange dungeon...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
        font-family: 'Helvetica Neue', '맑은 고딕', Helvetica, Arial, sans-serif;
      }
    </style>
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	<div class="row">
		<div class="span9">
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/09/boost_asio_iostream/">boost::asio iostream</a> <small>2008-02-09</small></h1>
	</div>
	<div><p>문자열 기반의 네트워크 입출력 프로그래밍을 해야 한다면, ASIO 의 iostream 을 사용하면 간단히 해결된다.</p>
<p>boost::asio::io_service 같이 모호한 객체 선언도 필요없고, 연결 관리나 버퍼링 같은 개념도 적당히 무시할 수 있어서, 예외 처리만 잘 한다면 원격 로그라든지 XML RPC  클라이언트 같은 곳에 써먹을 수 있을 것 같다.</p>
<p>만약 복잡한 문자열 조작이 필요하다면 boost::string_algo 정도면 충분하고, 정규식이 필요하면 boost::regexp 을 가져다 사용하면 될 듯하다.</p>
<!--more-->

<pre><code>
// 문자열 기반의 네트워크 입출력 스트림
BOOST_AUTO_TEST_CASE( test_iostream )
{
    string http_request =
        &quot;GET / HTTP/1.0\r\n&quot;
        &quot;Host: reiot.cafe24.com\r\n\r\n&quot;;
    string expected_http_response[] = { &quot;HTTP/1.0 200 OK&quot;, &quot;HTTP/1.1 200 OK&quot; };

    {

        tcp::iostream io_(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);

        io_    &lt;&lt; http_request &lt;&lt; flush;    // or io_.flush();

        vector&lt;string&gt; http_response;
        while ( !io_.eof() )
        {
            string line;
            getline(io_,line);
            http_response.push_back(line);
        }

        BOOST_CHECK_EQUAL( boost::trim_copy(http_response[0]), expected_http_response[1] );

        io_.close();
    }

    {
        string host = &quot;www.google.co.kr&quot;;
        tcp::iostream io_(host,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/&quot; &lt;&lt; 1 &lt;&lt; &quot;.&quot; &lt;&lt; 0 &lt;&lt; endl
            &lt;&lt; &quot;Host: &quot; &lt;&lt; host &lt;&lt; endl &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        vector&lt;string&gt; http_response;
        while ( !io_.eof() )
        {
            string line;
            getline(io_,line);
            http_response.push_back(line);
        }

        BOOST_CHECK_EQUAL( boost::trim_copy(http_response[0]), expected_http_response[0] );
    }

    {
        tcp::iostream io_(&quot;www.naver.com&quot;,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/1.0&quot; &lt;&lt; endl
            &lt;&lt; &quot;Host: www.naver.com&quot; &lt;&lt; endl
            &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        stringstream response;
        while ( !io_.eof() )
        {
            char ch = io_.get();
            response &lt;&lt; ch;
        }

        string line;
        getline(response,line);
        BOOST_CHECK_EQUAL( boost::trim_copy(line), expected_http_response[1] );
    }

    {
        tcp::iostream io_(&quot;clien.career.co.kr&quot;,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/1.0&quot; &lt;&lt; endl
            &lt;&lt; &quot;Host: clien.career.co.kr&quot; &lt;&lt; endl
            &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        stringstream response;
        while ( !io_.eof() )
        {
            char buf[128];
            io_.read(buf,127);
            size_t nread = io_.gcount();
            if ( nread &gt; 0 )
            {
                buf[nread] = 0;
                response &lt;&lt; buf;               
            }
        }

        string line;
        getline(response,line);
        BOOST_CHECK_EQUAL( boost::trim_copy(line), expected_http_response[1] );
    }
}

</code></pre></div>
	
	<p>
	
		<a href="/tag/ASIO/"><span class="label">ASIO</span></a>
	
		<a href="/tag/boost/"><span class="label">boost</span></a>
	
	</p>
	
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/09/boost-test-thread-safe/">boost::test thread safe</a> <small>2008-02-09</small></h1>
	</div>
	<div><p>다른 표준 라이브러리와 마찬가지로, boost::test 역시 멀티쓰레드에 대해서 안전하지 않다. 물론 BOOST_CHECK 등의 테스트 매크로들은 내부적으로 싱글톤을 사용하기 때문에, 쓰레드 함수 내부에서 사용하더라도 실패할 경우 에러 메시지를 출력해주지만, 다른 쓰레드에서 동일한 순간에 역시 같은 매크로를 호출하게 되면 콜스택 깊은 곳에서 난감한 에러를 뱉어버린다.</p>
<p>이걸 해결하려면 결국 mutex 로 테스트 매크로들을 wrap 한 또다른 매크로를 만들어서 써야 하는 수 밖에 없다.</p>
<pre><code>
#define SAFE_BOOST_CHECK_EQUAL(m,x,y) { \
boost::mutex::scoped_lock lock(m); \
BOOST_CHECK_EQUAL(x,y); }

void boost_check_always( boost::mutex * m )
{
boost::timer timer_;

while(timer_.elapsed() &lt; 10.f )
{
SAFE_BOOST_CHECK_EQUAL(*m,1,1);
}

}

BOOST_AUTO_TEST_CASE( test_boost_check_always )
{
boost::mutex m;
boost::thread t(boost::bind(boost_check_always,&amp;m));

boost::timer timer_;
while(timer_.elapsed() &lt; 10.f )
{
SAFE_BOOST_CHECK_EQUAL(m,1,1);
}

t.join();
}
</code></pre></div>
	
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/04/boostasio-tcp-resolver/">boost::asio TCP resolver</a> <small>2008-02-04</small></h1>
	</div>
	<div><p>한가로운 주말, 최신 BOOST 를 vc81로 빌드하고 <a href="http://asio.sourceforge.net/">ASIO</a>를 만지작거려 봤다. 대충 훑어본 바, 이 정도면 지금 코드에서 충분히 ACE를 제거해도 될 수준의 기능인 듯하다. 어차피 둘 다 디버깅 들어가면 템플릿 사이에서 헤매이는 건 마찬가지니...</p>
<!--more-->

<pre><code>
// TODO multiple ip address in localmachine (..localmachine)
BOOST_AUTO_TEST_CASE( test_resolver )
{
 boost::asio::io_service io_service;
 boost::system::error_code error;
 tcp::resolver resolver(io_service);
 tcp::resolver::iterator end_;

 // localmachine
 {
  tcp::resolver::query query(boost::asio::ip::host_name(),&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;192.168.10.101&quot; );
 }

 // host -&gt; ip
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
 }

 // localhost
 {
  tcp::resolver::query query(&quot;localhost&quot;,&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;127.0.0.1&quot; );
  if ( ++iterator != end_ )
  {
   _endpoint = *iterator;
   BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;192.168.10.101&quot; );
  }
 }

 // http
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 80 );
 }

 // ftp
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;ftp&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 21 );
 }

 // telnet
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;telnet&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 23 );
 }

 // unknown host
 {
  tcp::resolver::query query(&quot;reiot1.com&quot;,&quot;&quot;);
  resolver.resolve(query,error);
  BOOST_CHECK_EQUAL( error.value(), boost::asio::error::host_not_found );
 }

 // unknown service
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;test&quot;);
  resolver.resolve(query,error);
  BOOST_CHECK_EQUAL( error.value(), boost::asio::error::service_not_found );
 }
}

void print_address(const boost::system::error_code&amp; e, tcp::resolver::iterator itr )
{
 tcp::endpoint endpoint_ = *itr;
 BOOST_MESSAGE( endpoint_.address() );
}

class AsyncResolveHandler
{
public :
 AsyncResolveHandler( int errorcode ) : address_(&quot;&quot;), port_(0), errorcode_(errorcode) {}
 AsyncResolveHandler( std::string addr, int port = 0 ) : address_(addr), port_(port) {}
 void operator() (const boost::system::error_code&amp; e, tcp::resolver::iterator itr )
 {
  if ( !e )
  {
   tcp::endpoint endpoint_ = *itr;
   BOOST_CHECK_EQUAL( endpoint_.address().to_string(), address_ );
   if ( port_ != 0 )
   {
    BOOST_CHECK_EQUAL( endpoint_.port(), port_ );
   }
  }
  else
  {
   BOOST_CHECK_EQUAL( e.value(), errorcode_ );
  }
 }
 std::string address_;
 int port_;
 int errorcode_;
};

BOOST_AUTO_TEST_CASE( test_async_resolver )
{
 boost::asio::io_service io_service;

 tcp::resolver resolver(io_service);

 boost::system::error_code error;

 // host -&gt; ip
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // localhost -&gt; 127.0.0.1
 {
  tcp::resolver::query query(&quot;localhost&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;127.0.0.1&quot;));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // http
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,80));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();

 }

 // ftp
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;ftp&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,21));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // telnet
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;telnet&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,23));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // unknown host
 {
  tcp::resolver::query query(&quot;reiot1.com&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(boost::asio::error::host_not_found));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // unknown service
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;test&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(boost::asio::error::service_not_found));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }
}

</code></pre></div>
	
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/04/anticheatengine/">AntiCheatEngine</a> <small>2008-02-04</small></h1>
	</div>
	<div><p>원래는 Cheat Engine 으로도 freeze 를 걸 수 없는 안전한 변수를 만들기 위해서 만든 클래스다. 여기에 CRC라든지 XOR도 넣고, 또 값이 바뀔 때마다 위치도 바꾸고 할려고 했는데, 가만히 생각해보니 속도도 제법 느리고 막상 함수 내에 아래와 같이 로컬 캐시가 있다면 그걸 바꿔버리면 전혀 쓸모 없어져서 그냥 포기버렸다.</p>
<pre><code>
float speed = ac.Get&lt;float&gt;(&quot;speed&quot;);
// -- inject code here --
check_next_pos(pos,speed);
</code></pre>

<p><a href="http://reiot.cafe24.com/2008/02/03/ai-game-programming-wisdom-3/">어제 주문한 책들</a>이 도착하면 다시 한번 도전해볼까 싶기도 하지만, assembly 쪽 지식이 전무해서...</p>
<!--more-->

<pre><code>
// AntiCheatEngine.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include &quot;stdafx.h&quot;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;hash_map&gt;

#pragma warning(disable:4819)
#define BOOST_TEST_MAIN
#include &lt;boost/format.hpp&gt;
#include &lt;boost/test/unit_test.hpp&gt;

using std::string;

size_t GenerateIndex()
{
static size_t key = 0;
return key++;
}

class AntiCheat
{
typedef std::vector&lt;size_t&gt; INDEX_LIST;
typedef stdext::hash_map&lt;string, INDEX_LIST &gt; KEY_MAP;

public :

AntiCheat( size_t N = 1024*64 )
{
m_Buffer.assign(N,0);
m_UnusedIndex.assign(N,0);
std::generate(m_UnusedIndex.begin(),m_UnusedIndex.end(),GenerateIndex);
std::random_shuffle(m_UnusedIndex.begin(),m_UnusedIndex.end());
}

bool IsValid() const { return true; }

unsigned int GetCRC() { return m_CRC; }

// FIXME use ASSERT, dont check return value
template&lt;class T&gt;
bool Set( const string &amp; name , const T &amp; valueIn )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
INDEX_LIST idxList;
for ( size_t i = 0 ; i &lt; sizeof(valueIn); i ++ )
{
if ( m_UnusedIndex.empty() )
return false;
size_t idx = m_UnusedIndex.back();
m_UnusedIndex.pop_back();
idxList.push_back(idx);
}

itr = m_Keys.insert(make_pair(name,idxList)).first;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
m_Buffer[idx] = reinterpret_cast&lt;const char*&gt;(&amp;valueIn)[i];
}

return true;
}

template&lt;typename T&gt;
bool Get( const string &amp; name, T &amp; valueOut )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
return false;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
reinterpret_cast&lt;char*&gt;(&amp;valueOut)[i] = m_Buffer[idx];
}
return true;
}

size_t GetUnusedIndexCount() const { return m_UnusedIndex.size(); }

unsigned int m_CRC;

INDEX_LIST m_UnusedIndex;
std::vector&lt;unsigned char&gt; m_Buffer;
KEY_MAP m_Keys;
};

//////////////////////////////////////////////////////////////////////////
template&lt;&gt;
bool AntiCheat::Set&lt;string&gt;( const string &amp; name, const string &amp; valueIn )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
INDEX_LIST idxList;
for ( size_t i = 0 ; i &lt; valueIn.size(); i ++ )
{
if ( m_UnusedIndex.empty() )
return false;
size_t idx = m_UnusedIndex.back();
m_UnusedIndex.pop_back();
idxList.push_back(idx);
}

itr = m_Keys.insert(make_pair(name,idxList)).first;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
m_Buffer[idx] = valueIn[i];
}

return true;
}

template&lt;&gt;
bool AntiCheat::Get&lt;string&gt;( const string &amp; name, string &amp; valueOut )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
return false;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

// FIXME 최초 크기 보다 작은 사이즈는 저장할 수 없다?
valueOut.assign(indexList.size(),0);
for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
valueOut[i] = m_Buffer[idx];
}
return true;
}

BOOST_AUTO_TEST_CASE( test1 )
{
AntiCheat ac(100);

BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100 );

BOOST_CHECK( ac.IsValid() );

string strIn = &quot;World&quot;, strOut;

{
ac.Set(&quot;string&quot;,strIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;string&gt;(&quot;string&quot;,strOut) );
BOOST_CHECK_EQUAL( strIn, strOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size());
}

{
int intIn, intOut;

intIn = 1;
ac.Set(&quot;int&quot;,intIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;int&gt;(&quot;int&quot;,intOut) );
BOOST_CHECK_EQUAL( intIn, intIn );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int));

intIn = -1;
ac.Set(&quot;int&quot;,intIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;int&gt;(&quot;int&quot;,intOut) );
BOOST_CHECK_EQUAL( intIn, intIn );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int));
}

{
bool boolIn, boolOut;

boolIn = true;
ac.Set(&quot;bool&quot;,boolIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;bool&gt;(&quot;bool&quot;,boolOut) );
BOOST_CHECK_EQUAL( boolIn, boolOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool));

boolIn = true;
ac.Set(&quot;bool&quot;,boolIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;bool&gt;(&quot;bool&quot;,boolOut) );
BOOST_CHECK_EQUAL( boolIn, boolOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool));
}

{
float floatIn, floatOut;

floatIn = 1.234f;
ac.Set(&quot;float&quot;,floatIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;float&gt;(&quot;float&quot;,floatOut) );
BOOST_CHECK_EQUAL( floatIn, floatOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool)-sizeof(float));

floatIn = -56.78f;
ac.Set(&quot;float&quot;,floatIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;float&gt;(&quot;float&quot;,floatOut) );
BOOST_CHECK_EQUAL( floatIn, floatOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool)-sizeof(float));
}

}

/*

값을 바꾸면 Key 및 CRC 가 바뀐다
멤버 함수가 아닌 다른 경로로 값을 바꾸면 CRC 체크가 깨져야 한다.
AntiCheat 는 하나의 큰 버퍼를 가진다. (ex: 32k)
여기에 변수를 키값을 이용해서 저장하고 읽어낸다.
이때 각 변수들은 바이트 단위로 흩어진다. 이때 흩어지는 인덱스는 저장하는 순간 랜덤하게, 중복되지 않게 결정된다.
(이때문에 unused index set 이 필요함)
또한 각 변수들은 Verifier 라는 range-checker 와 연동될 수 있다.
키값 역시 다이나믹하게 결정된다. (가령 player.hp 의 경우 매크로에 의해서 __K(PlayerHP) -&gt; 세션키와의 XOR 등등 )
Verify()를 호출하면 각 키에 대해서 Verify 한 다음,
특정 영역 마다 0xEF 등 boundry checker 를 넣어두고, 바뀌었는지 체크한다.

문자열일 경우 (길이 2바이트,본문) 이렇게 저장해야 한다. 만약 길이가 달라질 경우 인덱스를 새로 얻어 오거나 반납해야 한다.

*/
</code></pre></div>
	
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/01/29/solid-compression/">Solid Compression</a> <small>2008-01-29</small></h1>
	</div>
	<div><p><a href="http://boxcatstudio.files.wordpress.com/2009/07/learning_reiot.png" title="learning_reiot.png"><img alt="learning_reiot.png" src="http://boxcatstudio.files.wordpress.com/2009/07/learning_reiot.png" /></a></p>
<p><a href="http://sonee.com">소니</a>군의 가상 파일 시스템 작업을 배후조종 하면서 알아낸 팁.<br />
<code>여러 파일들을 하나의 스트림으로 압축해버리는 [Solid Compression](http://en.wikipedia.org/wiki/Solid_compression) 으로 압축한 파일에서는, 단 하나의 파일을 해제하는데에도 꽤 오랜 시간이 걸린다.</code><br />
see also:</p>
<pre><code>- 위 그림은 [O'Reilly 책 표지를 만들어주는 사이트](http://www.oreillymaker.com/)에서 생성해냈다.
- [Photoscape](http://www.photoscape.org/ps/main/index.php) : 쉬귀 군이 추천해준, 사진 편집 기능이 탁월한 무료 그래픽 에디터
</code></pre></div>
	
</div>
			
			<ul class="pager">
			
			  	<li class="previous">
			    	<a href="/page/22/">&larr; Older</a>
			  	</li>
		  	
		  	
				<li class="next">
					<a href="/page/22">Newer &rarr;</a>
				</li>
		  	
			</ul>
		</div>
		<div class="span3">
			<ul class="nav nav-list well">
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2008/02/09/boost_asio_iostream/">boost::asio iostream</a>
	</li>
	
	<li>
		<a href="/2008/02/09/boost-test-thread-safe/">boost::test thread safe</a>
	</li>
	
	<li>
		<a href="/2008/02/04/boostasio-tcp-resolver/">boost::asio TCP resolver</a>
	</li>
	
	<li>
		<a href="/2008/02/04/anticheatengine/">AntiCheatEngine</a>
	</li>
	
	<li>
		<a href="/2008/01/29/solid-compression/">Solid Compression</a>
	</li>
	
</ul>
		</div>
	</div>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
	

  </body>
</html>