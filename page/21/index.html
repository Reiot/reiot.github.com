<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="A social game developer wandering strange dungeons...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="/assets/js/google-code-prettify/prettify.css" rel="stylesheet">
    <link href="/assets/css/droppress.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top navbar-inverse">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
            <form class="navbar-search pull-right">
              <input type="text" class="search-query" placeholder="Title Search">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	

	<div class="row">
		<div class="span9">
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/10/boost-serialization/">boost::serialization</a> <small>2008-02-10</small></h1>
	</div>
	<div><p>boost::serialization 은, 템플릿 멤버 함수 하나 또는 free function 하나만 정의하면, 해당 클래스를 다양한 스트림으로 직렬화할 수 있게 해준다. 특히 list - vector - map - set 등의 다양한 STL 컨테이너들을 지원한다는 것이 장점이다.</p>
<p>이때, 매크로 없이 &amp; 연산자 만으로 읽고 쓰기를 가능하게 했는데, 이건 템플릿 아카이브 파라미터가 알아서 잘 읽거나 쓰도록 책임을 전가했다는 게 상당히 아름답다.. 단, virtual 이 아니라서 하위 클래스는 모두 이걸 정의해줘야 한다. 그리고 아직 hash_map 은 잘 지원하지 않는 모양인데, 뭔가 복잡한 사정이 있는 듯하다.</p>
<p>주의할 점이라면 아래 예제처럼 쓰려는 객체가 const 여야 한다는 점 정도?</p>
<pre><code>
#include &quot;stdafx.h&quot;

#include &lt;fstream&gt;

#include &lt;boost/archive/text_oarchive.hpp&gt;
#include &lt;boost/archive/text_iarchive.hpp&gt;

#include &lt;boost/archive/binary_oarchive.hpp&gt;
#include &lt;boost/archive/binary_iarchive.hpp&gt;

#include &lt;boost/serialization/list.hpp&gt;
#include &lt;boost/serialization/vector.hpp&gt;
#include &lt;boost/serialization/map.hpp&gt;
#include &lt;boost/serialization/hash_map.hpp&gt;

class chat_message
{
    friend class boost::serialization::access;
public:

    chat_message() {}

    chat_message(unsigned short id, unsigned short body_length, string msg, wstring wmsg)
        : id_(id)
        , body_length_(body_length)
        , message(msg)
        , wmessage(wmsg)
    {
        for ( size_t i = 0 ; i &lt; 10 ; i ++ )
        {
            string val = boost::str(boost::format(&quot;Hello %1%&quot;)%i);
            messages[i] = val;
            array_[i] = val;
            list_.push_back(i);
            vector_.push_back(i);
            map_[i] = val;
            hash_map_[val] = (rand()%2==0 ? true : false);
        }
    }

    template&lt;class Archive&gt;
    void serialize(Archive &amp; ar, const unsigned int version)
    {
        ar &amp; id_;
        ar &amp; body_length_;
        ar &amp; message;
        ar &amp; wmessage;
        ar &amp; messages;          // pritimive array
        ar &amp; array_.elems;      // boost::array
        ar &amp; list_;             // std::list
        ar &amp; vector_;           // std::vector
        ar &amp; map_;              // std::map
        //ar &amp; hash_map_;
    }

    void check_equal( const chat_message &amp; r ) const
    {
        BOOST_CHECK_EQUAL(id_,r.id_);
        BOOST_CHECK_EQUAL(body_length_,r.body_length_);
        BOOST_CHECK_EQUAL(message,r.message);
        BOOST_CHECK(wmessage==r.wmessage);

        for ( size_t i = 0 ; i &lt; 10 ; i ++ )
        {
            BOOST_CHECK_EQUAL(messages[i],r.messages[i]);
        }

        for ( size_t i = 0 ; i &lt; array_.size() ; i ++ )
        {
            BOOST_CHECK_EQUAL(array_[i],r.array_[i]);
        }

        {
            BOOST_REQUIRE_EQUAL( list_.size(), r.list_.size() );
            list&lt;float&gt;::const_iterator itr = list_.begin();
            list&lt;float&gt;::const_iterator itr2 = r.list_.begin();
            for ( ; itr != list_.end() ; itr ++, itr2++ )
            {
                BOOST_CHECK_EQUAL( *itr, *itr2 );
            }
        }

        {
            BOOST_REQUIRE_EQUAL( vector_.size(), r.vector_.size() );
            vector&lt;int&gt;::const_iterator itr = vector_.begin();
            vector&lt;int&gt;::const_iterator itr2 = r.vector_.begin();
            for ( ; itr != vector_.end() ; itr ++, itr2++ )
            {
                BOOST_CHECK_EQUAL( *itr, *itr2 );
            }
        }

        {
            BOOST_REQUIRE_EQUAL( map_.size(), r.map_.size() );
            map&lt;int,string&gt;::const_iterator itr = map_.begin();
            map&lt;int,string&gt;::const_iterator itr2 = r.map_.begin();
            for ( ; itr != map_.end() ; itr ++, itr2++ )
            {
                BOOST_CHECK_EQUAL( itr-&gt;first, itr2-&gt;first );
                BOOST_CHECK_EQUAL( itr-&gt;second, itr2-&gt;second );
            }
        }

        //{
        //  BOOST_REQUIRE_EQUAL( hash_map_.size(), r.hash_map_.size() );
        //  stdext::hash_map&lt;string,bool&gt;::const_iterator itr = hash_map_.begin();
        //  stdext::hash_map&lt;string,bool&gt;::const_iterator itr2 = r.hash_map_.begin();
        //  for ( ; itr != hash_map_.end() ; itr ++, itr2++ )
        //  {
        //      BOOST_CHECK_EQUAL( itr-&gt;first, itr2-&gt;first );
        //      BOOST_CHECK_EQUAL( itr-&gt;second, itr2-&gt;second );
        //  }
        //}
    }
private :
    unsigned short id_;
    unsigned short body_length_;
    string message;
    wstring wmessage;
    string messages[10];
    boost::array&lt;string,10&gt; array_;
    list&lt;float&gt; list_;
    vector&lt;int&gt; vector_;
    map&lt;int,string&gt; map_;
    stdext::hash_map&lt;string,bool&gt; hash_map_;
};

// TODO
// - archive from/to buffer
// - user defined archive
// - string, wstring load/save
// - stl support (list,vector,map)

BOOST_AUTO_TEST_CASE(test_serialize)
{
    const chat_message msg1(35, 59, &quot;Hello World!&quot;,L&quot;Welcome!&quot;);

    {
        chat_message msg2;

        std::ofstream ofs(&quot;serialize.txt&quot;);
        boost::archive::text_oarchive oa(ofs);
        oa &lt;&lt; msg1;
        ofs.close();

        std::ifstream ifs(&quot;serialize.txt&quot;);
        boost::archive::text_iarchive ia(ifs);
        ia &gt;&gt; msg2;
        ifs.close();

        msg1.check_equal(msg2);
    }

    {
        chat_message msg2;

        std::ofstream ofs(&quot;serialize.bin&quot;, std::ios::binary);
        boost::archive::binary_oarchive oa(ofs);
        oa &lt;&lt; msg1;
        ofs.close();

        std::ifstream ifs(&quot;serialize.bin&quot;, std::ios::binary);
        boost::archive::binary_iarchive ia(ifs);
        ia &gt;&gt; msg2;
        ifs.close();

        msg1.check_equal(msg2);
    }

    {
        chat_message msg2;

        boost::asio::streambuf buf;
        ostream os(&amp;buf);
        boost::archive::text_oarchive oa(os);
        oa &lt;&lt; msg1;

        istream is(&amp;buf);
        boost::archive::text_iarchive ia(is);
        ia &gt;&gt; msg2;

        msg1.check_equal(msg2);
    }

    {
        chat_message msg2;

        boost::asio::streambuf osf;
        boost::archive::binary_oarchive oa(osf);
        oa &lt;&lt; msg1;

        boost::archive::binary_iarchive ia(osf);
        ia &gt;&gt; msg2;

        msg1.check_equal(msg2);
    }

    // via istream/ostream
    {
        chat_message msg2;

        boost::asio::streambuf buf;
        ostream os(&amp;buf);
        boost::archive::binary_oarchive oa(os);
        oa &lt;&lt; msg1;

        istream is(&amp;buf);
        boost::archive::binary_iarchive ia(is);
        ia &gt;&gt; msg2;

        msg1.check_equal(msg2);
    }

}
</code></pre></div>
	<br />
	<p>
	
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/09/boost_asio_iostream/">boost::asio iostream</a> <small>2008-02-09</small></h1>
	</div>
	<div><p>문자열 기반의 네트워크 입출력 프로그래밍을 해야 한다면, ASIO 의 iostream 을 사용하면 간단히 해결된다.</p>
<p>boost::asio::io_service 같이 모호한 객체 선언도 필요없고, 연결 관리나 버퍼링 같은 개념도 적당히 무시할 수 있어서, 예외 처리만 잘 한다면 원격 로그라든지 XML RPC  클라이언트 같은 곳에 써먹을 수 있을 것 같다.</p>
<p>만약 복잡한 문자열 조작이 필요하다면 boost::string_algo 정도면 충분하고, 정규식이 필요하면 boost::regexp 을 가져다 사용하면 될 듯하다.</p>
<!--more-->

<pre><code>
// 문자열 기반의 네트워크 입출력 스트림
BOOST_AUTO_TEST_CASE( test_iostream )
{
    string http_request =
        &quot;GET / HTTP/1.0\r\n&quot;
        &quot;Host: reiot.cafe24.com\r\n\r\n&quot;;
    string expected_http_response[] = { &quot;HTTP/1.0 200 OK&quot;, &quot;HTTP/1.1 200 OK&quot; };

    {

        tcp::iostream io_(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);

        io_    &lt;&lt; http_request &lt;&lt; flush;    // or io_.flush();

        vector&lt;string&gt; http_response;
        while ( !io_.eof() )
        {
            string line;
            getline(io_,line);
            http_response.push_back(line);
        }

        BOOST_CHECK_EQUAL( boost::trim_copy(http_response[0]), expected_http_response[1] );

        io_.close();
    }

    {
        string host = &quot;www.google.co.kr&quot;;
        tcp::iostream io_(host,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/&quot; &lt;&lt; 1 &lt;&lt; &quot;.&quot; &lt;&lt; 0 &lt;&lt; endl
            &lt;&lt; &quot;Host: &quot; &lt;&lt; host &lt;&lt; endl &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        vector&lt;string&gt; http_response;
        while ( !io_.eof() )
        {
            string line;
            getline(io_,line);
            http_response.push_back(line);
        }

        BOOST_CHECK_EQUAL( boost::trim_copy(http_response[0]), expected_http_response[0] );
    }

    {
        tcp::iostream io_(&quot;www.naver.com&quot;,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/1.0&quot; &lt;&lt; endl
            &lt;&lt; &quot;Host: www.naver.com&quot; &lt;&lt; endl
            &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        stringstream response;
        while ( !io_.eof() )
        {
            char ch = io_.get();
            response &lt;&lt; ch;
        }

        string line;
        getline(response,line);
        BOOST_CHECK_EQUAL( boost::trim_copy(line), expected_http_response[1] );
    }

    {
        tcp::iostream io_(&quot;clien.career.co.kr&quot;,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/1.0&quot; &lt;&lt; endl
            &lt;&lt; &quot;Host: clien.career.co.kr&quot; &lt;&lt; endl
            &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        stringstream response;
        while ( !io_.eof() )
        {
            char buf[128];
            io_.read(buf,127);
            size_t nread = io_.gcount();
            if ( nread &gt; 0 )
            {
                buf[nread] = 0;
                response &lt;&lt; buf;               
            }
        }

        string line;
        getline(response,line);
        BOOST_CHECK_EQUAL( boost::trim_copy(line), expected_http_response[1] );
    }
}

</code></pre></div>
	<br />
	<p>
	
	
		<a href="/tag/ASIO/"><span class="label"><span class="icon icon-tag"></span> ASIO</span></a>
	
		<a href="/tag/boost/"><span class="label"><span class="icon icon-tag"></span> boost</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/09/boost-test-thread-safe/">boost::test thread safe</a> <small>2008-02-09</small></h1>
	</div>
	<div><p>다른 표준 라이브러리와 마찬가지로, boost::test 역시 멀티쓰레드에 대해서 안전하지 않다. 물론 BOOST_CHECK 등의 테스트 매크로들은 내부적으로 싱글톤을 사용하기 때문에, 쓰레드 함수 내부에서 사용하더라도 실패할 경우 에러 메시지를 출력해주지만, 다른 쓰레드에서 동일한 순간에 역시 같은 매크로를 호출하게 되면 콜스택 깊은 곳에서 난감한 에러를 뱉어버린다.</p>
<p>이걸 해결하려면 결국 mutex 로 테스트 매크로들을 wrap 한 또다른 매크로를 만들어서 써야 하는 수 밖에 없다.</p>
<pre><code>
#define SAFE_BOOST_CHECK_EQUAL(m,x,y) { \
boost::mutex::scoped_lock lock(m); \
BOOST_CHECK_EQUAL(x,y); }

void boost_check_always( boost::mutex * m )
{
boost::timer timer_;

while(timer_.elapsed() &lt; 10.f )
{
SAFE_BOOST_CHECK_EQUAL(*m,1,1);
}

}

BOOST_AUTO_TEST_CASE( test_boost_check_always )
{
boost::mutex m;
boost::thread t(boost::bind(boost_check_always,&amp;m));

boost::timer timer_;
while(timer_.elapsed() &lt; 10.f )
{
SAFE_BOOST_CHECK_EQUAL(m,1,1);
}

t.join();
}
</code></pre></div>
	<br />
	<p>
	
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/04/boostasio-tcp-resolver/">boost::asio TCP resolver</a> <small>2008-02-04</small></h1>
	</div>
	<div><p>한가로운 주말, 최신 BOOST 를 vc81로 빌드하고 <a href="http://asio.sourceforge.net/">ASIO</a>를 만지작거려 봤다. 대충 훑어본 바, 이 정도면 지금 코드에서 충분히 ACE를 제거해도 될 수준의 기능인 듯하다. 어차피 둘 다 디버깅 들어가면 템플릿 사이에서 헤매이는 건 마찬가지니...</p>
<!--more-->

<pre><code>
// TODO multiple ip address in localmachine (..localmachine)
BOOST_AUTO_TEST_CASE( test_resolver )
{
 boost::asio::io_service io_service;
 boost::system::error_code error;
 tcp::resolver resolver(io_service);
 tcp::resolver::iterator end_;

 // localmachine
 {
  tcp::resolver::query query(boost::asio::ip::host_name(),&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;192.168.10.101&quot; );
 }

 // host -&gt; ip
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
 }

 // localhost
 {
  tcp::resolver::query query(&quot;localhost&quot;,&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;127.0.0.1&quot; );
  if ( ++iterator != end_ )
  {
   _endpoint = *iterator;
   BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;192.168.10.101&quot; );
  }
 }

 // http
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 80 );
 }

 // ftp
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;ftp&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 21 );
 }

 // telnet
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;telnet&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 23 );
 }

 // unknown host
 {
  tcp::resolver::query query(&quot;reiot1.com&quot;,&quot;&quot;);
  resolver.resolve(query,error);
  BOOST_CHECK_EQUAL( error.value(), boost::asio::error::host_not_found );
 }

 // unknown service
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;test&quot;);
  resolver.resolve(query,error);
  BOOST_CHECK_EQUAL( error.value(), boost::asio::error::service_not_found );
 }
}

void print_address(const boost::system::error_code&amp; e, tcp::resolver::iterator itr )
{
 tcp::endpoint endpoint_ = *itr;
 BOOST_MESSAGE( endpoint_.address() );
}

class AsyncResolveHandler
{
public :
 AsyncResolveHandler( int errorcode ) : address_(&quot;&quot;), port_(0), errorcode_(errorcode) {}
 AsyncResolveHandler( std::string addr, int port = 0 ) : address_(addr), port_(port) {}
 void operator() (const boost::system::error_code&amp; e, tcp::resolver::iterator itr )
 {
  if ( !e )
  {
   tcp::endpoint endpoint_ = *itr;
   BOOST_CHECK_EQUAL( endpoint_.address().to_string(), address_ );
   if ( port_ != 0 )
   {
    BOOST_CHECK_EQUAL( endpoint_.port(), port_ );
   }
  }
  else
  {
   BOOST_CHECK_EQUAL( e.value(), errorcode_ );
  }
 }
 std::string address_;
 int port_;
 int errorcode_;
};

BOOST_AUTO_TEST_CASE( test_async_resolver )
{
 boost::asio::io_service io_service;

 tcp::resolver resolver(io_service);

 boost::system::error_code error;

 // host -&gt; ip
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // localhost -&gt; 127.0.0.1
 {
  tcp::resolver::query query(&quot;localhost&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;127.0.0.1&quot;));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // http
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,80));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();

 }

 // ftp
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;ftp&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,21));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // telnet
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;telnet&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,23));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // unknown host
 {
  tcp::resolver::query query(&quot;reiot1.com&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(boost::asio::error::host_not_found));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // unknown service
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;test&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(boost::asio::error::service_not_found));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }
}

</code></pre></div>
	<br />
	<p>
	
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2008/02/04/anticheatengine/">AntiCheatEngine</a> <small>2008-02-04</small></h1>
	</div>
	<div><p>원래는 Cheat Engine 으로도 freeze 를 걸 수 없는 안전한 변수를 만들기 위해서 만든 클래스다. 여기에 CRC라든지 XOR도 넣고, 또 값이 바뀔 때마다 위치도 바꾸고 할려고 했는데, 가만히 생각해보니 속도도 제법 느리고 막상 함수 내에 아래와 같이 로컬 캐시가 있다면 그걸 바꿔버리면 전혀 쓸모 없어져서 그냥 포기버렸다.</p>
<pre><code>
float speed = ac.Get&lt;float&gt;(&quot;speed&quot;);
// -- inject code here --
check_next_pos(pos,speed);
</code></pre>

<p><a href="http://reiot.cafe24.com/2008/02/03/ai-game-programming-wisdom-3/">어제 주문한 책들</a>이 도착하면 다시 한번 도전해볼까 싶기도 하지만, assembly 쪽 지식이 전무해서...</p>
<!--more-->

<pre><code>
// AntiCheatEngine.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.
//

#include &quot;stdafx.h&quot;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;hash_map&gt;

#pragma warning(disable:4819)
#define BOOST_TEST_MAIN
#include &lt;boost/format.hpp&gt;
#include &lt;boost/test/unit_test.hpp&gt;

using std::string;

size_t GenerateIndex()
{
static size_t key = 0;
return key++;
}

class AntiCheat
{
typedef std::vector&lt;size_t&gt; INDEX_LIST;
typedef stdext::hash_map&lt;string, INDEX_LIST &gt; KEY_MAP;

public :

AntiCheat( size_t N = 1024*64 )
{
m_Buffer.assign(N,0);
m_UnusedIndex.assign(N,0);
std::generate(m_UnusedIndex.begin(),m_UnusedIndex.end(),GenerateIndex);
std::random_shuffle(m_UnusedIndex.begin(),m_UnusedIndex.end());
}

bool IsValid() const { return true; }

unsigned int GetCRC() { return m_CRC; }

// FIXME use ASSERT, dont check return value
template&lt;class T&gt;
bool Set( const string &amp; name , const T &amp; valueIn )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
INDEX_LIST idxList;
for ( size_t i = 0 ; i &lt; sizeof(valueIn); i ++ )
{
if ( m_UnusedIndex.empty() )
return false;
size_t idx = m_UnusedIndex.back();
m_UnusedIndex.pop_back();
idxList.push_back(idx);
}

itr = m_Keys.insert(make_pair(name,idxList)).first;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
m_Buffer[idx] = reinterpret_cast&lt;const char*&gt;(&amp;valueIn)[i];
}

return true;
}

template&lt;typename T&gt;
bool Get( const string &amp; name, T &amp; valueOut )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
return false;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
reinterpret_cast&lt;char*&gt;(&amp;valueOut)[i] = m_Buffer[idx];
}
return true;
}

size_t GetUnusedIndexCount() const { return m_UnusedIndex.size(); }

unsigned int m_CRC;

INDEX_LIST m_UnusedIndex;
std::vector&lt;unsigned char&gt; m_Buffer;
KEY_MAP m_Keys;
};

//////////////////////////////////////////////////////////////////////////
template&lt;&gt;
bool AntiCheat::Set&lt;string&gt;( const string &amp; name, const string &amp; valueIn )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
INDEX_LIST idxList;
for ( size_t i = 0 ; i &lt; valueIn.size(); i ++ )
{
if ( m_UnusedIndex.empty() )
return false;
size_t idx = m_UnusedIndex.back();
m_UnusedIndex.pop_back();
idxList.push_back(idx);
}

itr = m_Keys.insert(make_pair(name,idxList)).first;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
m_Buffer[idx] = valueIn[i];
}

return true;
}

template&lt;&gt;
bool AntiCheat::Get&lt;string&gt;( const string &amp; name, string &amp; valueOut )
{
KEY_MAP::iterator itr = m_Keys.find(name);
if ( itr == m_Keys.end() )
{
return false;
}

INDEX_LIST &amp; indexList = itr-&gt;second;

// FIXME 최초 크기 보다 작은 사이즈는 저장할 수 없다?
valueOut.assign(indexList.size(),0);
for ( size_t i = 0 ; i &lt; indexList.size() ; i ++ )
{
size_t idx = indexList[i];
valueOut[i] = m_Buffer[idx];
}
return true;
}

BOOST_AUTO_TEST_CASE( test1 )
{
AntiCheat ac(100);

BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100 );

BOOST_CHECK( ac.IsValid() );

string strIn = &quot;World&quot;, strOut;

{
ac.Set(&quot;string&quot;,strIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;string&gt;(&quot;string&quot;,strOut) );
BOOST_CHECK_EQUAL( strIn, strOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size());
}

{
int intIn, intOut;

intIn = 1;
ac.Set(&quot;int&quot;,intIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;int&gt;(&quot;int&quot;,intOut) );
BOOST_CHECK_EQUAL( intIn, intIn );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int));

intIn = -1;
ac.Set(&quot;int&quot;,intIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;int&gt;(&quot;int&quot;,intOut) );
BOOST_CHECK_EQUAL( intIn, intIn );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int));
}

{
bool boolIn, boolOut;

boolIn = true;
ac.Set(&quot;bool&quot;,boolIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;bool&gt;(&quot;bool&quot;,boolOut) );
BOOST_CHECK_EQUAL( boolIn, boolOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool));

boolIn = true;
ac.Set(&quot;bool&quot;,boolIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;bool&gt;(&quot;bool&quot;,boolOut) );
BOOST_CHECK_EQUAL( boolIn, boolOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool));
}

{
float floatIn, floatOut;

floatIn = 1.234f;
ac.Set(&quot;float&quot;,floatIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;float&gt;(&quot;float&quot;,floatOut) );
BOOST_CHECK_EQUAL( floatIn, floatOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool)-sizeof(float));

floatIn = -56.78f;
ac.Set(&quot;float&quot;,floatIn);
BOOST_CHECK( ac.IsValid() );
BOOST_CHECK( ac.Get&lt;float&gt;(&quot;float&quot;,floatOut) );
BOOST_CHECK_EQUAL( floatIn, floatOut );
BOOST_CHECK_EQUAL( ac.GetUnusedIndexCount(), 100-strIn.size()-sizeof(int)-sizeof(bool)-sizeof(float));
}

}

/*

값을 바꾸면 Key 및 CRC 가 바뀐다
멤버 함수가 아닌 다른 경로로 값을 바꾸면 CRC 체크가 깨져야 한다.
AntiCheat 는 하나의 큰 버퍼를 가진다. (ex: 32k)
여기에 변수를 키값을 이용해서 저장하고 읽어낸다.
이때 각 변수들은 바이트 단위로 흩어진다. 이때 흩어지는 인덱스는 저장하는 순간 랜덤하게, 중복되지 않게 결정된다.
(이때문에 unused index set 이 필요함)
또한 각 변수들은 Verifier 라는 range-checker 와 연동될 수 있다.
키값 역시 다이나믹하게 결정된다. (가령 player.hp 의 경우 매크로에 의해서 __K(PlayerHP) -&gt; 세션키와의 XOR 등등 )
Verify()를 호출하면 각 키에 대해서 Verify 한 다음,
특정 영역 마다 0xEF 등 boundry checker 를 넣어두고, 바뀌었는지 체크한다.

문자열일 경우 (길이 2바이트,본문) 이렇게 저장해야 한다. 만약 길이가 달라질 경우 인덱스를 새로 얻어 오거나 반납해야 한다.

*/
</code></pre></div>
	<br />
	<p>
	
	
	</p>
</div>
			
			<div class="pagination pagination-centered">
				<ul>
				
					<li><a href="/page/18/">&laquo;</a></li>
				
				
				  	<li >
				  	
				    	<a href="/page/19/">19</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/20/">20</a>
				    
				  	</li>
		  		
				  	<li class="active">
				  	
				    	<a href="/page/21/">21</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/22/">22</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/23/">23</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/24/">24</a>
				    
				  	</li>
		  		
				
					<li><a href="/page/25/">&raquo;</a></li>
				
		  		</ul>
			</div>
		</div>
		<div class="span3">
			<ul class="nav nav-list well dsq-widget">
	<li>
		
		<a href="http://facebook.com/reiot" style="display: inline-block"><img src="/assets/img/facebook.png" /></a>
		
		
		<a href="http://twitter.com/reiot" style="display: inline-block"><img src="/assets/img/twitter.png" /></a>
		
	    <a href="atom.xml" style="display: inline-block"><img src="/assets/img/rss.png" /></a>
	</li>
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2008/02/10/boost-serialization/">boost::serialization</a>
	</li>
	
	<li>
		<a href="/2008/02/09/boost_asio_iostream/">boost::asio iostream</a>
	</li>
	
	<li>
		<a href="/2008/02/09/boost-test-thread-safe/">boost::test thread safe</a>
	</li>
	
	<li>
		<a href="/2008/02/04/boostasio-tcp-resolver/">boost::asio TCP resolver</a>
	</li>
	
	<li>
		<a href="/2008/02/04/anticheatengine/">AntiCheatEngine</a>
	</li>
	
	<li class="nav-header dsq-widget-title">
		Recent Comments
	</li>
	<script type="text/javascript" src="http://reiot.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script>
</ul>
		</div>
	</div>

	<footer>
	<p class="pull-right">
		<a href="http://github.com/Reiot/droppress" class="btn btn-success btn-mini">powered by DropPress 0.0.1</a>
	</p>
</footer>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/google-code-prettify/prettify.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/droppress.js"></script>
	

  
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-247024-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
  

  </body>
</html>