<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Social Game Developer wandering strange dungeon...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	<div class="row">
		<div class="span9">
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/26/spread/">Spread</a> <small>2006-04-26</small></h1>
	</div>
	<div><h1>개요</h1>
<p><a href="http://www.spread.org">Spread</a>는 그룹 기반의 UDP 메시징 라이브러리로, unicast &amp; multicast 및 scattered send/receive를 지원한다. 단 PeerToPeer 모델이 아니라, 독립적인 어플리케이션인 Spread 데몬이 가운데에서 중계를 해주는, 일종의 메시지 버스의 역할을 한다. RakNet 과 마찬가지로 다양한 UDP 전송 방식을 지원한다.</p>
<table>
<thead>
<tr>
<th>전송방식</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unreliable</td>
<td>least</td>
</tr>
<tr>
<td>Reliable</td>
<td>will get there, no ordering</td>
</tr>
<tr>
<td>Fifo</td>
<td>reliable and ordered fifo by source</td>
</tr>
<tr>
<td>Causal</td>
<td>reliable and all mesg from any source of this  level are causally ordered</td>
</tr>
<tr>
<td>Agreed</td>
<td>reliable and all mesg from any source of this level are totally ordered</td>
</tr>
<tr>
<td>Safe</td>
<td>Agreed ordering and mesg will not be delivered to application until the mesg has reached ALL receipients' daemons</td>
</tr>
</tbody>
</table>
<h1>성능</h1>
<p>문서에 의하면 1k 메시지 8000개를 1초에 전송 보장한다고 하며, 또한, <a href="http://www.cnds.jhu.edu/pub/papers/cnds-2004-1.pdf">The Spread Toolkit: Architecture and Performance</a>에 따르면 만개의 그룹에서 Safe 메시지를 보낼 때의 지연 시간이 6ms 라고 나온다. 실제로, 파이썬 바인딩을 이용한 클라이언트와 (아무런 부하를 주지 않은) localhost 데몬과의 테스트 결과 0.25ms 정도의 반응 시간을 보여줬다.</p>
<table>
<thead>
<tr>
<th>전송방식</th>
<th>평균 ping 시간</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNRELIABLE_MESS</td>
<td>0.248ms</td>
</tr>
<tr>
<td>RELIABLE_MESS</td>
<td>0.248ms</td>
</tr>
<tr>
<td>FIFO_MESS</td>
<td>0.247ms</td>
</tr>
<tr>
<td>CAUSAL_MESS</td>
<td>0.247ms</td>
</tr>
<tr>
<td>AGREED_MESS</td>
<td>0.247ms</td>
</tr>
<tr>
<td>SAFE_MESS</td>
<td>0.248ms</td>
</tr>
</tbody>
</table>
<p>로컬랜에 연결된 2개의 머신에서 한쪽(Windows XP, P4 2G + 512M)에 데몬을 real time priority 로 띄우고 다른 쪽에 송수신 전용 쓰레드를 가진 테스트 클라이언트를 붙인 다음, 초당 8000개의 4byte 메시지를 보내는 경우 CPU 사용량 100% 에 RTT 0.8s 가 나왔다. 즉 1초 안에 전송은 보장하지만 반응 속도는 영 좋지 않았다. 그리고 로컬랜의 방화벽 바깥에 있는 머신(Windows 2003 + P4 2.8G + RAM 2G)에 데몬을 띄우고 방화벽 안쪽에서 테스트한 결과, 초당 4000개를 보내면 연결이 끊기며 초당 1000개를 보내면 0.8s 의 반응 속도를 보여줬다.</p>
<h1>예상되는 용도</h1>
<dl>
<dt>컨텐트 중계 서버</dt>
<dd>채팅 채널, 파티 채팅, 길드 채팅을 중계해주는 서버. 굳이 채팅 서버를 두지 않아도 무방할 듯. 그 역할을 Spread Daemon 이 해주니까.</dd>
<dt>게이트웨이 서버</dt>
<dd>M:N 관계에 있는 tier 에서의 중계 서버 역할. 가령 N개의 에이전트와 M개의 게임서버간의 연결을 TCP로 하게 되면 각 에이전트는 M개의 TCP연결을 하고 그것을 관리해야 한다. 이를 1개의 Spread 연결로 해결할 수 있다. (M개의 그룹에 대해 1개의 연결을 사용한다는 가정 하에서...) 마찬가지로 게임서버는 1개의 Spread 연결에 대해서만 처리하게 되므로 이벤트 드리븐이 간단하게 이루어진다. 가령 클라이언트가 에이전트에 로그인하고 이전 위치를 로딩하게 되면, 에이전트는 해당 서버 그룹에 join 하고, 클라이언트가 로그아웃하면 그룹에서 leave 하면 된다. (ref-counting을 사용하면 간단) 서버간 이동도 마찬가지로 처리할 수 있다. 단 이렇게 될 경우 데몬이 다운되면 게임 끝이다.</dd>
<dt>브로드캐스트 서버</dt>
<dd>(현실성이 없는 이야기지만) 게임 서버의 각 브로드캐스트 영역(일명 Area)을 그룹으로 간주하고, 그 안에 들어있는 플레이어들에게 멀티캐스팅할 수 있겠다. 단 이런 모델은 잦은 그룹 join/leave 가 이루어지므로 Area 개수가 늘어날수록 부하가 심해질 듯. 1000개의 그룹일 경우 35ms 정도니까... 10000개면...</dd>
<dt>데이터 복제 서버</dt>
<dd>게임 서버의 경계 영역에서의 데이터 변화를, 이를 공유하는 다른 서버로 복제한다. 예를 들면, NPC 길찾기를 위한 동적 객체 정보를 게임 서버에서 NPC 에이전트로 복제하는 등.</dd>
</dl>
<h1>참고사항</h1>
<p>경험자의 말에 의하면, windows xp 와의 궁합이 잘 맞지 않다고 한다. 대신 windows 2000 에서는 잘 된다고 하는데, 커널의 네트워크 모듈과의 궁합 문제일 가능성이 있다고 한다. 즉 windows 2003 에서 테스트를 더 해봐야 한다는 의미.</p>
<p>see also:</p>
<ul>
<li><a href="http://www.spread.org/docs/guide/users_guide.pdf">Spread User Guide</a></li>
<li><a href="http://www.zope.org/Members/tim_one/spread/">Python Spread</a></li>
<li><a href="http://www3.telus.net/taj_khattra/luaspread.html">Lua Spread</a></li>
</ul>
<!--more-->

<pre><code>
#format python
import spread
import unittest
import time

daemon = '3333@localhost'

class SpreadTest(unittest.TestCase):
  def testConnect(self):
  mbox = spread.connect(daemon,'test1')
  self.failUnless( mbox.fileno &gt; 0 )
  mbox.disconnect()
  def testJoin(self):
  mbox = spread.connect(daemon,'test2')
  mbox.join('test1')
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( str(type(msg)) , &quot;&quot; )
  self.failUnlessEqual( msg.group , &quot;test1&quot; )
  self.failUnlessEqual( msg.reason, spread.CAUSED_BY_JOIN )
  mbox.leave('test1')
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( str(type(msg)) , &quot;&quot; )
  self.failUnlessEqual( msg.group , &quot;test1&quot; )
  self.failUnlessEqual( msg.reason, spread.CAUSED_BY_LEAVE )
  mbox.disconnect()
  def testLeave(self):
  mbox = spread.connect(daemon,'test2')
  mbox.join('test1')
  mbox.leave('test2')
  mbox.disconnect()
  def testSend(self):
  mbox = spread.connect(daemon,'test3')
  group = 'StressTesters'
  message = 'Hello Spread!'
  mbox.join(group)
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( msg.reason, spread.CAUSED_BY_JOIN )
  mbox.multicast( spread.FIFO_MESS, group, message)
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( msg.groups[0], group )
  self.failUnlessEqual( msg.message, message )
  mbox.leave(group)
  mbox.disconnect()

def testPing( trycount = 100 ):
  mbox = spread.connect(daemon,'StressTester')
  group = 'StressTesters'
  mbox.join(group)
  msg = mbox.receive()
  assert msg.reason == spread.CAUSED_BY_JOIN

  service_types = (
  spread.UNRELIABLE_MESS,
  spread.RELIABLE_MESS,
  spread.FIFO_MESS,
  spread.CAUSAL_MESS,
  spread.AGREED_MESS,
  spread.SAFE_MESS )
  service_type_str = (
  'UNRELIABLE_MESS',
  'RELIABLE_MESS',
  'FIFO_MESS',
  'CAUSAL_MESS',
  'AGREED_MESS',
  'SAFE_MESS' )
  ping_stat = []

  for service_type in service_types:
  ping_count = 0
  total_ping = 0
  for i in range(0,trycount):
  mbox.multicast( service_type, group, str(time.clock()) )
  msg = mbox.receive()
  total_ping = total_ping + time.clock() - float( msg.message )
  ping_count = ping_count + 1

  if ping_count &gt; 0 :
  ping_stat.append( total_ping / ping_count )
  else:
  ping_stat.append(0)

  for i in range( 0, len(service_type_str) ):
  print &quot;%15s : %8f&quot; %( service_type_str[i],ping_stat[i])

  mbox.leave(group)
  msg = mbox.receive()
  assert msg.reason == spread.CAUSED_BY_LEAVE

  mbox.disconnect()
if __name__ == '__main__':
  testPing(10000)
  #unittest.main()
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/26/python-tips/">Python Tips</a> <small>2006-04-26</small></h1>
	</div>
	<div><h3># asyncore.dispatcher</h3>
<pre><code>- 원래부터 nonblocking 이다.
- set_socket 하는 시점에 map 에 등록된다.
</code></pre>
<h3># StringIO.readline()</h3>
<p>StringIO 는 file-like 객체이므로 readline() 을 지원한다. 그러나 write() 한 후 읽어들이면 None 을 리턴한다. 내부적으로 유지하는 offset 이 하나이기 때문인데, 만약 사용하려면 offset(0) 을 호출해서 포인터를 맨 앞으로 돌려줘야 한다. (너무 단순한가?)</p>
<h3># zipfile</h3>
<p>zip 포맷으로 특정 폴더를 압축하기 위해서는 다음과 같이 해야 한다. 이때 압축 포맷으로 ZIP_DEFLATED 를 사용해야 파일 크기가 작아진다.</p>
<pre><code>
def zipdir(zfile,dir,base='.'):
&quot;&quot;&quot;zip directory recursively&quot;&quot;&quot;
print '\nzip %s'%dir,

global log
log.write('zip %s...'%dir)

for f in os.listdir(dir):
nf = os.path.join(dir,f)
if os.path.isdir(nf):
zipdir(zfile,nf,os.path.basename(dir))
else:
print '.',
zfile.write(nf,
os.path.join( base, os.path.basename(dir), f),
zipfile.ZIP_DEFLATED)
</code></pre>

<h3># dict(zip(seq1,seq2))</h3>
<p>keys와 values를 dict로 매치시킬 때 dict()와 zip()을 사용할 수 있다.</p>
<pre><code>
&gt;&gt;&gt; keys = [ 'aaa', 'bbb', 'ccc' ]
&gt;&gt;&gt; values = [ 1, 2, 3 ]
&gt;&gt;&gt; zip(keys,values)
[('aaa', 1), ('bbb', 2), ('ccc', 3)]
&gt;&gt;&gt; dict(zip(keys,values))
{'aaa': 1, 'bbb': 2, 'ccc': 3}
</code></pre>

<h3># re.findall</h3>
<p>스트링에서 특정 seperator 로 구분된 패턴으로 자를 때, string.split() 도 좋지만 re.findall() 을 강추</p>
<pre><code>
&gt;&gt;&gt; args = '&quot;SELECT * FROM User&quot;,&quot;aaa,bbb,ccc,ddd&quot;'
&gt;&gt;&gt; args.split('&quot;')
['', 'SELECT * FROM User', ',', 'aaa,bbb,ccc,ddd', '']
&gt;&gt;&gt; re.findall('&quot;(.+?)&quot;',args)
['SELECT * FROM User', 'aaa,bbb,ccc,ddd']
</code></pre>

<h3># re 를 이용한 파일명 변경</h3>
<p>특정 폴더 안에 여러가지 파일명들을 바꾸기 위해서는 re 모듈을 잘 사용해야 한다. 다음은 파일명에 {{{[...]}}} 을 없엘 때 쓰는 스크립트이다.</p>
<pre><code>
import os, re
os.chdir(target_folder)
for old_name in os.listdir('.'):
new_name = re.sub('\[.+\]','',old_name)
os.rename(old_name,new_name)
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/26/funny-memory-values/">Funny Memory Values</a> <small>2006-04-26</small></h1>
	</div>
	<div><p>from <a href="http://www.samblackburn.com/wfc/technotes/WTN006.htm">WFC Technical Note 006 - Funny Memory Values</a></p>
<p>윈도우 환경에서 디버깅을 하다 보면 0XCDCD 라든지 0XDDDD 같은 특이한 값들을 만날 수 있는데, 이게 그냥 가비지가 아니라 각각마다 특유의 의미를 가지고 있었다. 가령 0xDDDD는 이미 지워진 포인터라든지 0xFDFD는 힙에 할당한 값의 앞뒤에 위치하는 경계값이라든지 말이다.</p>
<p>한글로 된 설명은 <a href="http://codian.net/wp/archives/352">요기</a>와 <a href="http://www.trozan.net/blog/tag/%B5%F0%B9%F6%B1%D7">요기</a>가 제일 잘 되어 있으니 참고하시길.</p></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/25/udt-udp-based-data-transfer-library/">UDT : UDP-based Data Transfer Library</a> <small>2006-04-25</small></h1>
	</div>
	<div><p><a href="http://udt.sf.net">UDT</a>는 Internet2 혹은 기가비트 이더넷과 같이 빠른 네트워크에서 수십~수백 기가 바이트의 대용량 데이터를 전송할 때 TCP가 매우 느리다는 점때문에 시작된 오픈소스 프로젝트이다. 버클리 소켓 API를 그대로 유지하고 있어서 접근성이 좋고, TCP의 슬라이딩 윈도우 같은 Congestion Control 을 사용자가 상황에 맞게 조정할 수 있다는 장점이 있다. 2.0 버전까지는 UDP 스트림만을 지원했는데 3.0부터는 UDP 다이어그램과 중첩입출력(Overlapped)도 지원하기 시작했다. 현재 3.0 beta 가 나와 있는 상태이다.</p>
<p>이번에 reliable UDP 라이브러리 조사 도중 탐지망에 걸려 들어서 검토한 결과, 하나의 소켓에 대해서 내부적으로 입력과 출력 쓰레드를 1개씩 사용하는 것을 발견했다. 원래부터 데이터 전송을 목적으로 구현되어서 그런 듯한데, 이를 수정하지 않고는 게임 서버에서 사용하기는 힘들다는 판단을 내렸다. 시간이 난다면 IOCP를 연동할 수 있게 살짝 고쳐 보고 싶지만, 누구 말마따나 게임 회사는 연구소가 아닌 관계로... OTL</p>
<p>결국 다시 RakNet으로 가야 된단 말인가...</p></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/25/codekeep/">CodeKeep</a> <small>2006-04-25</small></h1>
	</div>
	<div><p><a class="imagelink" href="http://boxcatstudio.files.wordpress.com/2009/07/codekeep.JPG" title="codekeep.JPG"><img alt="codekeep.JPG" src="http://boxcatstudio.files.wordpress.com/2009/07/codekeep.thumbnail.JPG" /></a><br />
<a href="http://msdn.microsoft.com/msdnmag/issues/05/12/VisualStudioAddins/default.aspx">Visual Studio Add-Ins Every Developer Should Download Now</a> 에서 비주얼 스튜디오를 위한 10 가지 필수 플러그인들을 만나볼 수 있다. 그 중에서 제일 마음에 드는 것은, 함수를 선택하면 파라미터를 읽어서 자동적으로 XML 코멘트를 만들어주는 <a href="http://www.roland-weigelt.de/ghostdoc">GhostDoc</a>과, 웹에서 코드 조각들을 검색해서 내 코드에 넣을 수 있는 <a href="http://www.codekeep.net/">CodeKeep</a>이라는 플러그인이다.</p>
<p>단 GhostDoc은 아직 VS2005 영문판만 지원해서 CodeKeep만 구경해볼 수 있었는데, 아직은 기부된 코드의 양이 부족한 듯해서 아쉬웠다. del.icio.us처럼 많은 사람들이 사용해줘야 시너지 효과가 날텐데, 홈페이지만 <a href="http://goodhyun.com/archives/2006/04/_co_oe_aoea_a_2.php">웹2.0 디자인</a>을 닮으려고 해서는 안될 것이다. 이런 식으로 팀 내부적으로 코드조각을 공유할 수 있는 솔루션이 있었으면 좋으련만... (누가 위키 기반으로 만들어주시게~~)</p></div>
	
</article>
			
			<ul class="pager">
			
			  	<li class="previous">
			    	<a href="/page/33/">&larr; Older</a>
			  	</li>
		  	
		  	
				<li class="next">
					<a href="/page/33">Newer &rarr;</a>
				</li>
		  	
			</ul>
		</div>
		<div class="span3">
			<ul class="nav nav-list well">
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2006/04/26/spread/">Spread</a>
	</li>
	
	<li>
		<a href="/2006/04/26/python-tips/">Python Tips</a>
	</li>
	
	<li>
		<a href="/2006/04/26/funny-memory-values/">Funny Memory Values</a>
	</li>
	
	<li>
		<a href="/2006/04/25/udt-udp-based-data-transfer-library/">UDT : UDP-based Data Transfer Library</a>
	</li>
	
	<li>
		<a href="/2006/04/25/codekeep/">CodeKeep</a>
	</li>
	
</ul>
		</div>
	</div>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
	

  </body>
</html>