<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Social Game Developer wandering strange dungeon...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	<div class="row">
		<div class="span9">
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/26/sql-tips/">SQL Tips</a> <small>2006-04-26</small></h1>
	</div>
	<div><p>MS-SQL SERVER + Transact SQL Tip</p>
<h2>IP 문자열에서 a.b.c 추출하기</h2>
<p>declare @ip varchar(20)<br />
SET @ip = '111.22.33.22'<br />
SELECT LEFT(@ip,len(@ip)-patindex('%.%',reverse(@ip)))</p>
<h2>리포팅 서비스</h2>
<p><a href="http://network.hanbitbook.co.kr/view.php?bi_id=1048">IIS + ASP + VisualStudio.NET 을 이용한 리포트 서비스 제작</a></p>
<h2>FTP 파일 업로드</h2>
<p>DTS 에서 제공하는 파일 전송 프로토콜 작업(FTPTask)의 경우, 다운로드만 가능하고 업로드는 지원하지 않는다. 가령, 로컬 백업한 <em>.bak, </em>.trn 파일을 리모트 서버로 옮기려면 업로드 스크립트를 SQL 이나 VB 또는 Python으로 직접 개발해야 한다.</p>
<h2>복구 모델</h2>
<p>당연히, 트랜잭션 로그를 남기려면 FULL 복구 모델로 데이터베이스를 설정해야 한다. 백업 정책을 세울 때 꼭 모델을 체크하기 바란다. (기본적으로 FULL 모델로 만들어지는 것 같지만, 필수적으로 체크할 것)</p>
<h2>SQLServerAgent</h2>
<p>유지 관리 계획 등 주기적인 작업을 실행하려면 기본적으로 꺼져있는 SqlServerAgent 를 켜야 한다.</p>
<h2>테이블 스키마 복사</h2>
<p>스크립트로 추출해서 다른 DB 에 설치할 경우 디폴트값이 지정되지 않는 경우가 있다. 이때 DEFAULT 등 제약조건 스크립팅에 꼭 체크를 해야 한다. 아니면 그냥 데이터 내보내기를 사용하길.</p>
<h2>노트북에 SQL Server 설치하기</h2>
<p>SQL Server 상위 버전들은 기본적으로 서버급 OS 에서만 설치된다. 그러나 노트북은 대체로 XP Professional or Home Edition 을 사용하는 법. 이를 지원하는 SQL Server 버전들을 살펴보자.<br />
<table><br />
<thead><br />
<th></th><br />
<th>XP Home</th><br />
<th>XP Pro</th><br />
<th>comment</th></p>
<tr>
<td>MSDE</td>
<td>O</td>
<td>O</td>
<td> </td>
</tr>

<tr>
<td>Evaluation Edition</td>
<td>O</td>
<td>O</td>
<td>120 일 평가판</td>
</tr>

<tr>
<td>Persional Edition</td>
<td>X</td>
<td>O</td>
<td> </td>
</tr>

<tr>
<td>Developer Edition</td>
<td>X</td>
<td>O</td>
<td> </td>
</tr>

<p></thead></table><br />
결국 XP Home Edition 을 사용하는 경우에는 평가판 또는 MSDE 를 사용해야 한다. 이참에 MSDE 의 새 버전인 SQL Server Express 2005 를 사용해보는 것도... <img alt="(" src="http://boxcatstudio.files.wordpress.com/2009/07/icon_sad.gif" /></p>
<p>see also: * [http://www.microsoft.com/sql/evaluation/overview/default.asp SQL Server Overview] - 여기에 버전별 비교표가 들어있다 * [http://go.microsoft.com/?linkid=2534867 120일 평가판 다운로드]</p>
<h2>NULL 비교</h2>
<p>NULL 에 대한 비교는 is 로 하라!</p>
<p>declare @a int<br />
SET @a = NULL</p>
<p>IF @a = NULL<br />
print '@a=NULL'<br />
IF @a IS NULL<br />
print '@a is NULL'</p>
<p>declare @b int<br />
SET @b = 1</p>
<p>IF @b &lt;&gt; NULL<br />
print '@b &lt;&gt; NULL'<br />
IF @b IS NOT NULL<br />
print '@b is not NULL'</p>
<p>-- 실행 결과<br />
@a IS NULL<br />
@b IS NOT NULL</p>
<h2>constraint 관리</h2>
<p>디폴트 constraint 를 삭제하고 다시 추가하는 법...</p>
<p>-- 삭제<br />
ALTER TABLE [dbo].[테이블] DROP<br />
CONSTRAINT [DF_테이블_컬럼]</p>
<p>-- 추가<br />
ALTER TABLE [dbo].[테이블] WITH NOCHECK ADD<br />
CONSTRAINT [DF_테이블_컬럼] DEFAULT (디폴트값) FOR [관련컬럼]</p>
<h2>CASE WHEN...</h2>
<p>다음은 승률을 나타내는 컬럼을 계산해오는 방식이다.</p>
<p>SELECT<br />
....<br />
CASE<br />
WHEN (WinCount + LoseCount + DrawCount) = 0 THEN 0.00<br />
ELSE round((WinCount * 1.0) / (WinCount + LoseCount + DrawCount) , 2)<br />
END AS WinRate,<br />
....</p>
<h2>SELECT...INTO...</h2>
<p>INSERT INTO...SELECT...가 존재하는 테이블에 데이터를 넣을 때 사용한다면, SELECT...INTO...는 새로운 테이블을 만들어 넣을 때 사용한다. 특히 통계 테이블에 데이터를 넣을 때, TRUNCATE TABLE xxx; INSERT INTO...SELECT를 하게 되면, 문제가 생길 수 있으므로 아예 DROP 한 다음 SELECT...INTO... 를 사용하도록 한다. (우리 DBA의 말씀~)</p>
<p>SELECT.. INTO는 MS-SQL의 기능! . 일반적인 ANSI-SQL에서는 CREATE TABLE ... SELECT 를 사용함.</p>
<h2>대용량 데이터 빨리 넣기</h2>
<pre><code>- 관련 데이터베이스의 로그 타입 변경 : EM에서 데이터베이스 등록정보를 선택, 복구 모델을 단순 또는 대량 로그로 임시 변경해준다.
- ALTER TABLE ... 로 관련 테이블의 PK 제거하기. 그러나, FK 관계에 있을 경우에도 제거를 해야 하므로 EM 또는 VS 의 DB 다이어그램에서 삭제하는게 제일 간편하다. 단. 복구는 수동 -_-;
- DROP INDEX ...로 관련 테이블의 인덱스 제거하기. 그러나, 다시 복구해야 하므로... 수작업 필수
- BULK INSERT : DB 스트레스 테스트를 위해 백만건 이상의 데이터를 넣어야 할 때 사용하면 간편하다. 단 샘플 데이터 파일을 제공해줘야 한다.
- INSERT INTO xxx () SELECT ...로 자기 자신 혹은 관련 테이블을 활용할 것. while + insert 1 보다 훨씬 빠르다. 테스트해본 결과 한줄씩 insert 할 경우 10만건에 40초, 그러나 위의 방법을 쓰면 2초로 해결 가능. 단, 용량이 너무 커질 경우 실행이 안되므로, 범위를 나눠야 할 듯. 300만건에서는 대충 됨.
- PK/FK/Index/Trigger 복구하기. 800만건이 들어있는 테이블의 PK 를 복구하는데 Xeon Dual 0.8G 에서 무려 '''5분'''이나 걸렸다.
</code></pre>
<p>ALTER TABLE xxx ADD CONSTRAINT PK_xxx_yyy PRIMARY KEY(yyy)<br />
ALTER TABLE xxx ADD CONSTRAINT FK_xxx_yyy FORENGN KEY REFERENCES zzz(yyy) ON DELETE CASCADE<br />
CREATE [UNIQUE] INDEX IX_xxx_yyy ON xxx(yyy)</p>
<h2>데드락 해결하기</h2>
<p>sp_who2<br />
sp_lock pid<br />
KILL pid</p>
<h2>like 와 인덱스</h2>
<pre><code>- col like 'userid%'
- col like '%userid%'
- col like '%userid'
</code></pre>
<p>오직 1번만이 인덱스를 타게 된다. Index는 Binary Tree로 구성되어 있기 때문에 처음부터 찾아서 들어가는 것임. 당연히 첫자를 알 수 없다면 index를 경유하지 못함!!!</p>
<h2>Update Trigger</h2>
<p>특정 컬럼이 변경된 경우 로그 테이블에 row 를 추가해야할 경우 Update Trigger 를 사용하면 간편하다. 가령, 플레이어 레벨이 바뀌었을 때 레벨 테이블에 insert 를 해야 한다고 가정하면 트리거는 대략 다음과 같다.</p>
<p>CREATE TRIGGER trigger_name ON src_tbl FOR UPDATE<br />
AS<br />
IF UPDATE(level)<br />
begin<br />
declare @old_level smallint, @new_level smallint<br />
SELECT @new_level = [Level] FROM inserted<br />
SELECT @old_level = [Level] FROM deleted<br />
IF @old_level &lt;&gt; @new_level<br />
begin<br />
INSERT INTO log_tbl (....) VALUES (...,@old_level,@new_level,...)<br />
end<br />
RETURN<br />
end</p>
<h2>@@IDENTITY vs. SCOPE_IDENTITY()</h2>
<p>전자의 경우, 현재 세션에서의 최종적인 IDENTITY 컬럼의 값을 리턴해준다. 단, 트리거에 의해서 다른 테이블에서 IDENTITY 가 바뀐 경우 그 값을 리턴해준다. 따라서, 최종적으로 직접 만진 테이블의 IDENTITY 값을 알아오려면 SCOPE_IDENTITY() 를 사용하는 것이 안전하다.</p>
<h2>UPDLOCK</h2>
<p>쿼리 분석기에서 좌측 쿼리를 먼저 실행한 후 우측 쿼리를 실행할 때, 첫번째 예제의 경우 그냥 실행이 되지만 두번째 예제는 block 된다. 오라클에는 select for update 라는 게 있다나...<br />
<table><br />
<tr><br />
<td>nonblocked query</td><br />
</tr><br />
<tr><br />
<td>begin trans</td><br />
<td rowspan="2">select * from users</td><br />
</tr><br />
<tr><br />
<td>select * from users with (updlock)</td><br />
</tr><br />
<tr><br />
<td>blocked query</td><br />
</tr><br />
<tr><br />
<td>begin trans</td><br />
<td rowspan="2">select * from users with (updlock)</td><br />
</tr><br />
<tr><br />
<td>select * from users with (updlock)</td><br />
</tr><br />
</table><br />
DB레벨에서 중복로그인을 처리할 경우, DB 컬럼에 LogOn flag 를 둬야 한다. LOGOFF - LOGON - GAME 이런 식의 상태 변화가 있다고 가정하면, 로그인시 LOGOFF -&gt; LOGON 으로 바꿔주고 로그아웃시 LOGON -&gt; LOGOFF 로 설정하게 될 것이다. 문제는 이걸 언제 어떻게 체크해서 바꾸느냐인데...</p>
<p>-- simplified login procedure<br />
declare @logon<br />
SELECT @logon=LogOn FROM users WHERE ...<br />
IF ( @logon &lt;&gt; LOGOFF )<br />
begin<br />
handle_error...<br />
end<br />
UPDATE users SET @logon = LOGON WHERE ...</p>
<p>이런 식으로 처리할 경우, abuser 에 의해서 동일 유저에 대한 로그온 프로시저가 DB에서 동시에 일어난다고 가정하면 중복로그인이 충분히 발생할 수 있게 된다. (아주 낮은 확률이지만...) 이를 손쉽게 막으려면 select with updlock를 사용하면 된다. (단, 이때 (Page,IU), (KEY,U), (Table,IX) 의 3가지의 락이 걸린다)</p>
<p>웬지 불필요한 lock 을 피하기 위해서는, update 의 where 절에서 다시 한번 LogOn 필드를 체크(즉 select 해온 뒤 누가 바꿨는지 다시 확인) 해주면 될 거 같다.</p>
<p>-- simplified login procedure<br />
declare @logon<br />
SELECT @logon=LogOn FROM users WHERE ...<br />
IF ( @logon &lt;&gt; LOGOFF )<br />
begin<br />
handle_error...<br />
end<br />
UPDATE users SET @logon = LOGON WHERE ... AND logon = LOGOFF<br />
IF ( @@rowcount &lt;&gt; 1 )<br />
begin<br />
handle_error...<br />
end</p>
<p>테스트 해 본 결과 양 쪽에서 select 한 후 한쪽에서 update 를 하면, 다른 쪽의 update 는 트랜잭션에 의해 block 되며 상대 트랜잭션이 끝나면 실패를 리턴하게 된다. (만약 where 절의 체크가 없다면 둘 다 로그인 성공으로 간주되므로 주의할 것)<br />
<code>이게 consistent non-blocking read을 지원하기 때문인데, 간혹 조금 이해하기 힘든 현상이 일어날 때도 있지. 하지만 Query 하나 들어갈때마다 table에 lock을 걸어버리는 방법은 너무 위험부담이 크기 때문에. consistent read에 대한 설명이 필요하다면 다음 기회에..</code></p>
<h2>sp_lock, sp_who2</h2>
<pre><code>- sp_lock : 현재 시스템에 존재하는 lock 을 보여준다.
- sp_who2 : 현재 시스템에서 실행되는 프로세스, 소유주, 접속지, 실행내용 등을 보여준다.
</code></pre>
<p>이 내용은 Enterprise Manager 의 관리에서 찾아볼 수 있다.</p>
<h2>GOTO</h2>
<p>어릴 적(?)부터 항상 GOTO 는 쓰지 말라는 이야기를 들어 왔지만, 프로시저에서 또 쓰게 될 줄은... 그러나, 트랜잭션이 존재할 경우 GOTO 를 쓰지 않으면 자꾸 if-else-if-else 로 indent 해들어가는 바람에 읽기가 힘들어져서...</p>
<p>begin transaction<br />
....<br />
....<br />
IF ( error_found )<br />
begin<br />
rollback transaction<br />
SET @errorcode = -1<br />
goto Label<br />
end<br />
....<br />
....<br />
commit transaction<br />
....<br />
....<br />
Label:<br />
log something...<br />
....<br />
....</p>
<h2>SET IDENTITY_INSERT</h2>
<p>identity 컬럼의 경우 DELETE FROM tbl 하더라도 시드값은 계속 증가하게 되어 있다. 또한, 특정 값을 명시적으로 insert 할 수 없다. 이를 가능하게 하기 위해서는 아래와 같이 하면 된다.</p>
<p>SET identity_insert tbl ON<br />
INSERT INTO tbl (identity_col,...) VALUES (N,...)<br />
SET identity_insert tbl off</p>
<h2>@@ERROR / @@ROWCOUNT</h2>
<p>프로시저 중간에 insert 나 update 할 경우 혹시 모를 실패에 대비해서 아래와 같이 체크해야 한다.</p>
<p>INSERT ...<br />
IF @@error &lt;&gt; 0<br />
begin<br />
rollback transaction<br />
RETURN<br />
end</p>
<p>update 의 경우 1개의 업데이트만 기대했는데, 2개가 업데이트된 경우 @@ERROR는 정상이 된다. 이때에는 @@ROWCOUNT 를 체크해야 한다.</p>
<h2>시간 필드의 디폴트값</h2>
<p>insert 시점의 시간을 저장하는 필드의 경우, 테이블 선언시</p>
<p>CREATE TABLE xxx<br />
...<br />
yyy DATETIME DEFAULT GETDATE()<br />
...</p>
<p>라고 해주면 insert 할때 굳이 명시할 필요가 없다.</p>
<h2>현재 시간 + a</h2>
<p>dateadd( datepart, N, getdate() )</p>
<h2>스크립트 디버깅</h2>
<p>exec sp_sdidebug 'legacy_on'</p>
<h2>시간 변환</h2>
<p>convert(varchar(10),getdate(),121)</p>
<h2>프로시저 실행시 파라미터</h2>
<p>out 을 명시해주지 않으면 받아낼 수 없다</p>
<p>execute proc @param1, @param2, @param3 out, @param4 out</p></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/26/spread/">Spread</a> <small>2006-04-26</small></h1>
	</div>
	<div><h1>개요</h1>
<p><a href="http://www.spread.org">Spread</a>는 그룹 기반의 UDP 메시징 라이브러리로, unicast &amp; multicast 및 scattered send/receive를 지원한다. 단 PeerToPeer 모델이 아니라, 독립적인 어플리케이션인 Spread 데몬이 가운데에서 중계를 해주는, 일종의 메시지 버스의 역할을 한다. RakNet 과 마찬가지로 다양한 UDP 전송 방식을 지원한다.</p>
<table>
<thead>
<tr>
<th>전송방식</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unreliable</td>
<td>least</td>
</tr>
<tr>
<td>Reliable</td>
<td>will get there, no ordering</td>
</tr>
<tr>
<td>Fifo</td>
<td>reliable and ordered fifo by source</td>
</tr>
<tr>
<td>Causal</td>
<td>reliable and all mesg from any source of this  level are causally ordered</td>
</tr>
<tr>
<td>Agreed</td>
<td>reliable and all mesg from any source of this level are totally ordered</td>
</tr>
<tr>
<td>Safe</td>
<td>Agreed ordering and mesg will not be delivered to application until the mesg has reached ALL receipients' daemons</td>
</tr>
</tbody>
</table>
<h1>성능</h1>
<p>문서에 의하면 1k 메시지 8000개를 1초에 전송 보장한다고 하며, 또한, <a href="http://www.cnds.jhu.edu/pub/papers/cnds-2004-1.pdf">The Spread Toolkit: Architecture and Performance</a>에 따르면 만개의 그룹에서 Safe 메시지를 보낼 때의 지연 시간이 6ms 라고 나온다. 실제로, 파이썬 바인딩을 이용한 클라이언트와 (아무런 부하를 주지 않은) localhost 데몬과의 테스트 결과 0.25ms 정도의 반응 시간을 보여줬다.</p>
<table>
<thead>
<tr>
<th>전송방식</th>
<th>평균 ping 시간</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNRELIABLE_MESS</td>
<td>0.248ms</td>
</tr>
<tr>
<td>RELIABLE_MESS</td>
<td>0.248ms</td>
</tr>
<tr>
<td>FIFO_MESS</td>
<td>0.247ms</td>
</tr>
<tr>
<td>CAUSAL_MESS</td>
<td>0.247ms</td>
</tr>
<tr>
<td>AGREED_MESS</td>
<td>0.247ms</td>
</tr>
<tr>
<td>SAFE_MESS</td>
<td>0.248ms</td>
</tr>
</tbody>
</table>
<p>로컬랜에 연결된 2개의 머신에서 한쪽(Windows XP, P4 2G + 512M)에 데몬을 real time priority 로 띄우고 다른 쪽에 송수신 전용 쓰레드를 가진 테스트 클라이언트를 붙인 다음, 초당 8000개의 4byte 메시지를 보내는 경우 CPU 사용량 100% 에 RTT 0.8s 가 나왔다. 즉 1초 안에 전송은 보장하지만 반응 속도는 영 좋지 않았다. 그리고 로컬랜의 방화벽 바깥에 있는 머신(Windows 2003 + P4 2.8G + RAM 2G)에 데몬을 띄우고 방화벽 안쪽에서 테스트한 결과, 초당 4000개를 보내면 연결이 끊기며 초당 1000개를 보내면 0.8s 의 반응 속도를 보여줬다.</p>
<h1>예상되는 용도</h1>
<dl>
<dt>컨텐트 중계 서버</dt>
<dd>채팅 채널, 파티 채팅, 길드 채팅을 중계해주는 서버. 굳이 채팅 서버를 두지 않아도 무방할 듯. 그 역할을 Spread Daemon 이 해주니까.</dd>
<dt>게이트웨이 서버</dt>
<dd>M:N 관계에 있는 tier 에서의 중계 서버 역할. 가령 N개의 에이전트와 M개의 게임서버간의 연결을 TCP로 하게 되면 각 에이전트는 M개의 TCP연결을 하고 그것을 관리해야 한다. 이를 1개의 Spread 연결로 해결할 수 있다. (M개의 그룹에 대해 1개의 연결을 사용한다는 가정 하에서...) 마찬가지로 게임서버는 1개의 Spread 연결에 대해서만 처리하게 되므로 이벤트 드리븐이 간단하게 이루어진다. 가령 클라이언트가 에이전트에 로그인하고 이전 위치를 로딩하게 되면, 에이전트는 해당 서버 그룹에 join 하고, 클라이언트가 로그아웃하면 그룹에서 leave 하면 된다. (ref-counting을 사용하면 간단) 서버간 이동도 마찬가지로 처리할 수 있다. 단 이렇게 될 경우 데몬이 다운되면 게임 끝이다.</dd>
<dt>브로드캐스트 서버</dt>
<dd>(현실성이 없는 이야기지만) 게임 서버의 각 브로드캐스트 영역(일명 Area)을 그룹으로 간주하고, 그 안에 들어있는 플레이어들에게 멀티캐스팅할 수 있겠다. 단 이런 모델은 잦은 그룹 join/leave 가 이루어지므로 Area 개수가 늘어날수록 부하가 심해질 듯. 1000개의 그룹일 경우 35ms 정도니까... 10000개면...</dd>
<dt>데이터 복제 서버</dt>
<dd>게임 서버의 경계 영역에서의 데이터 변화를, 이를 공유하는 다른 서버로 복제한다. 예를 들면, NPC 길찾기를 위한 동적 객체 정보를 게임 서버에서 NPC 에이전트로 복제하는 등.</dd>
</dl>
<h1>참고사항</h1>
<p>경험자의 말에 의하면, windows xp 와의 궁합이 잘 맞지 않다고 한다. 대신 windows 2000 에서는 잘 된다고 하는데, 커널의 네트워크 모듈과의 궁합 문제일 가능성이 있다고 한다. 즉 windows 2003 에서 테스트를 더 해봐야 한다는 의미.</p>
<p>see also:</p>
<ul>
<li><a href="http://www.spread.org/docs/guide/users_guide.pdf">Spread User Guide</a></li>
<li><a href="http://www.zope.org/Members/tim_one/spread/">Python Spread</a></li>
<li><a href="http://www3.telus.net/taj_khattra/luaspread.html">Lua Spread</a></li>
</ul>
<!--more-->

<pre><code>
#format python
import spread
import unittest
import time

daemon = '3333@localhost'

class SpreadTest(unittest.TestCase):
  def testConnect(self):
  mbox = spread.connect(daemon,'test1')
  self.failUnless( mbox.fileno &gt; 0 )
  mbox.disconnect()
  def testJoin(self):
  mbox = spread.connect(daemon,'test2')
  mbox.join('test1')
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( str(type(msg)) , &quot;&quot; )
  self.failUnlessEqual( msg.group , &quot;test1&quot; )
  self.failUnlessEqual( msg.reason, spread.CAUSED_BY_JOIN )
  mbox.leave('test1')
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( str(type(msg)) , &quot;&quot; )
  self.failUnlessEqual( msg.group , &quot;test1&quot; )
  self.failUnlessEqual( msg.reason, spread.CAUSED_BY_LEAVE )
  mbox.disconnect()
  def testLeave(self):
  mbox = spread.connect(daemon,'test2')
  mbox.join('test1')
  mbox.leave('test2')
  mbox.disconnect()
  def testSend(self):
  mbox = spread.connect(daemon,'test3')
  group = 'StressTesters'
  message = 'Hello Spread!'
  mbox.join(group)
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( msg.reason, spread.CAUSED_BY_JOIN )
  mbox.multicast( spread.FIFO_MESS, group, message)
  if mbox.poll() &gt; 0:
  msg = mbox.receive()
  self.failUnlessEqual( msg.groups[0], group )
  self.failUnlessEqual( msg.message, message )
  mbox.leave(group)
  mbox.disconnect()

def testPing( trycount = 100 ):
  mbox = spread.connect(daemon,'StressTester')
  group = 'StressTesters'
  mbox.join(group)
  msg = mbox.receive()
  assert msg.reason == spread.CAUSED_BY_JOIN

  service_types = (
  spread.UNRELIABLE_MESS,
  spread.RELIABLE_MESS,
  spread.FIFO_MESS,
  spread.CAUSAL_MESS,
  spread.AGREED_MESS,
  spread.SAFE_MESS )
  service_type_str = (
  'UNRELIABLE_MESS',
  'RELIABLE_MESS',
  'FIFO_MESS',
  'CAUSAL_MESS',
  'AGREED_MESS',
  'SAFE_MESS' )
  ping_stat = []

  for service_type in service_types:
  ping_count = 0
  total_ping = 0
  for i in range(0,trycount):
  mbox.multicast( service_type, group, str(time.clock()) )
  msg = mbox.receive()
  total_ping = total_ping + time.clock() - float( msg.message )
  ping_count = ping_count + 1

  if ping_count &gt; 0 :
  ping_stat.append( total_ping / ping_count )
  else:
  ping_stat.append(0)

  for i in range( 0, len(service_type_str) ):
  print &quot;%15s : %8f&quot; %( service_type_str[i],ping_stat[i])

  mbox.leave(group)
  msg = mbox.receive()
  assert msg.reason == spread.CAUSED_BY_LEAVE

  mbox.disconnect()
if __name__ == '__main__':
  testPing(10000)
  #unittest.main()
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/26/python-tips/">Python Tips</a> <small>2006-04-26</small></h1>
	</div>
	<div><h3># asyncore.dispatcher</h3>
<pre><code>- 원래부터 nonblocking 이다.
- set_socket 하는 시점에 map 에 등록된다.
</code></pre>
<h3># StringIO.readline()</h3>
<p>StringIO 는 file-like 객체이므로 readline() 을 지원한다. 그러나 write() 한 후 읽어들이면 None 을 리턴한다. 내부적으로 유지하는 offset 이 하나이기 때문인데, 만약 사용하려면 offset(0) 을 호출해서 포인터를 맨 앞으로 돌려줘야 한다. (너무 단순한가?)</p>
<h3># zipfile</h3>
<p>zip 포맷으로 특정 폴더를 압축하기 위해서는 다음과 같이 해야 한다. 이때 압축 포맷으로 ZIP_DEFLATED 를 사용해야 파일 크기가 작아진다.</p>
<pre><code>
def zipdir(zfile,dir,base='.'):
&quot;&quot;&quot;zip directory recursively&quot;&quot;&quot;
print '\nzip %s'%dir,

global log
log.write('zip %s...'%dir)

for f in os.listdir(dir):
nf = os.path.join(dir,f)
if os.path.isdir(nf):
zipdir(zfile,nf,os.path.basename(dir))
else:
print '.',
zfile.write(nf,
os.path.join( base, os.path.basename(dir), f),
zipfile.ZIP_DEFLATED)
</code></pre>

<h3># dict(zip(seq1,seq2))</h3>
<p>keys와 values를 dict로 매치시킬 때 dict()와 zip()을 사용할 수 있다.</p>
<pre><code>
&gt;&gt;&gt; keys = [ 'aaa', 'bbb', 'ccc' ]
&gt;&gt;&gt; values = [ 1, 2, 3 ]
&gt;&gt;&gt; zip(keys,values)
[('aaa', 1), ('bbb', 2), ('ccc', 3)]
&gt;&gt;&gt; dict(zip(keys,values))
{'aaa': 1, 'bbb': 2, 'ccc': 3}
</code></pre>

<h3># re.findall</h3>
<p>스트링에서 특정 seperator 로 구분된 패턴으로 자를 때, string.split() 도 좋지만 re.findall() 을 강추</p>
<pre><code>
&gt;&gt;&gt; args = '&quot;SELECT * FROM User&quot;,&quot;aaa,bbb,ccc,ddd&quot;'
&gt;&gt;&gt; args.split('&quot;')
['', 'SELECT * FROM User', ',', 'aaa,bbb,ccc,ddd', '']
&gt;&gt;&gt; re.findall('&quot;(.+?)&quot;',args)
['SELECT * FROM User', 'aaa,bbb,ccc,ddd']
</code></pre>

<h3># re 를 이용한 파일명 변경</h3>
<p>특정 폴더 안에 여러가지 파일명들을 바꾸기 위해서는 re 모듈을 잘 사용해야 한다. 다음은 파일명에 {{{[...]}}} 을 없엘 때 쓰는 스크립트이다.</p>
<pre><code>
import os, re
os.chdir(target_folder)
for old_name in os.listdir('.'):
new_name = re.sub('\[.+\]','',old_name)
os.rename(old_name,new_name)
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/26/funny-memory-values/">Funny Memory Values</a> <small>2006-04-26</small></h1>
	</div>
	<div><p>from <a href="http://www.samblackburn.com/wfc/technotes/WTN006.htm">WFC Technical Note 006 - Funny Memory Values</a></p>
<p>윈도우 환경에서 디버깅을 하다 보면 0XCDCD 라든지 0XDDDD 같은 특이한 값들을 만날 수 있는데, 이게 그냥 가비지가 아니라 각각마다 특유의 의미를 가지고 있었다. 가령 0xDDDD는 이미 지워진 포인터라든지 0xFDFD는 힙에 할당한 값의 앞뒤에 위치하는 경계값이라든지 말이다.</p>
<p>한글로 된 설명은 <a href="http://codian.net/wp/archives/352">요기</a>와 <a href="http://www.trozan.net/blog/tag/%B5%F0%B9%F6%B1%D7">요기</a>가 제일 잘 되어 있으니 참고하시길.</p></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/04/25/udt-udp-based-data-transfer-library/">UDT : UDP-based Data Transfer Library</a> <small>2006-04-25</small></h1>
	</div>
	<div><p><a href="http://udt.sf.net">UDT</a>는 Internet2 혹은 기가비트 이더넷과 같이 빠른 네트워크에서 수십~수백 기가 바이트의 대용량 데이터를 전송할 때 TCP가 매우 느리다는 점때문에 시작된 오픈소스 프로젝트이다. 버클리 소켓 API를 그대로 유지하고 있어서 접근성이 좋고, TCP의 슬라이딩 윈도우 같은 Congestion Control 을 사용자가 상황에 맞게 조정할 수 있다는 장점이 있다. 2.0 버전까지는 UDP 스트림만을 지원했는데 3.0부터는 UDP 다이어그램과 중첩입출력(Overlapped)도 지원하기 시작했다. 현재 3.0 beta 가 나와 있는 상태이다.</p>
<p>이번에 reliable UDP 라이브러리 조사 도중 탐지망에 걸려 들어서 검토한 결과, 하나의 소켓에 대해서 내부적으로 입력과 출력 쓰레드를 1개씩 사용하는 것을 발견했다. 원래부터 데이터 전송을 목적으로 구현되어서 그런 듯한데, 이를 수정하지 않고는 게임 서버에서 사용하기는 힘들다는 판단을 내렸다. 시간이 난다면 IOCP를 연동할 수 있게 살짝 고쳐 보고 싶지만, 누구 말마따나 게임 회사는 연구소가 아닌 관계로... OTL</p>
<p>결국 다시 RakNet으로 가야 된단 말인가...</p></div>
	
</article>
			
			<ul class="pager">
			
			  	<li class="previous">
			    	<a href="/page/33/">&larr; Older</a>
			  	</li>
		  	
		  	
				<li class="next">
					<a href="/page/33">Newer &rarr;</a>
				</li>
		  	
			</ul>
		</div>
		<div class="span3">
			<ul class="nav nav-list well">
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2006/04/26/sql-tips/">SQL Tips</a>
	</li>
	
	<li>
		<a href="/2006/04/26/spread/">Spread</a>
	</li>
	
	<li>
		<a href="/2006/04/26/python-tips/">Python Tips</a>
	</li>
	
	<li>
		<a href="/2006/04/26/funny-memory-values/">Funny Memory Values</a>
	</li>
	
	<li>
		<a href="/2006/04/25/udt-udp-based-data-transfer-library/">UDT : UDP-based Data Transfer Library</a>
	</li>
	
</ul>
		</div>
	</div>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
	

  </body>
</html>