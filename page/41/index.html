
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Social Reiot</title>
  <meta name="author" content="Ray Yun">

  
  <meta name="description" content="multiple result set + parameter binding- 캐릭터 정보 로딩과 같이, 하나의 프로시저에서 여러 테이블의 row 들을 select 하면서 파라미터도 바인딩해야 할 경우, static binding 으로는 구현할 수 없으며, CDynam...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://reiot.com/page/41/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://s3.amazonaws.com/ender-js/jeesh.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Social Reiot" type="application/atom+xml">
  <!--Fonts from Google's Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>

</head>

<body  >
  <header role="banner"><hgroup>
  <h1><a href="/">Social Reiot</a></h1>
  
    <h2>Social Game Developer wandering in strange dungeon.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:reiot.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul role=main-navigation>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/06/05/ole-db-tips/">OLE DB Tips</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-06-05T06:30:16+09:00" pubdate  data-updated="true" >Jun 5<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>multiple result set + parameter binding</h2>

<pre><code>- 캐릭터 정보 로딩과 같이, 하나의 프로시저에서 여러 테이블의 row 들을 select 하면서 파라미터도 바인딩해야 할 경우, static binding 으로는 구현할 수 없으며, CDynamicParameterAccessor::GetParam()를 이용해야 한다.
- 파라미터의 경우, select 해온 모든 result set 을 소진한 후, 가장 마지막에 읽어와야 한다. 즉 DB_S_NORESULT == GetNextResult(...); 를 실행한 후에만 유효하다는 뜻이다. 만약, 그 전에 읽게 되면 garbage 가 리턴된다.
- Bind()와 무관하므로, GetInterface()!=NULL 체크를 할 필요가 없다.
</code></pre>

<h2>CCommand::Prepare()</h2>

<p>한번 생성후 재사용하는 구조가 필요하다.</p>

<h2>GetNextResult(rowCount)</h2>

<p>웬지 계속 -1 이 넘어오는 걸로 봐서 뭔가 문제가 있는 듯? property 설정이 필요한가?</p>

<h2>DateTime to String</h2>

<pre><code>- VarBstrFromDate 이걸 써야 될까나~
- use
</code></pre>

<p>HRESULT DataConvert (
DBTYPE          wSrcType,
DBTYPE          wDstType,
DBLENGTH        cbSrcLength,
DBLENGTH <em>      pcbDstLength,
void </em>          pSrc,
void <em>          pDst,
DBLENGTH        cbDstMaxLength,
DBSTATUS        dbsSrcStatus,
DBSTATUS </em>      pdbsStatus,
BYTE            bPrecision,
BYTE            bScale,
DBDATACONVERT   dwFlags);</p>

<h2>Connection Pooling</h2>

<pre><code>- SqlServer Provider 를 기반으로, ThreadPooling 을 이용해 쿼리를 할 경우, DataSource 가 1개이고 Session 이 N 개를 생성했다면, 실제 DB에 대한 연결은 N 개가 된다.
- 즉, Session 이 내부적으로 연결 풀링을 사용하게 되므로, DataSource 객체는 1개만 만들어도 된다.
</code></pre>

<h2>어떤 Accessor 를 사용할 것인가?</h2>

<p>MSDN 의 비교표를 간략하게 요약하면 다음과 같다.</p>

<pre><code>- CAccessor : 매크로를 이용한 컴파일 타임 바인딩이므로 성능 면에서 가장 우수하지만, 쉽게 말해서 하드코딩이므로 귀찮은 작업들이 많다. 컬럼 및 파라미터 바인딩 모두 지원.
- CDynamicAccessor : 런타임 바인딩. 따라서 컬럼 정보를 읽어와야한다. 대신 파라미터 바인딩은 불가능. 뭔가 컴파일 타임에 정보를 알기 힘든 경우, 또는 multiple result set 을 리턴하는 프로시저에 사용하면 된다.
- CDynamicParameterAccessor : CDynamicAccessor 에 파라미터 바인딩 기능이 추가되었다. 당연히 더욱 느려졌다.
- CDynamicStringAccessor : CDynamicAccessor 와 유사하지만 컬럼값을 스트링으로 리턴한다.
- CManualAccessor : AddBindEntry(), AddParameterEntry() 를 이용해서 수동으로 컬럼과 파라미터를 바인딩한다. 아마 CAccessor 에 이어 두번째로 빠른 듯.
- CXMLAccessor : CDynamicStringAccessor 와 같지만, XML 스트링의 형태로 컬럼값을 리턴한다.
</code></pre>

<p>성능적인 순서로 정렬해 본다면 대충 다음과 같지 않을까? (이건 본인의 추측)</p>

<pre><code>- CAccessor &lt; CManualAccessor &lt; CDynamicAccessor &lt; CDynamicStringAccessor &lt; CXMLAccessor &lt; CDynamicParameterAccessor
</code></pre>

<p>단, 파라미터 바인딩을 지원하는 넘은 아래의 3가지 뿐이다.</p>

<pre><code>- CAccessor
- CManualAccessor
- CDynamicParameterAccessor
</code></pre>

<p>see also</p>

<pre><code>- [Which accessor should I use?](http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccore/html/vcfaqwhichaccessorshouldiuse.asp) from MSDN
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/06/05/%E1%84%8B%E1%85%B1%E1%86%AB%E1%84%83%E1%85%A9%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%B3%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-ip-%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A2%E1%86%A8-%E1%84%89%E1%85%A5%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5/">윈도우즈에서 IP 보안 정책 설정하기</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-06-05T06:20:08+09:00" pubdate  data-updated="true" >Jun 5<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>XP 부터 소프트웨어 방화벽을 지원하지만, TCP/UDP에 대해 특정 포트를 On/Off 시키는 정도의 제어만 가능하다. 그러나 Windows 서버 2003 부터는 - 리눅스에서는 오래전부터 지원했던 - IpSec 을 지원한다. 이는 관리도구 - 로컬보안정책 - IP보안정책 에서 설정할 수 있다.</p>

<p><em>그러나 가장 좋은 것은 뭐니뭐니해도 하드웨어 방화벽이다</em>. :)</p>

<h2>보안 정책</h2>

<p>보안 정책은 {IP 필터:필터 동작}의 매핑으로 이루어진다.</p>

<ul>
<li>IP 필터 - {src_ip,dest_ip,protocol,port,&#8230;} 으로 구성된다.</li>
<li>필터 동작 - 위 IP 필터에 의해 걸러진 트래픽을 허용/보안요청/보안필요/거부할 것인지를 결정한다.</li>
</ul>


<p>기본적으로 3가지의 보안 정책이 존재한다. 단 OS 설치 초기에는 모든 정책이 꺼져 있다.</p>

<ul>
<li>서버(보안요청)</li>
<li>클라이언트(응답만)</li>
<li>보안 서버(보안필요)</li>
</ul>


<p>따라서, 우리는 새로운 커스텀 보안정책을 생성한 후 아래와 같이 필터와 동작들을 추가해야 한다.</p>

<ul>
<li>터미널 서비스 : 회사의 개발용 머신, IDC의 다른 컴퓨터들에서만 허용</li>
<li>MSSQL : IDC의 다른 컴퓨터에서만 허용</li>
<li>WWW : 방화벽 없슴</li>
</ul>


<h2>IP필터</h2>

<h3>터미널 서비스</h3>

<p>터미널 서비스는 TCP 3389 포트를 사용한다. 따라서, 기본적으로 터미널 서비스를 거부한 다음, 접근을 허용하고 싶은 컴퓨터의 IP만 지정해주면 간단하다. OS 방화벽을 함께 사용한 경우, TCP 3389 포트를 열어주는 것을 잊지 말자.</p>

<p>반면, 특정 subnet에서만 터미널 서비스를 허용하려면 , 해당 subnet 이 시작하는 주소를 잘 지정해야 한다. 하긴 mask 만 잘 지정하면 적당한 대역의 IP를 넣으면 알아서 변환이 되니깐 별 관계는 없다만&#8230;</p>

<table>
<thead>
<tr>
<th></th>
<th>정책</th>
<th>프로토콜</th>
<th>원본주소</th>
<th>원본포트</th>
<th>대상주소</th>
<th>대상포트</th>
<th>필터동작</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>모든 터미널 서비스 거부</td>
<td>TCP</td>
<td>any</td>
<td>any</td>
<td>서버의 IP</td>
<td>3389</td>
<td>거부|</td>
</tr>
<tr>
<td></td>
<td>특정 컴퓨터의 터미널 서비스 허용</td>
<td>TCP</td>
<td>특정 컴퓨터 - IP 또는 DNS</td>
<td>any</td>
<td>서버의 IP</td>
<td>3389</td>
<td>허용|</td>
</tr>
<tr>
<td></td>
<td>특정 서브넷의 터미널 서비스 허용</td>
<td>TCP</td>
<td>특정 subnet- 시작 IP / subnet mask </td>
<td>any </td>
<td>서버의 IP </td>
<td>3389 </td>
<td>허용 |</td>
</tr>
</tbody>
</table>


<h3>SqlServer 에 대한 외부 접근 제어</h3>

<p>SqlServer 는 TCP 1433, UDP 1433 포트를 사용한다. OS 방화벽을 함께 사용한 경우, 각 포트들을 열어주는 것을 잊지 말자. TCP/UDP에 대한 거부 필터를 2개 만들어서 추가한 뒤, 접근을 허용하고 싶은 서버를 허용 필터로 추가하면 된다. (보안의 기본적인 컨셉은 모두 막은 뒤 하나씩 풀어주는 것..이라고 누가 말했던가..)</p>

<table>
<thead>
<tr>
<th></th>
<th>정책</th>
<th>프로토콜</th>
<th>원본주소</th>
<th>원본포트</th>
<th>대상주소</th>
<th>대상포트</th>
<th>필터동작</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>SqlServer 외부 접근 거부</td>
<td> TCP/UDP 각각 </td>
<td>any </td>
<td>any </td>
<td>서버의 IP </td>
<td>1433 </td>
<td>거부 |</td>
</tr>
<tr>
<td></td>
<td>SqlServer 특정 서버 허용</td>
<td> TCP/UDP 각각 </td>
<td>특정 서버의 IP 또는 DNS </td>
<td>any </td>
<td>서버의 IP </td>
<td>1433 </td>
<td>허용 |</td>
</tr>
</tbody>
</table>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/06/02/stl-tips/">STL Tips</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-06-02T07:43:56+09:00" pubdate  data-updated="true" >Jun 2<span>nd</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p></p></blockquote>


<blockquote><p>***이 페이지는 더이상 업데이트되지 않으며, 최신 버전은 http://reiot.springnote.com/pages/87168에서 보실 수 있습니다.***</p></blockquote>


<blockquote><p></p></blockquote>


<h2>dll + STL</h2>

<p>dll 에서 hash_set 을 멤버로 가진 클래스를 만들려다가 nested class 인 _Hash 라든지 hash_compare 등등을 모두 dllexport 하라길래 포기하고 PIMPL 패턴으로 해결해야만 했다.</p>

<pre><code>- [How To Exporting STL Components Inside &amp; Outside of a Class](http://support.microsoft.com/default.aspx?scid=kb;EN-US;168958)
</code></pre>

<h2>boost::lambda</h2>

<p>아래의 mem_fun_if 류와 비슷한 역할을 하는 것이 바로 boost::lambda 라이브러리다. 일단 아래처럼 포인터 컨테이너를 순회하면서 NOT NULL 일 경우에 특정 멤버 함수를 호출하는 예제를 살펴보자.</p>

<blockquote><p>for_each( l.begin(), l.end(),<br/>if_then( _1 != constant((A*)NULL), bind( &A::print, _1 ) ) );</p></blockquote>


<p>lambda 라이브러리를 사용하면 위와 같이 간단한 코드로 표현이 가능하다. 대신 컴파일 속도는&#8230; ㅠㅠ</p>

<h2>mem_fun_if</h2>

<p>일반적으로 포인터 컨테이너를 순회하면서 특정 조건을 만족할 경우 멤버 함수를 호출하는 패턴을 위한 자작 adapter function 이다. (물론 const 버전과 파라미터 1개를 받는 버전, 합쳐서 총 4개의 클래스와 4개의 함수를 만들어야 하지만&#8230; 시간상 생략)</p>

<blockquote><p>template<class _Pred, class _Result, class _Ty><br/>class mem_fun_if_t : public unary_function<_Ty *, _Result><br/>{<br/>public:<br/>  explicit mem_fun_if_t( _Pred pred, _Result (_Ty::*_Pm)())<br/>: _pred(pred), _Pmemfun(_Pm), _count(0)<br/>  {<br/>  }</p><p>  // 단점이라면 멤버함수의 리턴값은&#8230; 도무지 캐치불가능&#8230;<br/>  bool operator()(_Ty *_Pleft) const<br/>  {<br/>  if ( _pred(_Pleft) )<br/>  {<br/>  ((_Pleft->*_Pmemfun)());<br/>_count++;<br/>  return true;<br/>  }<br/>  return false;<br/>  }</p><p>  int count() const { return _count; }</p><p>private:<br/>_Pred _pred;  // predicate<br/>_Result (_Ty::*_Pmemfun)(); // the member function pointer<br/>mutable int _count;<br/>};</p><p>template<class _Pred, class _Result, class _Ty><br/>inline<br/>mem_fun_if_t<_Pred,_Result, _Ty><br/>mem_fun_if(_Pred pred,_Result (_Ty::*_Pm)())<br/>{<br/>  return (mem_fun_if_t<_Pred,_Result, _Ty>(pred,_Pm));<br/>}</p></blockquote>


<p>이를 이용한 샘플이다.</p>

<blockquote><p>using namespace std;</p><p>class A<br/>{<br/>public :<br/>  explicit A( const string & s ): str(s) {}<br/>  void print() { cout <<str <<endl; }<br/>string str;<br/>};</p><p>#define not_null(T) bind2nd( not_equal_to<T*>(), (T*)0)</p><p>int _tmain(int argc, _TCHAR* argv[])<br/>{<br/>list<A*> l;<br/>l.push_back( new A(&#8220;Hello&#8221;) );<br/>l.push_back( NULL );<br/>l.push_back( new A(&#8220;World&#8221;) );<br/>l.push_back( NULL );<br/>l.push_back( new A(&#8220;!&#8221;) );</p><p>for_each( l.begin(), l.end(), mem_fun_if( bind2nd( not_equal_to<A*>(), (A*)0 ), &A::print ) );<br/>for_each( l.begin(), l.end(), mem_fun_if( not_null(A), &A::print ) );</p><p>  return 0;<br/>}</p></blockquote>


<h2>if_not_null</h2>

<p>다음은 포인터 컨테이너에서 NOT NULL 인 갯수를 찾는 코드이다.</p>

<blockquote><p>count_if( l.begin(), l.end(),<br/>bind2nd( not_equal_to<A*>(), (A*)0 ) );</p></blockquote>


<h2>ptr_fun and not1, not2</h2>

<p>ptr_fun 은 말 그대로 pointer to function 이다.</p>

<blockquote><p>template<class Arg, class Result><br/>pointer_to_unary_function<Arg, Result><br/>ptr_fun(Result (_*pfunc)(Arg));</p><p>template<class Arg1, class Arg2, class Result><br/>pointer_to_binary_function<Arg1, Arg2, Result><br/>ptr_fun(Result (_*pfunc)(Arg1, Arg2));</p><p>not1 은 unary_function 의 negate 이며, not2 는 binary_function 의 negate 이다.</p><p> </p><p><br/>template<class UnaryPredicate><br/>unary_negate<UnaryPredicate> not1(<br/>const UnaryPredicate& _Pred<br/>);</p><p>template<class Predicate><br/>class unary_negate<br/>: public unary_function<<br/>typename Predicate::argument_type,<br/>bool><br/>{<br/>public:<br/>explicit unary_negate(<br/>const Predicate& _Func<br/>);<br/>bool operator()(<br/>const typename Predicate::argument_type& _Left ) const;<br/>};</p><p> </p><p><br/>template<class BinaryPredicate><br/>binary_negate<BinaryPredicate> not2(<br/>const BinaryPredicate& _Func<br/>);</p><p>template<class Operation><br/>class binary_negate<br/>: public binary_function <<br/>typename Operation::first_argument_type,<br/>typename Operation::second_argument_type,<br/>bool><br/>{<br/>public:<br/>explicit binary_negate(<br/>const Operation& _Func<br/>);<br/>bool operator()(<br/>const typename Operation::first_argument_type& _Left,<br/>const typename Operation::second_argument_type& _Right<br/>) const;<br/>};</p></blockquote>


<p>그럼 그동안 배운 것을 토대로 다음 MSDN 샘플을 살펴보자.</p>

<p>not1( bind2nd( ptr_fun(strcmp), &#8220;pearly&#8221; ) )</p>

<p>만약 1초만에 strcmp(X,&#8221;pearly&#8221;)==0 임을 인지해 냈다면 당신은 STL의 고수&#8230; ㅠㅠ</p>

<h2>mem_fun vs. mem_fun_ref</h2>

<p>EffectiveSTL 에도 나오는 이야기이니, 책을 가지신 분은 43 아이템을 참고하라.</p>

<p>나를 비롯한 대부분의 프로그래머들은 이런 코드를 사랑한다.</p>

<p>for ( list&lt;GameObject<em>>::iterator itr = gameObjects.begin() ; itr != gameObjects.end() ; itr ++ )
{
GameObject * pObject = </em>itr;
__ASSERT(pObject!=NULL); /// be a paranoid!!!
pObject->Update();
}</p>

<p>너무나도 직관적인 코드이지만, 사실 mem_fun 을 사용하면 한 줄로 해결이 가능하다.</p>

<p>for_each( gameObjects.begin(), gameObject.end(), mem_fun(&amp;GameObject::Update) );</p>

<p>코드는 간단해졌지만 익숙하지 않은 관계로 팀원들이 싫어할 지도 모른다. 그러나, 타이핑하는 글자수도 적으면서 성능도 훨씬 더 좋다는데&#8230; 그 누가 안 쓸수 있으랴? (대신 디버깅할 때에는 멤버함수에다가 breakpoint 를 걸어야 하는 단점이 있을 수도 있다 <img class='' src='http://boxcatstudio.files.wordpress.com/2009/07/icon_wink.gif' width='' height='' alt=';)' title=';)'>  )</p>

<p>포인터의 컨테이너일 경우에는 mem_fun 을, 객체의 컨테이너라면 mem_fun_ref 를 사용하면 된다. 만약 멤버함수에 파라미터를 넘겨야 한다면, 아래와 같이 bind 함수를 사용할 것.</p>

<p>for_each( gameObjects.begin(), gameObject.end(), bind2nd( mem_fun(&amp;GameObject::SetHP),100) );</p>

<h2>bind1st vs. bind2nd</h2>

<p>우선 bind 함수를 알아보기에 앞서, unary_function 과 binary_function 에 대해서 알아보자. 이들은 단지 파라미터와 리턴타입에 대한 typedef 만을 담는 template structure 일 뿐이다. 즉 이들은 혼자서는 아무런 기능도 하지 않지만, 이를 상속받은 하위 클래스에서 타입 정보를 적절히 참조하기 좋도록 디자인된 베이스 클래스라는 뜻이다.</p>

<p>template<class Arg, class Result>
struct unary_function {
typedef Arg argument_type;
typedef Result result_type;
};</p>

<p>template<class Arg1, class Arg2, class Result>
struct binary_function {
typedef Arg1 first_argument_type;
typedef Arg2 second_argument_type;
typedef Result result_type;
};</p>

<p>기본적으로 STL 알고리즘에서 사용되는 Predicate 등의 함수들은 unary_function 의 형태를 띄어야 한다. 쉽게 말하면, find(), for_each(), count() 의 마지막 인자가 해당 컨테이너 내부의 객체 하나만을 인자로 받는 함수 객체라는 뜻이다.</p>

<p>가령 list<int> 에서 10보다 큰 객체를 찾으려면 대략 다음과 같은 predicate 을 작성해야 한다.</p>

<p>class GreaterThan10
{
public :
bool operator() ( int i ) { return i>= 10; }
};</p>

<p>사실 이렇게 짜면 너무 코드가 범용적이지 못하므로, 대부분의 경우에는 이렇게 구현할 것이다.</p>

<p>class GreaterThanN
{
public :
GreaterThenN( int N ) : m_N(N) {}
bool operator() ( int i ) { return i>= m_N; }
private :
int m_N;
};</p>

<p>이걸 STL 적인 생각으로 다시 구현한 것이 바로 bind 함수들이다. bindN(A,B) 은 binary_function A 의 N 번째 파라미터로 parameter B 을 바인딩해서, unary_function 을 만들어주는 놈이다. 얘네들을 잘 활용하면 단순 함수들은 간단히 한줄로 구현할 수 있게 된다.</p>

<pre><code>- bind1st( BINARY_FUNC, PARAM ) : PARAM 을 BINARY_FUNC의 1st 파라미터로 바인딩한다.

- ex&gt; bind1st( greater, 10 ) --&gt; 10 &gt; N

- bind2nd( BINARY_FUNC, PARAM ) : PARAM 을 BINARY_FUNC의 2nd 파라미터로 바인딩한다.

- bind2nd( greater, 10 ) --&gt; N &gt; 10
</code></pre>

<p>bind1st( greater, 10 ) 이 어떻게 10 > N 이라는 함수로 바뀌는지 자세히 살펴본다면&#8230;</p>

<pre><code>- greater는 binary_function 이다.
</code></pre>

<p>template<class Type>
struct greater : public binary_function &lt;Type, Type, bool>
{
bool operator()(
const Type&amp; <em>Left,
const Type&amp; </em>Right
) const;
};</p>

<pre><code>- bind1st(A,B) 는 binder1st 객체를 리턴한다.
</code></pre>

<p>template<class Operation, class Type>
binder1st <Operation> bind1st(
const Operation&amp; <em>Func,
const Type&amp; </em>Left
);</p>

<pre><code>- binder1st&lt;A&gt; 는 A의 두번째 파라미터를 파라미터로 받고, A의 리턴값을 리턴하는 함수 객체이다. 이때 이 클래스의 생성자의 인자 목록을 유심히 살펴보면, binary_function 하나와 이놈의 하나의 파라미터는 받고 있다. (나머지 하나는 당연히 container 에서 받게 된다.)
</code></pre>

<p>template<class Operation>
class binder1st
: public unary_function &lt;
typename Operation::second_argument_type,
typename Operation::result_type>
{
public:
typedef typename Operation::second_argument_type argument_type;
typedef typename Operation::result_type result_type;
binder1st(
const Operation &amp; <em>Func,
const typename Operation::first_argument_type&amp; </em>Left
);
result_type operator()(
const argument_type&amp; <em>Right
);
result_type operator()(
const argument_type&amp; </em>Right
) const;
protected:
Operation op;
typename Operation::first_argument_type value;
};</p>

<h2>SafeDeleter</h2>

<p>템플릿 클래스 버전을 사용할 경우, 매번마다 타입을 지정해줘야 하지만, 템플릿 멤버함수 버전을 사용하면 타입 없이도 사용할 수 있다. 아직까지 이걸 몰랐다니.. ㅠㅠ 쑥갓군 땡큐~</p>

<p>/// template class version
template <class T>
class SafeDeleter
{
public :
void operator () ( T * &amp; ptr ) const
{
SAFE_DELETE(ptr);
}
};</p>

<p>for_each( a.begin(), a.end(), SafeDeleter<A>() );</p>

<p>/// template member function version
class SafeDeleter2
{
public :
template <class T>
void operator () ( T * &amp; ptr ) const
{
SAFE_DELETE(ptr);
}
};</p>

<p>for_each( a.begin(), a.end(), SafeDeleter2() );</p>

<h2>Static Key vs. Dynamic Key</h2>

<p>class Object
{
KeyType_t Key;
&#8230;.;
};
map&lt;KeyType_t,Obj*> orderedObjects;</p>

<p>위와 같이 객체의 특정 필드의 값으로 정렬된 map이 있다고 하자. 일단 map에 객체를 넣고 난 다음에 Key 값을 변경하면 map 내부의 트리가 깨지므로 바꿔서는 곤란해진다. 그러나, 때로는 Key 값이 바뀌어야 할 필요가 있다. 언제나 실시간으로 바꿔주려면 map 에서 객체를 빼낸 다음 Key 값을 바꾸고 다시 넣어야 하는데, 항상 넣었다 뺐다 하기에는 성능적인 부분이 걱정되는데&#8230;</p>

<p>이럴 경우에는 외부에서 필요할 때마다 새로운 키를 저장한 다음, 적당히 바꿀 타이밍이 되면 객체를 map 에서 빼낸 다음 키값을 업데이트해주면 된다. 특히 아래와 같이, 정적인 메인 키의 맵으로 구성된 객체의 매니저가 내부에 특정 순서로 정렬된 서브 키의 맵을 가진 경우, 위와 같은 패턴을 사용하면 꽤 편하다.</p>

<p>class Object
{
StaticKeyType_t MainKey;
DynamicKeyType_t SubKey;
DynamicKeyType_t NewSubKey;
&#8230;.;
};</p>

<p>class ObjectManager : public map&lt;StaticKeyType_t,Object<em>>
{
map&lt;DynamicKeyType_t,Object</em>> orderedObjects;
void ChangeSubKey( StaticKeyType_t mainKey, DynamicKeyType_t newSubKey );
void UpdateSubMap();
};</p>

<p><strong>어쨌든, map 의 키값을 외부에서 바꿨다가는 큰 낭패를 볼 것이다.</strong></p>

<p>see also:</p>

<pre><code>- [Boost Multi-index Containers Library](http://boost.org/libs/multi_index/doc/index.html)
</code></pre>

<h2>multixxx::erase(key_type)</h2>

<p>일반적인 erase()는 iterator/const_iterator 를 파라미터로 받아서 그 넘을 지우는 역할을 한다. 그런데, multimap/multiset 에서는 key_type 만 넘겨서 해당 값을 지우는 메쏘드를 제공한다. 대체로 이는 잘 동작하지만 predicate 가 명시된 multimap/multiset 에서는 생각대로 동작하지 않는다. 다음 예를 보자.</p>

<p>class TeamInfo
{
public :
TeamInfo ( int point = 0 )  : TeamPoint(point) {}
int TeamPoint;
};</p>

<p>class GreaterTeam
{
public :
bool operator () (const TeamInfo<em> l, const TeamInfo</em> r) const
{
return l->TeamPoint> r->TeamPoint;
}
};</p>

<p>void
test_multiset()
{
typedef multiset&lt;TeamInfo*,GreaterTeam> TEAMS;</p>

<p>TEAMS teams;</p>

<p>TeamInfo t1(1);
TeamInfo t2(1);
TeamInfo t3(0);
TeamInfo t4(2);</p>

<p>teams.insert( &amp;t1 );
teams.insert( &amp;t2 );
teams.insert( &amp;t3 );
teams.insert( &amp;t4 );</p>

<p>// erase by key test
teams.erase( &amp;t4 ); assert( teams.size() == 3 );
teams.erase( &amp;t1 ); assert( teams.size() == 1 );  // t1 과 t2 를 지운다. 낭패~</p>

<p>// erase with iterator test
teams.clear();
teams.insert( &amp;t1 );
teams.insert( &amp;t2 );
teams.insert( &amp;t3 );
teams.insert( &amp;t4 );</p>

<p>pair&lt;TEAMS::iterator,TEAMS::iterator> itrs = teams.equal_range(&amp;t1);
teams.erase( find( itrs.first, itrs.second, &amp;t1 ) );
assert( teams.size() == 3 );</p>

<p>assert( <em>(teams.find(&amp;t1)) == &amp;t2 ); // t1 을 찾으면 t2 가 나온다는 놀라운 사실!
assert( </em>(teams.find(&amp;t2)) == &amp;t2 );
assert( <em>(teams.find(&amp;t3)) == &amp;t3 );
assert( </em>(teams.find(&amp;t4)) == &amp;t4 );
}</p>

<p>여기서 배울 수 있는 교훈은</p>

<pre><code>- 코드상으로는 equal_range(&amp;t1)이라는 것이 t1을 찾는 것처럼 보이지만, 실제로는 key_type과 무관하며 오직 predicate 를 이용해서 검색을 한다!
- multi 시리즈에서는 find()나 erase()에 있어서 항상 동일한 값이 존재할 수 있다!
- predicate 의 비교문에서 &gt;= 을 사용하면 다른 결과가 나온다!
- predicate 관련 변수(m_TeamPoint)와 같이, 비교 로직에 영향을 주는 무언가를 외부에서 바꾸게 되면 multixxx 내부의 트리가 깨지게 된다. 너무나 당연한 사실이지만, Key 를 바꾸는게 아니라서 안전할 거 같아 보이는 것도 사실이다. 이를 방지하려면 일단 container 에서 해당 값을 erase한 다음 값을 수정하고 다시 insert 하는 것을 권장한다.
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/06/02/queueuserworkitem/">QueueUserWorkItem()</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-06-02T07:16:06+09:00" pubdate  data-updated="true" >Jun 2<span>nd</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Windows 에서 제공하는 ThreadPooling API인 QueueUserWorkItem()에 대해서 알아보자.</p>

<h2>QueueUserWorkItem()</h2>

<p>Programming Application for Microsoft Windows 에 의하면 ThreadPooling 시 새로운 쓰레드가 추가되기 위한 factor 에는 아래와 같은 것이 있다.</p>

<ul>
<li>쓰레드가 추가된 지 몇 초가 지나면, 한번 고민해본다</li>
<li>WT_EXECUTELONGFUNCTION 이 사용될 경우, 한번 고민해본다</li>
<li>큐잉된 작업의 개수가 일정 threadhold 를 넘어설 경우, 한번 고민해본다.</li>
</ul>


<p>그러나, 상세한 파라미터는 알려져 있지 않아서.. 테스트를 해 보았다.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_WORK</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class='line'><span class="n">LONG</span> <span class="n">WorkCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">add_time</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">work_time</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">nloop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">bPreQueue</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">pre_queue_time</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">bMiddleSleep</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">middle_sleep_time</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="n">MyWorkThreadProc</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">pParam</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">MyWork</span><span class="o">*</span> <span class="n">pWork</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyWork</span><span class="o">*</span><span class="p">)</span><span class="n">pParam</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">Sleep</span><span class="p">(</span><span class="n">pWork</span><span class="o">-&gt;</span><span class="n">workTime</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">pWork</span><span class="o">-&gt;</span><span class="n">threadID</span> <span class="o">=</span> <span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
</span><span class='line'>  <span class="n">pWork</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">pWork</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">InterlockedIncrement</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">WorkCounter</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">thread_pool_test_fixture</span><span class="o">::</span><span class="n">test_really_pooling</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">k</span>  <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">Sleep</span><span class="p">(</span><span class="n">pre_queue_time</span><span class="p">);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">MyWork</span> <span class="n">works</span><span class="p">[</span><span class="n">MAX_WORK</span><span class="p">];</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">Sleep</span><span class="p">(</span><span class="n">add_time</span><span class="p">);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">500</span> <span class="o">&amp;&amp;</span> <span class="n">bMiddleSleep</span> <span class="o">&amp;&amp;</span> <span class="n">middle_sleep_time</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">Sleep</span><span class="p">(</span> <span class="n">middle_sleep_time</span> <span class="p">);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">while</span> <span class="p">(</span> <span class="n">WorkCounter</span>  <span class="n">threads</span><span class="p">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">;</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">;</span> <span class="n">itr</span> <span class="o">++</span> <span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">BOOST_MESSAGE</span><span class="p">(</span> <span class="o">*</span><span class="n">itr</span>  <span class="err">처리</span> <span class="err">시간</span> <span class="o">|</span>
</span><span class='line'><span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="mi">1</span>  <span class="o">|</span> <span class="err">큐잉되는</span> <span class="err">시간</span> <span class="o">==</span> <span class="err">처리</span> <span class="err">시간</span> <span class="o">|</span>
</span><span class='line'><span class="o">|</span> <span class="mi">10</span> <span class="o">|</span> <span class="mi">20</span> <span class="o">|</span> <span class="mi">3</span>  <span class="o">|</span> <span class="err">큐잉되는</span> <span class="err">시간</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/05/29/boostis_base_of/">Boost::is_base_of</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-05-29T08:31:12+09:00" pubdate  data-updated="true" >May 29<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>템플릿 프로그래밍을 하다 보면, 문자열이나 사용자 정의 클래스(UDT) 같은 특정 타입에 대한 특수화(specializaiton)를 할 경우가 있다. 그 중에서 가장 헷갈리는 부분이 바로 특정 클래스의 포인터를 템플릿 인자로 받아서 특수화해야 하는 경우인데, boost typetraits 중 하나인 boost::is_base_of를 사용하면 손쉽게 해결할 수 있다.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span>
</span><span class='line'><span class="kt">void</span> <span class="n">old_algorithm</span> <span class="p">(</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// do generic something</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>위와 같은 함수 템플릿에 대해서 Base 클래스의 하위 클래스 포인터를 받았을 때를 위한 특수화를 해야 할 경우, 다음과 같은 패턴을 사용하라. 핵심은 is_base_of::type 이 true_type 또는 false_type 이라는 2 개의 서로 다른 타입을 리턴하며, 이 값을 이용해서 특수화를 한다는 것이다.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span>
</span><span class='line'><span class="kt">void</span> <span class="n">new_algorithm</span> <span class="p">(</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">value</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">::</span><span class="n">type</span> <span class="n">is_derived_class</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// call impl</span>
</span><span class='line'>  <span class="n">new_algorithm_impl</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">is_derived_class</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span>
</span><span class='line'><span class="kt">void</span> <span class="n">new_algorithm_impl</span> <span class="p">(</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">true_type</span><span class="o">&amp;</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// do specialized for Base class</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span>
</span><span class='line'><span class="kt">void</span> <span class="n">new_algorithm_impl</span> <span class="p">(</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">false_type</span><span class="o">&amp;</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// do generic something</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/05/26/boostany/">Boost::any</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-05-26T08:18:12+09:00" pubdate  data-updated="true" >May 26<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>게임 개발을 하다 보면, 가끔 서로 다른 타입의 객체들을 하나의 컨테이너에서 다루어야 할 때가 있다. 만약 이 컨테이너로 하는 일이 간단하다면야 인터페이스 상속을 쓰면 되지만, 상속을 할 수 없을 정도로 타입이 다를 때도 있다. 이럴 때 사용하는 것이 바로 boost::any 클래스이다.</p>

<p>boost::any는 이름 그대로 어떤(any) 것도 담을 수 있는 클래스로, void * 와 비슷한 역할을 한다. (더욱 자세한 설명은 <a href="http://boost.org/doc/html/any.html">boost 온라인 매뉴얼</a>을 참고)</p>

<p>이번에 boost::any 의 코드를 참조해서 작업을 하다 보니 몇 가지 장단점들이 눈에 띄었다.</p>

<ul>
<li>미리 any 의 내부값의 타입을 파악하고 있어야 한다. 즉, type() 을 이용해서 if-else 방식으로 비교하는 수 밖에 없다.</li>
<li>any_cast(value) 는 생각보다 타이핑하기가 귀찮다. 꺽쇠와 괄호를 다 타이핑한다고 생각해보라&#8230;</li>
<li>디버깅시 any 내부의 placeholder 에 들어 있는 값을 찾기가 곤란하다.</li>
</ul>


<p>이번 주는 영식군이 한 달 동안 쇼핑하면서 작업한 <a href="http://reiot.cafe24.com/archives/395">객체 복제 프레임워크</a>를 이틀 동안 인수인계 받은 후, 복제의 최소 단위인 replication value 클래스를 boost::any 의 코드를 참조해서 고치고 있다. 미리 2000라인 정도의 테스트 코드를 만들어둔 덕택에 <del datetime="2006-05-25T14:14:00+00:00">코드 학습</del> 리팩토링이 겨우 4일 만에 거의 끝낼 수 있었다. 물론 영식군이 계속 지나가면서 어차피 기능이 똑같다면 왜 사서 삽질을 하냐고 갈구고 있지만 그냥 못들은 척하고 중이다. 흐흐.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/05/16/p2p-tips/">P2P Tips</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-05-16T09:46:34+09:00" pubdate  data-updated="true" >May 16<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>P2P 프로그래밍에 있어서 주의해야 할 항목들을 정리해 보았다. 입문자에게 많은 도움이 되었으면 한다. (참고로 본인은 직접 P2P를 개발하기보단 동료가 삽질하는 걸 지켜본 쪽이라서, 정확하지 않은 내용이 있을 수 있음을 먼저 밝힌다)</p>

<h1>분석 및 검토</h1>

<h2>게임성 분석</h2>

<p>만들고자 하는 게임의 다양한 속성들에 대한 분석이 최우선 단계이다. 다음 질문에 자신의 게임이 어떤 쪽인지를 잘 따져보기 바란다.</p>

<pre><code>- 최대접속자는 얼마인가? (4-8, 16-32, 64-256, Massive)
- 카운터 스트라이크처럼 사용자들에게 핑이 빠른 서버를 선택할 수 있도록 할 것인가?
- NPC 또는 몹이 존재하는가? 만약 그렇다면 누가 그들을 움직이게 할 것인가?
- 승패 또는 타격 판정, 이동에 대한 검증은 누가 할 것인가?
- dedicated server 를 지원할 것인가? 또는 클라이언트 중에서 UDP 서버를 선택할 것인가?
</code></pre>

<h2>토폴로지의 선택</h2>

<p>어떤 토폴로지를 선택하느냐에 따라서 최대 대역폭, 최대 접속자가 결정되므로, 위에서 조사한 결과에 따라서 적합한 토폴로지를 선택해야 한다. 아래의 문서를 참고하기 바란다.</p>

<p>see also : <a href="http://reiot.cafe24.com/2006/02/18/%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%95%a1%ec%85%98-%ea%b2%8c%ec%9e%84%ec%9d%98-%eb%b6%84%eb%a5%98/">네트워크 액션 게임의 분류</a></p>

<h2>UDP 라이브러리의 선택</h2>

<p>토폴로지를 선택했다면 이제 UDP 라이브러리를 선택할 단계이다.</p>

<p>단지 위치 정보만을 보내는 게 아닌 이상, 순수 UDP 만으로 네트워크 게임을 개발하기란 쉽지 않다. 결국은 reliable UDP 를 지원하는 외부 라이브러리를 사용하거나 직접 구현하게 될텐데, 직접 구현하는 것은 시간이 많거나 자신이 천재가 아닌 이상 그다지 좋은 선택은 아니다. 반면 어떤 라이브러리를 선택해도 깊은 이해 없이는 잘 사용하기가 힘든 것이 사실이다.</p>

<p>가능하면 Unreal, Source Engine 등 네트워크 모듈이 포함된 게임 엔진을 구매하는 것을 권장하며, 그럴 수 없다면 충분한 검토 기간 하에 RakNet, OpenTNL, udt, enet 중에서 하나를 선택하기 바란다.</p>

<h1>디자인 및 구현, 테스트</h1>

<h2>네트워크 모듈의 통합</h2>

<p>많은 UDP 라이브러리들은 보다 빠른 반응성을 위해 자체적으로 쓰레드를 사용한다. 그러나 dedicated server 가 아닌 이상, 서버쪽은 무작정 쓰레드를 남발해서는 곤란하다. 하나의 서버가 여러 개의 게임을 동시 처리해야 할 경우가 많으므로, 이럴 때에는 소스를 수정해야 할 수 있다.</p>

<pre><code>- polling vs. event-driven
- single thread vs. multithread
</code></pre>

<p>이때 폴링 방식의 클라이언트는 로딩 혹은 렌더링으로 인해 네트워크 업데이트를 방해하는 일이 없도록 주의해야 한다.</p>

<h2>NAT와 홀펀칭</h2>

<dl> <dt>하드웨어의 구비</dt> <dd>하드웨어가 없는 상태에서의 NAT 프로그래밍은 장님 코끼리 다리 만지기와 같다.</dd> <dt>SNAT</dt> <dd>SNAT-SNAT 간에는 홀펀칭이 통하지 않는다는 사실만 기억하면 된다. 중국이 아닌 이상 SNAT를 만나기란 쉽지 않다. 정 귀찮다면 C/S구조로 가는 것도 나쁘지 않다. GPGStudy 포럼을 잘 검색하면 어떤 라우터가 SNAT인지를 찾을 수 있다.</dd> <dt>N+1</dt> <dd>어떤 NAT는 새로운 매핑을 위해 포트 번호를 점차 증가시키기도 한다. 그러나 라우터 제조 업체마다 다르므로 일반적으로는 알 수 없다고 봐야 한다.</dd> <dt>Timeout</dt> <dd>30-40초마다 패킷을 밖으로 쏘지 않을 경우 매핑을 삭제하는 공유기가 존재한다.</dd> <dt>패킷 릴레이</dt> <dd>직접적인 통신이 되지 않는 peer 에게 패킷을 보낼 수 있는 유일한 방법이다. 문제는 릴레이는 핑이 2배 느려지는 것이 보통이므로 데드 레커닝 및 보간 기능으로 잘 극복해야 한다. 릴레이가 끊기는 경우 실시간으로 다른 루트를 찾아주면 금상첨화.</dd> <dt>사설 네트워크</dt> <dd>같은 네트워크에 있는 사용자들 끼리는 굳이 public 주소로 접속할 필요는 없다. 상대방의 (public,private) 모두로 핑을 쏜 다음, 응답이 오면 그 중 빠른 넘을 실제 주소로 선택하라. 이때 둘 다 될 경우라면 대체로 private를 사용하는 편이 좋다. 물론 **본인 확인**은 필수. 방화벽 내부에 있는 사람들끼리 플레이할 경우 public 으로 통신하면 괴로워진다.</dd> <dt>다단계 NAT</dt> <dd>중국은 다단계 NAT로 악명이 높다. 최소한 2단계로 NAT를 배치한 후 각 노드마다 클라이언트를 두고 내부/외부와 통신이 잘 되는지를 확인할 것. 그렇게 열심히 테스트해도 안되는 환경이 분명 존재하므로, 처음부터 릴레이를 기본 기능으로 포함시킬 것.</dd> <dt>사용자 서버</dt> <dd>네트워크 비용을 줄이려면 특정 클라이언트가 서버 역할을 하도록 하라. 단 Drop-out시 게임을 중단하고 새 서버를 찾는 기능을 구현해야 한다. 물론 보안 문제는 책임질 수 없다;;</dd> </dl>


<h2>대역폭 관리</h2>

<dl> <dt>모뎀 지원</dt> <dd>해외에는 아직도 모뎀을 많이 사용하고 있다. 따라서 모뎀 유저가 방에 들어올 경우 최대 접속자를 줄이든가 대역폭에 맞게 데이터를 실시간 관리하는 기능이 필요하다.</dd> <dt>MTU</dt> <dd>게임에서의 최대 패킷 크기를 항상 알고 있을 것. 특히 리스트 방식으로 전송되는 데이터들(방 목록, 사람 목록, 게임 목록)을 유의할 것.</dd> <dt>순간 대역폭 체크</dt> <dd>어떤 공유기(D-Link)는 순간 대역폭을 초과할 경우 reset 되기도 한다.</dd> </dl>


<h2>공유기, 방화벽, 포트 포워딩</h2>

<dl> <dt>(D)DOS 공격</dt> <dd>어떤 공유기는 외부로부터 갑자기 연결이 많이 들어올 경우 DOS 혹은 DDOS 로 간주해서 연결을 차단하기도 한다.</dd> <dt>XP 방화벽</dt> <dd>Windows XP의 방화벽에 자동 등록하기는 필수. 단 사용자에게 허가를 받지 않고 몰래 방화벽을 끌 경우 해외에서는 고소당할 수 있다.</dd> <dt>백신 호환성 체크</dt> <dd>일부 백신들은 정상적인 어플리케이션도 바이러스나 웜으로 간주하기도 한다. 따라서 유명 백신들을 설치한 상태에서 툴과의 호환성을 체크한 후 문제가 있다면 매뉴얼을 홈페이지에 등록해야 한다.</dd> <dt>포트 포워딩</dt> <dd>portforward.com이나 [WOW](http://www.blizzard.com/support/wow/?id=aww01154p)처럼 공유기에서 포트포워딩을 하는 방법을 홈페이지에 기술할 것. 가능하면 클라이언트에 네트워크 진단 도구를 탑재하거나, 웹 기반 진단 페이지를 만들기를 권장한다.</dd> <dt>주의 깊은 포트의 선택</dt> <dd>해외의 일부 회선 업체는 자신들의 자체 서비스(VoIP)를 위해 특정 UDP 포트를 임의로 막기도 한다. 가능한한 다른 게임 및 어플리케이션과 충돌하지 않는 포트를 선택할 것.</dd> <dt>서버 방화벽</dt> <dd>네트워크 관리자에게 사용하는 포트에 대한 문서를 넘기고 수시로 업데이트 해줄 것. (특히 해외 서비스일 경우는 필수) 허용된 포트의 끝언저리에서 실수로 인한 문제가 종종 생기곤 한다.</dd> </dl>


<h2>기타</h2>

<pre><code>- 공유기의 타입 찾기 : STUN
- Drop-In : 게임 도중 새로운 접속자가 들어올 때
- 연결 끊김 감지 : 게임 도중 연결이 끊길 경우 얼마나 빨리 감지할 수 있을까?
- 데이터 복제, 보안, 통계 수집
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/05/16/iocp-tips/">IOCP Tips</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-05-16T09:15:40+09:00" pubdate  data-updated="true" >May 16<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong><em>[공지사항] 이 페이지는 더이상 업데이트되지 않으며, 최신 버전은 <a href="http://reiot.springnote.com/pages/87239">http://reiot.springnote.com/pages/87239 </a>에서 읽으실 수 있습니다. </em></strong></p>

<p>I/O completion port 를 개발할 때 주의해야 할 사항들.</p>

<h2>1-Recv Rule</h2>

<p>하나의 소켓에 대해서 특정 순간에 1개 이하의 입력만이 요청되어야 한다는 규칙을 <strong>1-recv 규칙</strong>이라고 부른다. 물론 버퍼를 여러 개 준비한 다음 미리 요청해두는 N-recv 방식도 그럴듯하지만, 요청한 순서대로 항상 완료되지는 않는다는 소문(?)에 그다지 많이 사용되고 있지는 않은 듯하다.</p>

<p>그런데, 입력 재요청은 GQCS()를 호출하는 입출력 쓰레드에서 할 수도 있지만, 로직 처리 쓰레드에서 하는 경우도 많다. MMORPG가 아닌 경우에 한정해서 후자의 방식을 권장하는 편인데, 코드는 약간 복잡하지만 버퍼 복사 및 동기화 부담도 줄어들기 때문이다. 다음 두 예제를 살펴보자.</p>

<h1>ex1</h1>

<p>class ideal_session:
def end_read(self,buf,len):
&#8221;&#8221;&#8220;callback for input completion. called by i/o thread&#8221;&#8220;&#8221;
while 1:
msg = self.get_msg() # parse &amp; copy!!
if msg:
msgq.append((self,msg))
self.begin_read()</p>

<p>def ideal_process_sessions():
&#8221;&#8221;&#8220;logic process thread&#8221;&#8220;&#8221;
while 1:
session, msg = msgq.pop()
if session and msg:
msg_handler(session,msg)</p>

<h1>ex2</h1>

<p>class real_session:
def end_read(self,buf,len):
&#8221;&#8221;&#8220;callback for input completion. called by i/o thread&#8221;&#8220;&#8221;
sessions.append(self) # only notify</p>

<p>def real_process_sessions():
&#8221;&#8221;&#8220;logic process thread&#8221;&#8220;&#8221;
while 1:
session = sessions.pop()
if session:
while 1:
msg = session.get_msg() # parse but no copy!
if not msg: break
msg_handler(session,msg)
session.begin_read()</p>

<p>[예제1]에서는 입출력 쓰레드에서 메시지 파싱 - 큐잉 - 입력 재요청이 이루어지고 로직 처리 쓰레드는 메시지큐로 동작하는데, 전체적으로 코드는 단순하지만 <strong>메모리 복사 및 할당</strong>이 많아진다. 또한 입력 버퍼가 가득 찬 후의, 다음 입력 재요청을 과연 어디서 할 것인지도 애매하다. 반면, [예제2]에서는 대부분의 작업을 로직 처리 쓰레드에 위임시킴으로써 입출력 처리 쓰레드의 부하를 최소화하면서, 버퍼 복사 역시 극단적으로 줄일 수 있게 된다.</p>

<p>단, [예제1]이 <strong>입력 완료 후 재요청</strong>이 더 빠르지만, 전체적인 입출력 처리를 감안한다면 그다지 빠르다고 보기는 힘들 것으로 추측한다.</p>

<h2>1-Send Rule</h2>

<p>입력과 달리 출력 관리 방법에 대해서는 많은 이견이 존재한다.</p>

<p>N-send 는 보통 출력 버퍼 관리를 하기보다는 필요할 때마다 즉시 보내는 것을 의미하는데, 테스트해 본 결과 출력 완료시 <strong>bytes_transferred != bytes_written</strong> 인 경우를 거의 못봤다는 이야기도 종종 들린다. 그러나 만에 하나 예외 상황이 발생한다면 TCP 스트림이 꼬이게 되므로 1-send 로 구현하는 것을 보통 권장한다. <em>좀 더 자세한 설명은 <a href="http://www.gpgstudy.com/forum/viewtopic.php?t=2998">GPGStudy에서 sparrowhawk님이 쓰신 글</a>과 <a href="http://www.codeproject.com/internet/reusablesocketserver4.asp">이 글</a>을 참고하도록 할 것.</em></p>

<p>고전적인 출력 버퍼 관리 방식에서는 큰 출력 버퍼를 마련해 두고, 보낼 데이터를 복사한 후 한꺼번에 flush 하게 된다. 여기에 버퍼 복사를 줄이기 위해 큰 버퍼 대신 버퍼의 리스트로 구현한 것을 바로 <strong>gather-send</strong> 라고 하는데, 대부분이 broadcast 인 게임 서버에서는 Lock과 참조카운팅, 메모리 풀링을 함께 사용해야 하기 때문에, unicast가 많은 미들웨어에 한정해서 사용해야 할 것이다. 가능하면 출력 버퍼의 관리 방식을 손쉽게 교체할 수 있는 프레임워크를 만들거나 사용하는 것을 추천한다.</p>

<p>출력 완료 처리 및 재요청은 당연히 로직 처리 쓰레드의 몫이 된다. 1-Recv Rule과 같은 방식으로 하면 간단하므로 따로 예제는 준비하지 않았다.</p>

<h2>NumberOfCurrentThresds</h2>

<p>CreateIoCompletionPort() 의 마지막 파라미터인 NumberOfConcurrentThreads 에 대한 MSDN의 설명을 보자.</p>

<blockquote><p>Maximum number of threads that the operating system allows to concurrently process I/O completion packets for the I/O completion port. If this parameter is zero, the system allows as many concurrently running threads as there are processors in the system.</p><p>Although any number of threads can call the GetQueuedCompletionStatus function to wait for an I/O completion port, each thread is associated with only one completion port at a time. That port is the port that was last checked by the thread.</p><p>When a packet is queued to a port, the system first checks how many threads associated with the port are running. If the number of threads running is less than the value of NumberOfConcurrentThreads, then one of the waiting threads is allowed to process the packet. When a running thread completes its processing, it calls GetQueuedCompletionStatus again, at which point the system can allow another waiting thread to process a packet.</p><p>The system also allows a waiting thread to process a packet if a running thread enters any wait state. When the thread in the wait state begins running again, there may be a brief period when the number of active threads exceeds the NumberOfConcurrentThreads value. However, the system quickly reduces the number by not allowing any new active threads until the number of active threads falls below the specified value.</p></blockquote>


<p>즉 이 파라미터는 GQCS()에서 리턴되어 I/O completion 을 처리하는 쓰레드의 최대 동시 실행 개수를 의미한다. GQCS()를 호출하는 사용자 쓰레드의 개수에는 제한이 없지만, IOCP 자체에서 리턴시키는 개수를 이 파라미터로 제한하게 된다. 따라서 이 개수가 커지면 CPU 의 부하가 심해지므로 보통 0 을 넣어 자동화하거나 CPU 개수의 2배를 사용한다.</p>

<h2>리소스 관리</h2>

<p><em>Network Programming for Microsoft Windows 2000</em>에 나오는 리소스 관련 부분을 적당히 번역해봤다.</p>

<blockquote><p>IOCP 를 사용한 Windows 서버를 개발할 때에는 locked pages 제한과 non-paged pool 제한에 유의해야 한다. 그 중 locked pages 제한이 non-paged pool 제한보다는 덜 위험하고 해결하기도 더 쉽다.</p><p>**Locked Pages Limit**</p><p>모 든 Overlapped I/O 에 있어서 WSABUF 의 메모리 공간은 locked 된다. 메모리가 lock 되면, 이넘들은 page out 되지 않는다. OS 레벨에서 locked page 의 최대 제한이 존재한다. 이 제한에 도달하면 이후의 Overlapped I/O 에서는 WSANOBUFS 에러가 리턴된다.</p><p>이때, 최대 연결의 개수가 중요한 서버에서는 0 bytes overlapped I/O 기법을 사용할 수 있다. 이 기법에서는, 버퍼를 제공하지 않으므로 locked 되는 메모리가 발생하지 않는다. (읽기 요청이 완료될 때 nonblocking receive 를 하는 방식이다.) 단, 클라이언트와 서버간의 통신 방식에 따라서 좋은 방법을 골라야 한다. 만약 클라이언트가 데이터를 열라 보낸다면, 잦은 Overlapped Input 호출이 있을테니..</p><p>*(WSABUF[0].buf 가 가리키는 메모리 공간에 lock 이 걸리는 것은 당연하다만, OVERLAPPED 구조체가 존재하는 메모리에도 마찬가지일까? 윗 글에 따르면 그건 아닌 듯한데.. 냠..)*</p><p>또 중요하게 고려해야 하는 것은, 시스템의 페이지 사이즈이다. lock 을 걸 때에는 페이지 단위로 걸게 되는데, x86 에서의 페이지 크기는 4K 의 배수이다. (조사해보니 x86 에서는 4K 였다) GetSystemInfo() 를 사용하면 페이지 크기를 알 수 있다.</p><p>**Non Paged Pool Limit**</p><p>non-paged pool 제한은 보다 위험하고, 복구하기도 어렵다. non-paged pool 은 항상 물리적 메모리에 존재하고, 절대 page out 되지 않는 메모리 영역이다. 커널과 각종 드라이버들이 이 영역에 속한다. 또한 각 소켓 역시 non-paged pool 에 소켓 상태를 저장하기 위한 약간의 메모리를 소비하게 된다. 특정 주소에 bind 될 경우, 주소 정보를 위한 추가적인 메모리가 더 필요하다. 소켓이 연결되면 remote address 관련된 메모리도 필요해진다. 모두 합하면, 연결된 소켓은 2k 정도, accept/AcceptEx 로 리턴된 소켓은 1.5k 정도의 non-paged pool 공간을 차지한다. (accepted 소켓은 단지 리모트 주소만 필요하기 때문에 약간 더 작다) 또한, 각 overlapped I/O 연산은 500 바이트 정도의 메모리 공간을 필요로 한다. *(500 바이트는 혹시 OVERLAPPED 구조체를 위한 공간이 아닐까?)*</p><p>일 반적으로 non-paged pool 은 물리적 메모리의 1/4 이며, W2k 에서는 256M, NT4 에서는 128M 의 최대 제한을 가진다. 256M 의 경우라면 5만 정도의 연결을 처리할 수 있지만, Accept/Send/Receive Overlapped I/O 의 개수가 제한된다는 점에 주의하라. accepted 소켓당 1.5k 이라고 하면, 소켓 자체로만 75M( 50000 x 1.5k )를 차지하며, 0 bytes receive 기법을 사용한다면 25M의 메모리를 차지한다.</p><p>만 약 시스템의 non-paged pool 이 한계에 도달하면, 운이 좋다면 WSANOBUFS 에러를 리턴하지만 그렇지 않으면 crash 될 것이다. 이를 복구하거나 예측(혹은 모니터링)한다는 것은 거의 불가능하기 때문에 개발자 스스로 최대 동시 접속수라든지, 최대 overlapped 연산의 숫자 등을 테스트해볼 필요가 있다. 만약 WSAENOBUFS 에러를 만난다면 연결을 닫는다든지 해서 줄이는 것이 좋을 것이다&#8230;</p></blockquote>


<p>see also:</p>

<pre><code>- http://pl.atyp.us/content/tech/servers.html
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/05/02/%E1%84%8B%E1%85%A9%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%84%87%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB-%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B52/">오블리비언 스토리#2</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-05-02T10:05:20+09:00" pubdate  data-updated="true" >May 2<span>nd</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Official Guide 가 20일만에 드디어 도착했다. 랄라~</p>

<h2>the Origin of Gray Prince</h2>

<p>수도 임페리얼 시티의 투기장에 가면, 별명이 Gray Prince인 그랜드 챔피언 Agronak gro-Malog이라는 오크를 만날 수 있다. 그는 하녀였던 자신의 엄마가 군주와 사랑에 빠져서 자신을 낳았다가 군주의 마누라가 죽이려고 해서 할 수 없이 도망쳤다고 한다. 곧 열쇠를 하나 주며 혈통의 증거를 찾아와 달라고 하는데, 실제로 그 성에 가보면 오크 군주가 아니라 뱀파이어만 득실거리고 있다. 뱀파이어인 Lord Lovidicus를 죽이고 일기장을 가져다주면, 챔피언은 자신은 아무것도 아닌 괴물의 자식이며 그럴바엔 투기장에서 명예롭게 죽겠다며 실의에 빠진다.</p>

<p>실제로 투기장에서 그와 싸우게 되면, 공격하는 대신 귓속말로 빨리 자신을 죽이라고 하는데&#8230; 무시무시하게 달려오는 속도에 비해서 너무나도 슬퍼보였던 오크의 눈빛이 잊혀지지 않는다. (대신 이 퀘스트를 하지 않고 챔피언과 겨루게 되면 아마 피터지는 싸움이 되었으리라.)</p>

<p>오블리비언의 모든 NPC들의 목소리가 다 녹음된 것처럼, 매 경기마다 투기장에 울려퍼지는 아나운서(?)의 목소리도 계속 달라진다. 또한 챔피언과의 대결에서는 아나운서가 불러주는 호칭도 지정할 수도 있다. (이번에 키우는 캐릭터는 남자 레드가드 전사라서 the Crimson Sword를 선택했다. 으하하) 그리고, 투기장 위로 올라가면 실제로 NPC들이 싸우는 장면을 보면서 돈도 걸 수 있다.</p>

<h2>산적(Bandit) 이야기</h2>

<p><img class='' src='http://boxcatstudio.files.wordpress.com/2009/07/bandits.gif' width='' height='' alt='bandits.gif' title='bandits.gif'>코럴성에 가면 얼굴은 잘생겼지만 지능이 약간 모자라는 청년이 쌍동이 형을 찾아달라는 퀘스트를 준다. 대륙 반대편의 도시에 있는 형을 찾아가서 소식을 알려주면, 형은 즉시 동생을 찾아서 대륙을 횡단하기 시작한다. 과연 또 어디까지 뛰어가나 싶어서 따라가봤는데, 갑자기 매복중인 산적에게 두들겨 맞아 쓰러지는게 아닌가&#8230; 이런 퀘스트 NPC들은 죽지 않는 대신 그냥 실신했다가 다시 일어나기를 반복하기에, 귀찮아서 산적을 잡아 주었다. 다시 벌떡 일어나서 동생을 찾아 뛰어가는 걸 보고&#8230; 인사를 하고 뒤돌아섰다. ㅋ</p>

<p>그 후, 또다른 퀘스트를 하기 위해서 들판을 달려가고 있는데 멀리서 말을 탄 NPC하나가 달려 와서 인사를 하고 지나갔다. 웃긴 건 그 뒤로 또다른 산적 하나가 도끼를 들고 열심히 쫓아가는 장면. 결국 그 산적은 옆에 있던 길드 NPC에게 죽음을 당하게 되는데.. 앞에 NPC는 그것도 모르고 열심히 달려가고 있었다. 으하하.</p>

<p>보통 산적들은 길가에서 매복해 있는데 커다란 돌 뒤에 숨어 있다가 뛰어나와서 돈 100골드를 내놓을래 죽을래? 라고 묻곤 한다. 제일 특이한 넘들은 다리에서 통행세를 받는 넘들인데, 꼭 다리 건너 귀퉁이에 숨어 있다가 뛰어나온다. 언젠가는 다리 옆 으슥한 곳에서 자세를 잡고 있길래 숨어서 활로 죽여 버린 적도 있다. 레벨이 올라갈수록 장비가 화려해지기 때문에, 길을 가면서도 가끔은 산적이 나오기를 기대하곤 한다. :)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2006/04/29/css-tip/">CSS Tip</a></h1>
    
    
      <p class="meta">
        





  



<time datetime="2006-04-29T18:33:45+09:00" pubdate  data-updated="true" >Apr 29<span>th</span>, 2006</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>[공지사항] : 이 페이지는 더이상 업데이트되지 않으며, 최신 버전은 <a href="http://reiot.springnote.com/pages/22538">http://reiot.springnote.com/pages/22538</a> 에서 보실 수 있습니다.</strong></p>

<h1>id &amp; class</h1>

<p>class는 여러 곳에 쓸 수 있지만 id는 한 군데만 써야 하고, 특히 id는 anchor 의 타겟으로도 사용될 수 있다.</p>

<table>
<thead>
<th>selector</th>
<th>scope</th>
<th>example</th>

<tr>
<td>id selector</td>
<td>instance level style (single)</td>
<td>H1 #xxx {&#8230;}</td>
</tr>
<tr>
<td>class selector</td>
<td>class level style (multiple)</td>
<td>H1.xxx {&#8230;}</td>
</tr>
</thead></table>


<p>&#8217;*&#8217; 문자는 생략 가능하기 때문에, 다음의 두 표현식은 동등하다.</p>

<p>*#xxx {&#8230;}</p>

<h1>xxx {&#8230;}</h1>

<h1>padding &amp; margin</h1>

<p>padding 은 box 영역의 안쪽, margin 은 바깥쪽을 의미하는데, 본문 바깥쪽의 여백을 나타낸다는 것을 연상하면 쉬울 것이다. 각 방향별 속성을 지정할 수도 있고, 한꺼번에 지정할 수도 있다. 이때, 위에서부터 시계방향이라는 것만 외우면 편하다.</p>

<p>padding-top: 1px;
padding-bottom: 2em;
padding : &#8216;top&#8217; &#8216;right&#8217; &#8216;bottom&#8217; &#8216;left&#8217;;</p>

<p><a href="http://www.w3.org/TR/REC-CSS2/box.html#mpb-examples">padding &amp; margin example</a>을 참고할 것.</p>

<h1>div &amp; span</h1>

<p>div는 해당 블럭에 특정 id 또는 class 속성을 적용한다. 아래의 예제는 2개의 테이블 모두를 우측 정렬을 하기 위해서 DIV 태그를 사용했다.</p>

<p><a href="http://december.com/html/4/element/div.html">&lt;div</a> align=&#8221;right&#8221;>
<a href="http://december.com/html/4/element/table.html"><table></a>&#8230;</table>
<a href="http://december.com/html/4/element/table.html"><table></a>&#8230;</table>
</div></p>

<p>반면 span은 inline 으로 특정 id 또는 class 속성을 적용한다. 아래의 예제는 P 전체에 클래스 스타일을 적용해서 폰트 크기 및 종류를 지정한 다음, &#8217; 에 대해서만 빨간색으로 표시하기 위해서 SPAN 태그를 사용했다.</p>

<p><a href="http://december.com/html/4/element/p.html">&lt;p</a> class=&#8221;oreiot&#8221;>O<a href="http://december.com/html/4/element/span.html">&lt;span</a> class=&#8221;red&#8221;>&#8217;</span>REIOT</p></p>

<h1>font size</h1>

<p>픽셀 등의 단위를 사용하게 되면, 화면 해상도에 관계없이 크기가 고정되게 된다. 이렇게 할 경우, 브라우저의 문자 크기 확대-축소를 해도 바뀌지 않는다. 눈이 나쁜 사람들을 위해서도 픽셀 고정 보다는 아래의 크기를 사용하는 것을 권장한다. (순수 디자인의 관점에서는 맞지 않을지도?)</p>

<p>xx-small &lt;x-small &lt;small &lt;medium &lt;large &lt;x-large &lt;xx-large</p>

<p>아니면, 상대 크기인 smaller - larger를 써서, 자신의 부모 객체의 폰트보다 크거나 작도록 지정할 수도 있다.</p>

<h1>호환성 있는 페이지 만들기</h1>

<p>우선, 해당 페이지를 순수하게 텍스트로 렌더링하는 페이지를 만든다. 이때, h1, h2, &#8230;, p, hr, ul, ol, li, b 등의 텍스트형 태그만을 사용하도록 한다. (당연히 font 류의 데코레이션형 태그는 사용하지 않도록 한다.)</p>

<p>텍스트 페이지가 완성되면, 이제 각 element 에 적당한 클래스 스타일을 지정해서, 아름답게 꾸미도록 한다. 중복되는 스타일은 DIV 등을 이용해서 그룹으로 묶는다. (가령 li 태그들)</p>

<p>끝으로 CSS validate 및 HTML validate 를 통해서 호환성을 검증한다. 브라우저 테스트는 기본.</p>

<h1>float &amp; clear</h1>

<p>박스 또는 이미지가 다른 레이어와 충돌하지 않는 상태에서, 좌측 또는 우측으로 정렬될 수 있게 해준다. 가끔은, float 박스가 2개 이상의 레이어에 걸치지 않았으면 할 때가 있다. 이럴 경우, float 를 포함한 상위 레이어에다가 clear:both 속성을 지정해주면 걸치기를 막을 수 있다.</p>

<p><a href="http://www.w3.org/TR/REC-CSS2/visuren.html">Visual Formatting Model</a>을 참고할 것.</p>

<h1>기타 태그 설명</h1>

<pre><code>- line-height : 줄 간격
</code></pre>

<p>see also:</p>

<pre><code>- [CSS2 specification](http://www.w3.org/TR/REC-CSS2)
- [XHTML specification](http://www.w3.org/TR/xhtml-basic)
</code></pre>
</div>
  
  


    </article>
  
  <nav class="pagination">
    <div>
      
        <a class="prev" href="/page/42/">&larr; Older</a>
      
      <a href="/blog/archives">Blog Archives</a>
      
      <a class="next" href="/page/40/">Newer &rarr;</a>
      
    </div>
  </nav>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2011/09/21/wordpress-to-octopress/">Wordpress To Octopress</a>
      </li>
    
      <li class="post">
        <a href="/2011/07/09/jquery-proven-performance-tips-tricks/">jQuery Proven Performance Tips &amp; Tricks</a>
      </li>
    
      <li class="post">
        <a href="/2011/06/18/jquery-mobile-tip/">jQuery Mobile Tip</a>
      </li>
    
      <li class="post">
        <a href="/2011/06/18/clienpad-appspot-com/">clienpad.appspot.com</a>
      </li>
    
      <li class="post">
        <a href="/2011/04/15/ant-cookbook/">Ant Cookbook</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/reiot">@reiot</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'reiot',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("reiot", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/reiot" class="twitter-follow-button" data-width="208px" data-show-count="false">Follow @reiot</a>
  
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2011 - Ray Yun -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
    (function () {
      var disqus_shortname = 'reiot';
      
        
        var disqus_script = 'count.js'
      

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


  

  
  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>


  
  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>


</body>
</html>
