<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Social Game Developer wandering strange dungeon...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	<div class="row">
		<div class="span9">
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/06/04/ole-db-tips/">OLE DB Tips</a> <small>2006-06-04</small></h1>
	</div>
	<div><h2>multiple result set + parameter binding</h2>
<pre><code>- 캐릭터 정보 로딩과 같이, 하나의 프로시저에서 여러 테이블의 row 들을 select 하면서 파라미터도 바인딩해야 할 경우, static binding 으로는 구현할 수 없으며, CDynamicParameterAccessor::GetParam()를 이용해야 한다.
- 파라미터의 경우, select 해온 모든 result set 을 소진한 후, 가장 마지막에 읽어와야 한다. 즉 DB_S_NORESULT == GetNextResult(...); 를 실행한 후에만 유효하다는 뜻이다. 만약, 그 전에 읽게 되면 garbage 가 리턴된다.
- Bind()와 무관하므로, GetInterface()!=NULL 체크를 할 필요가 없다.
</code></pre>
<h2>CCommand::Prepare()</h2>
<p>한번 생성후 재사용하는 구조가 필요하다.</p>
<h2>GetNextResult(rowCount)</h2>
<p>웬지 계속 -1 이 넘어오는 걸로 봐서 뭔가 문제가 있는 듯? property 설정이 필요한가?</p>
<h2>DateTime to String</h2>
<pre><code>- VarBstrFromDate 이걸 써야 될까나~
- use
</code></pre>
<p>HRESULT DataConvert (<br />
DBTYPE          wSrcType,<br />
DBTYPE          wDstType,<br />
DBLENGTH        cbSrcLength,<br />
DBLENGTH <em>      pcbDstLength,<br />
void </em>          pSrc,<br />
void <em>          pDst,<br />
DBLENGTH        cbDstMaxLength,<br />
DBSTATUS        dbsSrcStatus,<br />
DBSTATUS </em>      pdbsStatus,<br />
BYTE            bPrecision,<br />
BYTE            bScale,<br />
DBDATACONVERT   dwFlags);</p>
<h2>Connection Pooling</h2>
<pre><code>- SqlServer Provider 를 기반으로, ThreadPooling 을 이용해 쿼리를 할 경우, DataSource 가 1개이고 Session 이 N 개를 생성했다면, 실제 DB에 대한 연결은 N 개가 된다.
- 즉, Session 이 내부적으로 연결 풀링을 사용하게 되므로, DataSource 객체는 1개만 만들어도 된다.
</code></pre>
<h2>어떤 Accessor 를 사용할 것인가?</h2>
<p>MSDN 의 비교표를 간략하게 요약하면 다음과 같다.</p>
<pre><code>- CAccessor : 매크로를 이용한 컴파일 타임 바인딩이므로 성능 면에서 가장 우수하지만, 쉽게 말해서 하드코딩이므로 귀찮은 작업들이 많다. 컬럼 및 파라미터 바인딩 모두 지원.
- CDynamicAccessor : 런타임 바인딩. 따라서 컬럼 정보를 읽어와야한다. 대신 파라미터 바인딩은 불가능. 뭔가 컴파일 타임에 정보를 알기 힘든 경우, 또는 multiple result set 을 리턴하는 프로시저에 사용하면 된다.
- CDynamicParameterAccessor : CDynamicAccessor 에 파라미터 바인딩 기능이 추가되었다. 당연히 더욱 느려졌다.
- CDynamicStringAccessor : CDynamicAccessor 와 유사하지만 컬럼값을 스트링으로 리턴한다.
- CManualAccessor : AddBindEntry(), AddParameterEntry() 를 이용해서 수동으로 컬럼과 파라미터를 바인딩한다. 아마 CAccessor 에 이어 두번째로 빠른 듯.
- CXMLAccessor : CDynamicStringAccessor 와 같지만, XML 스트링의 형태로 컬럼값을 리턴한다.
</code></pre>
<p>성능적인 순서로 정렬해 본다면 대충 다음과 같지 않을까? (이건 본인의 추측)</p>
<pre><code>- CAccessor &lt; CManualAccessor &lt; CDynamicAccessor &lt; CDynamicStringAccessor &lt; CXMLAccessor &lt; CDynamicParameterAccessor
</code></pre>
<p>단, 파라미터 바인딩을 지원하는 넘은 아래의 3가지 뿐이다.</p>
<pre><code>- CAccessor
- CManualAccessor
- CDynamicParameterAccessor
</code></pre>
<p>see also</p>
<pre><code>- [Which accessor should I use?](http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccore/html/vcfaqwhichaccessorshouldiuse.asp) from MSDN
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/06/01/stl-tips/">STL Tips</a> <small>2006-06-01</small></h1>
	</div>
	<div><pre><code></code></pre>

<pre><code>***이 페이지는 더이상 업데이트되지 않으며, 최신 버전은 http://reiot.springnote.com/pages/87168에서 보실 수 있습니다.***```
</code></pre>

<pre><code>## dll + STL

dll 에서 hash_set 을 멤버로 가진 클래스를 만들려다가 nested class 인 _Hash 라든지 hash_compare 등등을 모두 dllexport 하라길래 포기하고 PIMPL 패턴으로 해결해야만 했다.

    - [How To Exporting STL Components Inside &amp; Outside of a Class](http://support.microsoft.com/default.aspx?scid=kb;EN-US;168958)

## boost::lambda

아래의 mem_fun_if 류와 비슷한 역할을 하는 것이 바로 boost::lambda 라이브러리다. 일단 아래처럼 포인터 컨테이너를 순회하면서 NOT NULL 일 경우에 특정 멤버 함수를 호출하는 예제를 살펴보자.

</code></pre>

<p>for_each( l.begin(), l.end(),<br />
if_then( _1 != constant((A*)NULL), bind( &amp;A::print, _1 ) ) );</p>
<pre><code>lambda 라이브러리를 사용하면 위와 같이 간단한 코드로 표현이 가능하다. 대신 컴파일 속도는... ㅠㅠ
## mem_fun_if

일반적으로 포인터 컨테이너를 순회하면서 특정 조건을 만족할 경우 멤버 함수를 호출하는 패턴을 위한 자작 adapter function 이다. (물론 const 버전과 파라미터 1개를 받는 버전, 합쳐서 총 4개의 클래스와 4개의 함수를 만들어야 하지만... 시간상 생략)

</code></pre>

<dl>
<dt>template<class _Pred, class _Result, class _Ty></dt>
<dt>class mem_fun_if_t : public unary_function&lt;_Ty *, _Result&gt;</dt>
<dt>{</dt>
<dt>public:</dt>
<dt>explicit mem_fun_if_t( _Pred pred, _Result (_Ty::*_Pm)())</dt>
<dd>_pred(pred), _Pmemfun(_Pm), _count(0)<br />
  {<br />
  }</dd>
</dl>
<p>// 단점이라면 멤버함수의 리턴값은... 도무지 캐치불가능...<br />
  bool operator()(_Ty <em>_Pleft) const<br />
  {<br />
  if ( _pred(_Pleft) )<br />
  {<br />
  ((_Pleft-&gt;</em>_Pmemfun)());<br />
_count++;<br />
  return true;<br />
  }<br />
  return false;<br />
  }</p>
<p>int count() const { return _count; }</p>
<p>private:<br />
_Pred _pred;  // predicate<br />
_Result (_Ty::*_Pmemfun)(); // the member function pointer<br />
mutable int _count;<br />
};</p>
<p>template<class _Pred, class _Result, class _Ty><br />
inline<br />
mem_fun_if_t&lt;_Pred,_Result, _Ty&gt;<br />
mem_fun_if(_Pred pred,_Result (_Ty::*_Pm)())<br />
{<br />
  return (mem_fun_if_t&lt;_Pred,_Result, _Ty&gt;(pred,_Pm));<br />
}</p>
<pre><code>이를 이용한 샘플이다.

</code></pre>

<p>using namespace std;</p>
<p>class A<br />
{<br />
public :<br />
  explicit A( const string &amp; s ): str(s) {}<br />
  void print() { cout &lt;&lt;str &lt;&lt;endl; }<br />
string str;<br />
};</p>
<h1>define not_null(T) bind2nd( not_equal_to<T*>(), (T*)0)</h1>
<p>int _tmain(int argc, _TCHAR* argv[])<br />
{<br />
list<A*> l;<br />
l.push_back( new A("Hello") );<br />
l.push_back( NULL );<br />
l.push_back( new A("World") );<br />
l.push_back( NULL );<br />
l.push_back( new A("!") );</p>
<p>for_each( l.begin(), l.end(), mem_fun_if( bind2nd( not_equal_to<A*>(), (A*)0 ), &amp;A::print ) );<br />
for_each( l.begin(), l.end(), mem_fun_if( not_null(A), &amp;A::print ) );</p>
<p>return 0;<br />
}```</p>
<h2>if_not_null</h2>
<p>다음은 포인터 컨테이너에서 NOT NULL 인 갯수를 찾는 코드이다.</p>
<pre><code>
count_if( l.begin(), l.end(),
bind2nd( not_equal_to&lt;A*&gt;(), (A*)0 ) );
</code></pre>

<h2>ptr_fun and not1, not2</h2>
<p>ptr_fun 은 말 그대로 pointer to function 이다.</p>
<pre><code>
template&lt;class Arg, class Result&gt;
pointer_to_unary_function&lt;Arg, Result&gt;
ptr_fun(Result (_*pfunc)(Arg));

template&lt;class Arg1, class Arg2, class Result&gt;
pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;
ptr_fun(Result (_*pfunc)(Arg1, Arg2));

not1 은 unary_function 의 negate 이며, not2 는 binary_function 의 negate 이다.

template&lt;class UnaryPredicate&gt;
unary_negate&lt;UnaryPredicate&gt; not1(
const UnaryPredicate&amp; _Pred
);

template&lt;class Predicate&gt;
class unary_negate
: public unary_function&lt;
typename Predicate::argument_type,
bool&gt;
{
public:
explicit unary_negate(
const Predicate&amp; _Func
);
bool operator()(
const typename Predicate::argument_type&amp; _Left ) const;
};

template&lt;class BinaryPredicate&gt;
binary_negate&lt;BinaryPredicate&gt; not2(
const BinaryPredicate&amp; _Func
);

template&lt;class Operation&gt;
class binary_negate
: public binary_function &lt;
typename Operation::first_argument_type,
typename Operation::second_argument_type,
bool&gt;
{
public:
explicit binary_negate(
const Operation&amp; _Func
);
bool operator()(
const typename Operation::first_argument_type&amp; _Left,
const typename Operation::second_argument_type&amp; _Right
) const;
};
</code></pre>

<p>그럼 그동안 배운 것을 토대로 다음 MSDN 샘플을 살펴보자.</p>
<p>not1( bind2nd( ptr_fun(strcmp), "pearly" ) )</p>
<p>만약 1초만에 strcmp(X,"pearly")==0 임을 인지해 냈다면 당신은 STL의 고수... ㅠㅠ</p>
<h2>mem_fun vs. mem_fun_ref</h2>
<p>EffectiveSTL 에도 나오는 이야기이니, 책을 가지신 분은 43 아이템을 참고하라.</p>
<p>나를 비롯한 대부분의 프로그래머들은 이런 코드를 사랑한다.</p>
<p>for ( list<GameObject*>::iterator itr = gameObjects.begin() ; itr != gameObjects.end() ; itr ++ )<br />
{<br />
GameObject * pObject = *itr;<br />
__ASSERT(pObject!=NULL); /// be a paranoid!!!<br />
pObject-&gt;Update();<br />
}</p>
<p>너무나도 직관적인 코드이지만, 사실 mem_fun 을 사용하면 한 줄로 해결이 가능하다.</p>
<p>for_each( gameObjects.begin(), gameObject.end(), mem_fun(&amp;GameObject::Update) );</p>
<p>코드는 간단해졌지만 익숙하지 않은 관계로 팀원들이 싫어할 지도 모른다. 그러나, 타이핑하는 글자수도 적으면서 성능도 훨씬 더 좋다는데... 그 누가 안 쓸수 있으랴? (대신 디버깅할 때에는 멤버함수에다가 breakpoint 를 걸어야 하는 단점이 있을 수도 있다 <img alt=";)" src="http://boxcatstudio.files.wordpress.com/2009/07/icon_wink.gif" />  )</p>
<p>포인터의 컨테이너일 경우에는 mem_fun 을, 객체의 컨테이너라면 mem_fun_ref 를 사용하면 된다. 만약 멤버함수에 파라미터를 넘겨야 한다면, 아래와 같이 bind 함수를 사용할 것.</p>
<p>for_each( gameObjects.begin(), gameObject.end(), bind2nd( mem_fun(&amp;GameObject::SetHP),100) );</p>
<h2>bind1st vs. bind2nd</h2>
<p>우선 bind 함수를 알아보기에 앞서, unary_function 과 binary_function 에 대해서 알아보자. 이들은 단지 파라미터와 리턴타입에 대한 typedef 만을 담는 template structure 일 뿐이다. 즉 이들은 혼자서는 아무런 기능도 하지 않지만, 이를 상속받은 하위 클래스에서 타입 정보를 적절히 참조하기 좋도록 디자인된 베이스 클래스라는 뜻이다.</p>
<p>template<class Arg, class Result><br />
struct unary_function {<br />
typedef Arg argument_type;<br />
typedef Result result_type;<br />
};</p>
<p>template<class Arg1, class Arg2, class Result><br />
struct binary_function {<br />
typedef Arg1 first_argument_type;<br />
typedef Arg2 second_argument_type;<br />
typedef Result result_type;<br />
};</p>
<p>기본적으로 STL 알고리즘에서 사용되는 Predicate 등의 함수들은 unary_function 의 형태를 띄어야 한다. 쉽게 말하면, find(), for_each(), count() 의 마지막 인자가 해당 컨테이너 내부의 객체 하나만을 인자로 받는 함수 객체라는 뜻이다.</p>
<p>가령 list<int> 에서 10보다 큰 객체를 찾으려면 대략 다음과 같은 predicate 을 작성해야 한다.</p>
<p>class GreaterThan10<br />
{<br />
public :<br />
bool operator() ( int i ) { return i&gt;= 10; }<br />
};</p>
<p>사실 이렇게 짜면 너무 코드가 범용적이지 못하므로, 대부분의 경우에는 이렇게 구현할 것이다.</p>
<p>class GreaterThanN<br />
{<br />
public :<br />
GreaterThenN( int N ) : m_N(N) {}<br />
bool operator() ( int i ) { return i&gt;= m_N; }<br />
private :<br />
int m_N;<br />
};</p>
<p>이걸 STL 적인 생각으로 다시 구현한 것이 바로 bind 함수들이다. bindN(A,B) 은 binary_function A 의 N 번째 파라미터로 parameter B 을 바인딩해서, unary_function 을 만들어주는 놈이다. 얘네들을 잘 활용하면 단순 함수들은 간단히 한줄로 구현할 수 있게 된다.</p>
<pre><code>- bind1st( BINARY_FUNC, PARAM ) : PARAM 을 BINARY_FUNC의 1st 파라미터로 바인딩한다.

- ex&gt; bind1st( greater, 10 ) --&gt; 10 &gt; N

- bind2nd( BINARY_FUNC, PARAM ) : PARAM 을 BINARY_FUNC의 2nd 파라미터로 바인딩한다.

- bind2nd( greater, 10 ) --&gt; N &gt; 10
</code></pre>
<p>bind1st( greater, 10 ) 이 어떻게 10 &gt; N 이라는 함수로 바뀌는지 자세히 살펴본다면...</p>
<pre><code>- greater는 binary_function 이다.
</code></pre>
<p>template<class Type><br />
struct greater : public binary_function <Type, Type, bool><br />
{<br />
bool operator()(<br />
const Type&amp; _Left,<br />
const Type&amp; _Right<br />
) const;<br />
};</p>
<pre><code>- bind1st(A,B) 는 binder1st 객체를 리턴한다.
</code></pre>
<p>template<class Operation, class Type><br />
binder1st <Operation> bind1st(<br />
const Operation&amp; _Func,<br />
const Type&amp; _Left<br />
);</p>
<pre><code>- binder1st&lt;A&gt; 는 A의 두번째 파라미터를 파라미터로 받고, A의 리턴값을 리턴하는 함수 객체이다. 이때 이 클래스의 생성자의 인자 목록을 유심히 살펴보면, binary_function 하나와 이놈의 하나의 파라미터는 받고 있다. (나머지 하나는 당연히 container 에서 받게 된다.)
</code></pre>
<dl>
<dt>template<class Operation></dt>
<dt>class binder1st</dt>
<dd>public unary_function &lt;<br />
typename Operation::second_argument_type,<br />
typename Operation::result_type&gt;<br />
{<br />
public:<br />
typedef typename Operation::second_argument_type argument_type;<br />
typedef typename Operation::result_type result_type;<br />
binder1st(<br />
const Operation &amp; _Func,<br />
const typename Operation::first_argument_type&amp; _Left<br />
);<br />
result_type operator()(<br />
const argument_type&amp; _Right<br />
);<br />
result_type operator()(<br />
const argument_type&amp; _Right<br />
) const;<br />
protected:<br />
Operation op;<br />
typename Operation::first_argument_type value;<br />
};</dd>
</dl>
<h2>SafeDeleter</h2>
<p>템플릿 클래스 버전을 사용할 경우, 매번마다 타입을 지정해줘야 하지만, 템플릿 멤버함수 버전을 사용하면 타입 없이도 사용할 수 있다. 아직까지 이걸 몰랐다니.. ㅠㅠ 쑥갓군 땡큐~</p>
<p>/// template class version<br />
template <class T><br />
class SafeDeleter<br />
{<br />
public :<br />
void operator () ( T * &amp; ptr ) const<br />
{<br />
SAFE_DELETE(ptr);<br />
}<br />
};</p>
<p>for_each( a.begin(), a.end(), SafeDeleter<A>() );</p>
<p>/// template member function version<br />
class SafeDeleter2<br />
{<br />
public :<br />
template <class T><br />
void operator () ( T * &amp; ptr ) const<br />
{<br />
SAFE_DELETE(ptr);<br />
}<br />
};</p>
<p>for_each( a.begin(), a.end(), SafeDeleter2() );</p>
<h2>Static Key vs. Dynamic Key</h2>
<p>class Object<br />
{<br />
KeyType_t Key;<br />
....;<br />
};<br />
map<KeyType_t,Obj*> orderedObjects;</p>
<p>위와 같이 객체의 특정 필드의 값으로 정렬된 map이 있다고 하자. 일단 map에 객체를 넣고 난 다음에 Key 값을 변경하면 map 내부의 트리가 깨지므로 바꿔서는 곤란해진다. 그러나, 때로는 Key 값이 바뀌어야 할 필요가 있다. 언제나 실시간으로 바꿔주려면 map 에서 객체를 빼낸 다음 Key 값을 바꾸고 다시 넣어야 하는데, 항상 넣었다 뺐다 하기에는 성능적인 부분이 걱정되는데...</p>
<p>이럴 경우에는 외부에서 필요할 때마다 새로운 키를 저장한 다음, 적당히 바꿀 타이밍이 되면 객체를 map 에서 빼낸 다음 키값을 업데이트해주면 된다. 특히 아래와 같이, 정적인 메인 키의 맵으로 구성된 객체의 매니저가 내부에 특정 순서로 정렬된 서브 키의 맵을 가진 경우, 위와 같은 패턴을 사용하면 꽤 편하다.</p>
<p>class Object<br />
{<br />
StaticKeyType_t MainKey;<br />
DynamicKeyType_t SubKey;<br />
DynamicKeyType_t NewSubKey;<br />
....;<br />
};</p>
<p>class ObjectManager : public map<StaticKeyType_t,Object*><br />
{<br />
map<DynamicKeyType_t,Object*> orderedObjects;<br />
void ChangeSubKey( StaticKeyType_t mainKey, DynamicKeyType_t newSubKey );<br />
void UpdateSubMap();<br />
};</p>
<p><strong>어쨌든, map 의 키값을 외부에서 바꿨다가는 큰 낭패를 볼 것이다.</strong></p>
<p>see also:</p>
<pre><code>- [Boost Multi-index Containers Library](http://boost.org/libs/multi_index/doc/index.html)
</code></pre>
<h2>multixxx::erase(key_type)</h2>
<p>일반적인 erase()는 iterator/const_iterator 를 파라미터로 받아서 그 넘을 지우는 역할을 한다. 그런데, multimap/multiset 에서는 key_type 만 넘겨서 해당 값을 지우는 메쏘드를 제공한다. 대체로 이는 잘 동작하지만 predicate 가 명시된 multimap/multiset 에서는 생각대로 동작하지 않는다. 다음 예를 보자.</p>
<p>class TeamInfo<br />
{<br />
public :<br />
TeamInfo ( int point = 0 )  : TeamPoint(point) {}<br />
int TeamPoint;<br />
};</p>
<p>class GreaterTeam<br />
{<br />
public :<br />
bool operator () (const TeamInfo<em> l, const TeamInfo</em> r) const<br />
{<br />
return l-&gt;TeamPoint&gt; r-&gt;TeamPoint;<br />
}<br />
};</p>
<p>void<br />
test_multiset()<br />
{<br />
typedef multiset<TeamInfo*,GreaterTeam> TEAMS;</p>
<p>TEAMS teams;</p>
<p>TeamInfo t1(1);<br />
TeamInfo t2(1);<br />
TeamInfo t3(0);<br />
TeamInfo t4(2);</p>
<p>teams.insert( &amp;t1 );<br />
teams.insert( &amp;t2 );<br />
teams.insert( &amp;t3 );<br />
teams.insert( &amp;t4 );</p>
<p>// erase by key test <br />
teams.erase( &amp;t4 ); assert( teams.size() == 3 );<br />
teams.erase( &amp;t1 ); assert( teams.size() == 1 );  // t1 과 t2 를 지운다. 낭패~</p>
<p>// erase with iterator test<br />
teams.clear();<br />
teams.insert( &amp;t1 );<br />
teams.insert( &amp;t2 );<br />
teams.insert( &amp;t3 );<br />
teams.insert( &amp;t4 );</p>
<p>pair<TEAMS::iterator,TEAMS::iterator> itrs = teams.equal_range(&amp;t1);<br />
teams.erase( find( itrs.first, itrs.second, &amp;t1 ) );<br />
assert( teams.size() == 3 );</p>
<p>assert( <em>(teams.find(&amp;t1)) == &amp;t2 ); // t1 을 찾으면 t2 가 나온다는 놀라운 사실!<br />
assert( </em>(teams.find(&amp;t2)) == &amp;t2 );<br />
assert( <em>(teams.find(&amp;t3)) == &amp;t3 );<br />
assert( </em>(teams.find(&amp;t4)) == &amp;t4 );<br />
}</p>
<p>여기서 배울 수 있는 교훈은</p>
<pre><code>- 코드상으로는 equal_range(&amp;t1)이라는 것이 t1을 찾는 것처럼 보이지만, 실제로는 key_type과 무관하며 오직 predicate 를 이용해서 검색을 한다!
- multi 시리즈에서는 find()나 erase()에 있어서 항상 동일한 값이 존재할 수 있다!
- predicate 의 비교문에서 &gt;= 을 사용하면 다른 결과가 나온다!
- predicate 관련 변수(m_TeamPoint)와 같이, 비교 로직에 영향을 주는 무언가를 외부에서 바꾸게 되면 multixxx 내부의 트리가 깨지게 된다. 너무나 당연한 사실이지만, Key 를 바꾸는게 아니라서 안전할 거 같아 보이는 것도 사실이다. 이를 방지하려면 일단 container 에서 해당 값을 erase한 다음 값을 수정하고 다시 insert 하는 것을 권장한다.
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/06/01/queueuserworkitem/">QueueUserWorkItem()</a> <small>2006-06-01</small></h1>
	</div>
	<div><p>Windows 에서 제공하는 ThreadPooling API인 QueueUserWorkItem()에 대해서 알아보자.</p>
<h2>QueueUserWorkItem()</h2>
<p>Programming Application for Microsoft Windows 에 의하면 ThreadPooling 시 새로운 쓰레드가 추가되기 위한 factor 에는 아래와 같은 것이 있다.</p>
<ul>
<li>쓰레드가 추가된 지 몇 초가 지나면, 한번 고민해본다</li>
<li>WT_EXECUTELONGFUNCTION 이 사용될 경우, 한번 고민해본다</li>
<li>큐잉된 작업의 개수가 일정 threadhold 를 넘어설 경우, 한번 고민해본다.</li>
</ul>
<p>그러나, 상세한 파라미터는 알려져 있지 않아서.. 테스트를 해 보았다.</p>
<pre><code>
const int MAX_WORK = 1000;
LONG WorkCounter = 0;
int add_time = 1;
int work_time = 10;
int nloop = 1;
bool bPreQueue = false;
int pre_queue_time = 1000;
bool bMiddleSleep = false;
int middle_sleep_time = 1000;

DWORD WINAPI MyWorkThreadProc(PVOID pParam)
{
    MyWork* pWork = (MyWork*)pParam;

    Sleep(pWork-&gt;workTime);

    pWork-&gt;threadID = ::GetCurrentThreadId();
    pWork-&gt;output = pWork-&gt;input * 2;

    InterlockedIncrement( &amp;WorkCounter );

    return 0;
}

void
thread_pool_test_fixture::test_really_pooling()
{
    for ( int k = 0 ; k  0 )
            {
                Sleep(pre_queue_time);
            }
        }

        MyWork works[MAX_WORK];
        for (int i=0; i 0 )
            {
                Sleep(add_time);
            }

            if ( i == 500 &amp;&amp; bMiddleSleep &amp;&amp; middle_sleep_time &gt; 0 )
            {
                Sleep( middle_sleep_time );
            }
        }

        while ( WorkCounter  threads;
        for (int i=0; i::iterator itr = threads.begin() ; itr != threads.end() ; itr ++ )
        {
            BOOST_MESSAGE( *itr  처리 시간 |
| 10 | 10 | 1  | 큐잉되는 시간 == 처리 시간 |
| 10 | 20 | 3  | 큐잉되는 시간
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/05/28/boostis_base_of/">boost::is_base_of</a> <small>2006-05-28</small></h1>
	</div>
	<div><p>템플릿 프로그래밍을 하다 보면, 문자열이나 사용자 정의 클래스(UDT) 같은 특정 타입에 대한 특수화(specializaiton)를 할 경우가 있다. 그 중에서 가장 헷갈리는 부분이 바로 특정 클래스의 포인터를 템플릿 인자로 받아서 특수화해야 하는 경우인데, boost typetraits 중 하나인 boost::is_base_of를 사용하면 손쉽게 해결할 수 있다.</p>
<pre><code>
template
void old_algorithm ( const T &amp; value )
{
  // do generic something
}
</code></pre>

<p>위와 같은 함수 템플릿에 대해서 Base 클래스의 하위 클래스 포인터를 받았을 때를 위한 특수화를 해야 할 경우, 다음과 같은 패턴을 사용하라. 핵심은 is_base_of::type 이 true_type 또는 false_type 이라는 2 개의 서로 다른 타입을 리턴하며, 이 값을 이용해서 특수화를 한다는 것이다.</p>
<pre><code>
template
void new_algorithm ( const T &amp; value )
{
  typedef typename boost::is_base_of::type is_derived_class;

  // call impl
  new_algorithm_impl(value,is_derived_class());
}

template
void new_algorithm_impl ( const T &amp; value, const boost::true_type&amp; )
{
  // do specialized for Base class
}

template
void new_algorithm_impl ( const T &amp; value, const boost::false_type&amp; )
{
  // do generic something
}

</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2006/05/25/boostany/">boost::any</a> <small>2006-05-25</small></h1>
	</div>
	<div><p>게임 개발을 하다 보면, 가끔 서로 다른 타입의 객체들을 하나의 컨테이너에서 다루어야 할 때가 있다. 만약 이 컨테이너로 하는 일이 간단하다면야 인터페이스 상속을 쓰면 되지만, 상속을 할 수 없을 정도로 타입이 다를 때도 있다. 이럴 때 사용하는 것이 바로 boost::any 클래스이다.</p>
<p>boost::any는 이름 그대로 어떤(any) 것도 담을 수 있는 클래스로, void * 와 비슷한 역할을 한다. (더욱 자세한 설명은 <a href="http://boost.org/doc/html/any.html">boost 온라인 매뉴얼</a>을 참고)</p>
<p>이번에 boost::any 의 코드를 참조해서 작업을 하다 보니 몇 가지 장단점들이 눈에 띄었다.</p>
<ul>
<li>미리 any 의 내부값의 타입을 파악하고 있어야 한다. 즉, type() 을 이용해서 if-else 방식으로 비교하는 수 밖에 없다.</li>
<li>any_cast(value) 는 생각보다 타이핑하기가 귀찮다. 꺽쇠와 괄호를 다 타이핑한다고 생각해보라...</li>
<li>디버깅시 any 내부의 placeholder 에 들어 있는 값을 찾기가 곤란하다.</li>
</ul>
<p>이번 주는 영식군이 한 달 동안 쇼핑하면서 작업한 <a href="http://reiot.cafe24.com/archives/395">객체 복제 프레임워크</a>를 이틀 동안 인수인계 받은 후, 복제의 최소 단위인 replication value 클래스를 boost::any 의 코드를 참조해서 고치고 있다. 미리 2000라인 정도의 테스트 코드를 만들어둔 덕택에 <del datetime="2006-05-25T14:14:00+00:00">코드 학습</del> 리팩토링이 겨우 4일 만에 거의 끝낼 수 있었다. 물론 영식군이 계속 지나가면서 어차피 기능이 똑같다면 왜 사서 삽질을 하냐고 갈구고 있지만 그냥 못들은 척하고 중이다. 흐흐.</p></div>
	
</article>
			
			<ul class="pager">
			
			  	<li class="previous">
			    	<a href="/page/31/">&larr; Older</a>
			  	</li>
		  	
		  	
				<li class="next">
					<a href="/page/31">Newer &rarr;</a>
				</li>
		  	
			</ul>
		</div>
		<div class="span3">
			<ul class="nav nav-list well">
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2006/06/04/ole-db-tips/">OLE DB Tips</a>
	</li>
	
	<li>
		<a href="/2006/06/01/stl-tips/">STL Tips</a>
	</li>
	
	<li>
		<a href="/2006/06/01/queueuserworkitem/">QueueUserWorkItem()</a>
	</li>
	
	<li>
		<a href="/2006/05/28/boostis_base_of/">boost::is_base_of</a>
	</li>
	
	<li>
		<a href="/2006/05/25/boostany/">boost::any</a>
	</li>
	
</ul>
		</div>
	</div>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
	

  </body>
</html>