<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Social Game Developer wandering strange dungeon...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	<div class="row">
		<div class="span9">
			
				<article>
	<div class="page-header">
		<h1><a href="/2008/02/18/getting-real/">Getting Real</a> <small>2008-02-18</small></h1>
	</div>
	<div><p><a href="http://gettingreal.37signals.com/GR_kor.php">Getting Real</a>은 단지 웹개발에 대한 지침이기도 하지만, 쌓여 있는 버그와 뒤죽박죽한 요구 사항 속에서 고민하는 게임 개발자에게도 꽤 유익한 내용이다. 가끔씩 길을 잘못 들고 있지 않을까 하는 불안감이 들 때마다 읽어봐야겠다.<br />
```<br />
<strong>"혁신은 '아니오' 에서 시작된다."</strong></p>
<p>[혁신]은 1000가지 일에 대해서 '아니오'라고 말하므로써 잘못된 길을 가거나 불필요하게 너무 많은 일을 하지 않도록 하는 것에서 시작됩니다. 우리는 항상 새롭게 진입가능한 시장에 대해서 고민합니다. 하지만 그것은 과감히 '아니오'라고 말하므로써 실질적으로 중요한 일들에 대해서만 집중할 수 있을 때 가능합니다.<br />
<cite>—Steve Jobs, CEO, <a href="http://www.apple.com/">Apple</a> (from <a href="http://www.businessweek.com/bwdaily/dnflash/oct2004/nf20041012_4018_db083.htm">The Seed of Apple's Innovation</a>)<br />
</cite></p>
<p><strong>"천 개의 기능은 필요하지 않습니다."</strong></p>
<p>스티브 잡스가 아이튠즈에 대해서 독립음반회사 사람들을 모아놓고 조그만 발표를 했습니다. 그 날 많은 사람들은 쉴 새없이 손을 들면서 어떤 기능이 제공되는 지, 혹은 어떤 기능을 추가할 계획이 있는 지 물었습니다. 마침내 쟙스가 말했습니다. "잠깐만요. 손을 잠시 내리고 제 말을 들어보시죠. 저는 여러분이 아이튠즈에 있으면 좋을 만한 아이디어를 수 천개 가지고 있다는 것을 잘압니다. 하지만 우리는 수 천개의 기능을 원하지 않습니다. 그렇게 하면 엉망이 될 겁니다. 혁신은 모든 것에 대해서 '예'라고 말하는 것이 아닙니다. 혁신은 정말 중요한 것을 제외한 나머지에 대해서는 '아니오'라고 말하는 것입니다."</p>
<p><cite>—Derek Sivers, 대표 및 프로그래머, <a href="http://www.cdbaby.com/">CD Baby</a>  and <a href="http://www.hostbaby.com/">HostBaby</a></cite><cite>(from <a href="http://www.oreillynet.com/onlamp/blog/2004/08/say_no_by_default.html">Say NO by default</a>)</cite>```<br />
그러고 보면  헛똑똑이질을 하다가 매번 revert를 하다가 저런 글을 보고 뉘우치곤 하는 나보다, 이런 류의 글따위는 한번도 읽어보진 않아도 뭐가 중요한지 몸으로 깨닫고 있는 모군이 2g 정도 대견스럽긴 하다. ㅋㅋ</p></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2008/02/10/boost-serialization/">boost::serialization</a> <small>2008-02-10</small></h1>
	</div>
	<div><p>boost::serialization 은, 템플릿 멤버 함수 하나 또는 free function 하나만 정의하면, 해당 클래스를 다양한 스트림으로 직렬화할 수 있게 해준다. 특히 list - vector - map - set 등의 다양한 STL 컨테이너들을 지원한다는 것이 장점이다.</p>
<p>이때, 매크로 없이 &amp; 연산자 만으로 읽고 쓰기를 가능하게 했는데, 이건 템플릿 아카이브 파라미터가 알아서 잘 읽거나 쓰도록 책임을 전가했다는 게 상당히 아름답다.. 단, virtual 이 아니라서 하위 클래스는 모두 이걸 정의해줘야 한다. 그리고 아직 hash_map 은 잘 지원하지 않는 모양인데, 뭔가 복잡한 사정이 있는 듯하다.</p>
<p>주의할 점이라면 아래 예제처럼 쓰려는 객체가 const 여야 한다는 점 정도?</p>
<pre><code>
#include &quot;stdafx.h&quot;

#include &lt;fstream&gt;

#include &lt;boost/archive/text_oarchive.hpp&gt;
#include &lt;boost/archive/text_iarchive.hpp&gt;

#include &lt;boost/archive/binary_oarchive.hpp&gt;
#include &lt;boost/archive/binary_iarchive.hpp&gt;

#include &lt;boost/serialization/list.hpp&gt;
#include &lt;boost/serialization/vector.hpp&gt;
#include &lt;boost/serialization/map.hpp&gt;
#include &lt;boost/serialization/hash_map.hpp&gt;

class chat_message
{
    friend class boost::serialization::access;
public:

    chat_message() {}

    chat_message(unsigned short id, unsigned short body_length, string msg, wstring wmsg)
        : id_(id)
        , body_length_(body_length)
        , message(msg)
        , wmessage(wmsg)
    {
        for ( size_t i = 0 ; i &lt; 10 ; i ++ )
        {
            string val = boost::str(boost::format(&quot;Hello %1%&quot;)%i);
            messages[i] = val;
            array_[i] = val;
            list_.push_back(i);
            vector_.push_back(i);
            map_[i] = val;
            hash_map_[val] = (rand()%2==0 ? true : false);
        }
    }

    template&lt;class Archive&gt;
    void serialize(Archive &amp; ar, const unsigned int version)
    {
        ar &amp; id_;
        ar &amp; body_length_;
        ar &amp; message;
        ar &amp; wmessage;
        ar &amp; messages;          // pritimive array
        ar &amp; array_.elems;      // boost::array
        ar &amp; list_;             // std::list
        ar &amp; vector_;           // std::vector
        ar &amp; map_;              // std::map
        //ar &amp; hash_map_;
    }

    void check_equal( const chat_message &amp; r ) const
    {
        BOOST_CHECK_EQUAL(id_,r.id_);
        BOOST_CHECK_EQUAL(body_length_,r.body_length_);
        BOOST_CHECK_EQUAL(message,r.message);
        BOOST_CHECK(wmessage==r.wmessage);

        for ( size_t i = 0 ; i &lt; 10 ; i ++ )
        {
            BOOST_CHECK_EQUAL(messages[i],r.messages[i]);
        }

        for ( size_t i = 0 ; i &lt; array_.size() ; i ++ )
        {
            BOOST_CHECK_EQUAL(array_[i],r.array_[i]);
        }

        {
            BOOST_REQUIRE_EQUAL( list_.size(), r.list_.size() );
            list&lt;float&gt;::const_iterator itr = list_.begin();
            list&lt;float&gt;::const_iterator itr2 = r.list_.begin();
            for ( ; itr != list_.end() ; itr ++, itr2++ )
            {
                BOOST_CHECK_EQUAL( *itr, *itr2 );
            }
        }

        {
            BOOST_REQUIRE_EQUAL( vector_.size(), r.vector_.size() );
            vector&lt;int&gt;::const_iterator itr = vector_.begin();
            vector&lt;int&gt;::const_iterator itr2 = r.vector_.begin();
            for ( ; itr != vector_.end() ; itr ++, itr2++ )
            {
                BOOST_CHECK_EQUAL( *itr, *itr2 );
            }
        }

        {
            BOOST_REQUIRE_EQUAL( map_.size(), r.map_.size() );
            map&lt;int,string&gt;::const_iterator itr = map_.begin();
            map&lt;int,string&gt;::const_iterator itr2 = r.map_.begin();
            for ( ; itr != map_.end() ; itr ++, itr2++ )
            {
                BOOST_CHECK_EQUAL( itr-&gt;first, itr2-&gt;first );
                BOOST_CHECK_EQUAL( itr-&gt;second, itr2-&gt;second );
            }
        }

        //{
        //  BOOST_REQUIRE_EQUAL( hash_map_.size(), r.hash_map_.size() );
        //  stdext::hash_map&lt;string,bool&gt;::const_iterator itr = hash_map_.begin();
        //  stdext::hash_map&lt;string,bool&gt;::const_iterator itr2 = r.hash_map_.begin();
        //  for ( ; itr != hash_map_.end() ; itr ++, itr2++ )
        //  {
        //      BOOST_CHECK_EQUAL( itr-&gt;first, itr2-&gt;first );
        //      BOOST_CHECK_EQUAL( itr-&gt;second, itr2-&gt;second );
        //  }
        //}
    }
private :
    unsigned short id_;
    unsigned short body_length_;
    string message;
    wstring wmessage;
    string messages[10];
    boost::array&lt;string,10&gt; array_;
    list&lt;float&gt; list_;
    vector&lt;int&gt; vector_;
    map&lt;int,string&gt; map_;
    stdext::hash_map&lt;string,bool&gt; hash_map_;
};

// TODO
// - archive from/to buffer
// - user defined archive
// - string, wstring load/save
// - stl support (list,vector,map)

BOOST_AUTO_TEST_CASE(test_serialize)
{
    const chat_message msg1(35, 59, &quot;Hello World!&quot;,L&quot;Welcome!&quot;);

    {
        chat_message msg2;

        std::ofstream ofs(&quot;serialize.txt&quot;);
        boost::archive::text_oarchive oa(ofs);
        oa &lt;&lt; msg1;
        ofs.close();

        std::ifstream ifs(&quot;serialize.txt&quot;);
        boost::archive::text_iarchive ia(ifs);
        ia &gt;&gt; msg2;
        ifs.close();

        msg1.check_equal(msg2);
    }

    {
        chat_message msg2;

        std::ofstream ofs(&quot;serialize.bin&quot;, std::ios::binary);
        boost::archive::binary_oarchive oa(ofs);
        oa &lt;&lt; msg1;
        ofs.close();

        std::ifstream ifs(&quot;serialize.bin&quot;, std::ios::binary);
        boost::archive::binary_iarchive ia(ifs);
        ia &gt;&gt; msg2;
        ifs.close();

        msg1.check_equal(msg2);
    }

    {
        chat_message msg2;

        boost::asio::streambuf buf;
        ostream os(&amp;buf);
        boost::archive::text_oarchive oa(os);
        oa &lt;&lt; msg1;

        istream is(&amp;buf);
        boost::archive::text_iarchive ia(is);
        ia &gt;&gt; msg2;

        msg1.check_equal(msg2);
    }

    {
        chat_message msg2;

        boost::asio::streambuf osf;
        boost::archive::binary_oarchive oa(osf);
        oa &lt;&lt; msg1;

        boost::archive::binary_iarchive ia(osf);
        ia &gt;&gt; msg2;

        msg1.check_equal(msg2);
    }

    // via istream/ostream
    {
        chat_message msg2;

        boost::asio::streambuf buf;
        ostream os(&amp;buf);
        boost::archive::binary_oarchive oa(os);
        oa &lt;&lt; msg1;

        istream is(&amp;buf);
        boost::archive::binary_iarchive ia(is);
        ia &gt;&gt; msg2;

        msg1.check_equal(msg2);
    }

}
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2008/02/09/boost_asio_iostream/">boost::asio iostream</a> <small>2008-02-09</small></h1>
	</div>
	<div><p>문자열 기반의 네트워크 입출력 프로그래밍을 해야 한다면, ASIO 의 iostream 을 사용하면 간단히 해결된다.</p>
<p>boost::asio::io_service 같이 모호한 객체 선언도 필요없고, 연결 관리나 버퍼링 같은 개념도 적당히 무시할 수 있어서, 예외 처리만 잘 한다면 원격 로그라든지 XML RPC  클라이언트 같은 곳에 써먹을 수 있을 것 같다.</p>
<p>만약 복잡한 문자열 조작이 필요하다면 boost::string_algo 정도면 충분하고, 정규식이 필요하면 boost::regexp 을 가져다 사용하면 될 듯하다.</p>
<!--more-->

<pre><code>
// 문자열 기반의 네트워크 입출력 스트림
BOOST_AUTO_TEST_CASE( test_iostream )
{
    string http_request =
        &quot;GET / HTTP/1.0\r\n&quot;
        &quot;Host: reiot.cafe24.com\r\n\r\n&quot;;
    string expected_http_response[] = { &quot;HTTP/1.0 200 OK&quot;, &quot;HTTP/1.1 200 OK&quot; };

    {

        tcp::iostream io_(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);

        io_    &lt;&lt; http_request &lt;&lt; flush;    // or io_.flush();

        vector&lt;string&gt; http_response;
        while ( !io_.eof() )
        {
            string line;
            getline(io_,line);
            http_response.push_back(line);
        }

        BOOST_CHECK_EQUAL( boost::trim_copy(http_response[0]), expected_http_response[1] );

        io_.close();
    }

    {
        string host = &quot;www.google.co.kr&quot;;
        tcp::iostream io_(host,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/&quot; &lt;&lt; 1 &lt;&lt; &quot;.&quot; &lt;&lt; 0 &lt;&lt; endl
            &lt;&lt; &quot;Host: &quot; &lt;&lt; host &lt;&lt; endl &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        vector&lt;string&gt; http_response;
        while ( !io_.eof() )
        {
            string line;
            getline(io_,line);
            http_response.push_back(line);
        }

        BOOST_CHECK_EQUAL( boost::trim_copy(http_response[0]), expected_http_response[0] );
    }

    {
        tcp::iostream io_(&quot;www.naver.com&quot;,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/1.0&quot; &lt;&lt; endl
            &lt;&lt; &quot;Host: www.naver.com&quot; &lt;&lt; endl
            &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        stringstream response;
        while ( !io_.eof() )
        {
            char ch = io_.get();
            response &lt;&lt; ch;
        }

        string line;
        getline(response,line);
        BOOST_CHECK_EQUAL( boost::trim_copy(line), expected_http_response[1] );
    }

    {
        tcp::iostream io_(&quot;clien.career.co.kr&quot;,&quot;http&quot;);

        io_    &lt;&lt; &quot;GET / HTTP/1.0&quot; &lt;&lt; endl
            &lt;&lt; &quot;Host: clien.career.co.kr&quot; &lt;&lt; endl
            &lt;&lt; endl
            &lt;&lt; flush;    // or io_.flush();

        stringstream response;
        while ( !io_.eof() )
        {
            char buf[128];
            io_.read(buf,127);
            size_t nread = io_.gcount();
            if ( nread &gt; 0 )
            {
                buf[nread] = 0;
                response &lt;&lt; buf;               
            }
        }

        string line;
        getline(response,line);
        BOOST_CHECK_EQUAL( boost::trim_copy(line), expected_http_response[1] );
    }
}

</code></pre></div>
	
	<p>
	
		<a href="/tag/ASIO/"><span class="label">ASIO</span></a>
	
		<a href="/tag/boost/"><span class="label">boost</span></a>
	
	</p>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2008/02/09/boost-test-thread-safe/">boost::test thread safe</a> <small>2008-02-09</small></h1>
	</div>
	<div><p>다른 표준 라이브러리와 마찬가지로, boost::test 역시 멀티쓰레드에 대해서 안전하지 않다. 물론 BOOST_CHECK 등의 테스트 매크로들은 내부적으로 싱글톤을 사용하기 때문에, 쓰레드 함수 내부에서 사용하더라도 실패할 경우 에러 메시지를 출력해주지만, 다른 쓰레드에서 동일한 순간에 역시 같은 매크로를 호출하게 되면 콜스택 깊은 곳에서 난감한 에러를 뱉어버린다.</p>
<p>이걸 해결하려면 결국 mutex 로 테스트 매크로들을 wrap 한 또다른 매크로를 만들어서 써야 하는 수 밖에 없다.</p>
<pre><code>
#define SAFE_BOOST_CHECK_EQUAL(m,x,y) { \
boost::mutex::scoped_lock lock(m); \
BOOST_CHECK_EQUAL(x,y); }

void boost_check_always( boost::mutex * m )
{
boost::timer timer_;

while(timer_.elapsed() &lt; 10.f )
{
SAFE_BOOST_CHECK_EQUAL(*m,1,1);
}

}

BOOST_AUTO_TEST_CASE( test_boost_check_always )
{
boost::mutex m;
boost::thread t(boost::bind(boost_check_always,&amp;m));

boost::timer timer_;
while(timer_.elapsed() &lt; 10.f )
{
SAFE_BOOST_CHECK_EQUAL(m,1,1);
}

t.join();
}
</code></pre></div>
	
</article>
			
				<article>
	<div class="page-header">
		<h1><a href="/2008/02/04/boostasio-tcp-resolver/">boost::asio TCP resolver</a> <small>2008-02-04</small></h1>
	</div>
	<div><p>한가로운 주말, 최신 BOOST 를 vc81로 빌드하고 <a href="http://asio.sourceforge.net/">ASIO</a>를 만지작거려 봤다. 대충 훑어본 바, 이 정도면 지금 코드에서 충분히 ACE를 제거해도 될 수준의 기능인 듯하다. 어차피 둘 다 디버깅 들어가면 템플릿 사이에서 헤매이는 건 마찬가지니...</p>
<!--more-->

<pre><code>
// TODO multiple ip address in localmachine (..localmachine)
BOOST_AUTO_TEST_CASE( test_resolver )
{
 boost::asio::io_service io_service;
 boost::system::error_code error;
 tcp::resolver resolver(io_service);
 tcp::resolver::iterator end_;

 // localmachine
 {
  tcp::resolver::query query(boost::asio::ip::host_name(),&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;192.168.10.101&quot; );
 }

 // host -&gt; ip
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
 }

 // localhost
 {
  tcp::resolver::query query(&quot;localhost&quot;,&quot;&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;127.0.0.1&quot; );
  if ( ++iterator != end_ )
  {
   _endpoint = *iterator;
   BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;192.168.10.101&quot; );
  }
 }

 // http
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 80 );
 }

 // ftp
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;ftp&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 21 );
 }

 // telnet
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;telnet&quot;);
  tcp::resolver::iterator iterator = resolver.resolve(query);
  tcp::endpoint _endpoint = *iterator;
  BOOST_CHECK_EQUAL( _endpoint.address().to_string(), &quot;123.214.172.49&quot; );
  BOOST_CHECK_EQUAL( _endpoint.port(), 23 );
 }

 // unknown host
 {
  tcp::resolver::query query(&quot;reiot1.com&quot;,&quot;&quot;);
  resolver.resolve(query,error);
  BOOST_CHECK_EQUAL( error.value(), boost::asio::error::host_not_found );
 }

 // unknown service
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;test&quot;);
  resolver.resolve(query,error);
  BOOST_CHECK_EQUAL( error.value(), boost::asio::error::service_not_found );
 }
}

void print_address(const boost::system::error_code&amp; e, tcp::resolver::iterator itr )
{
 tcp::endpoint endpoint_ = *itr;
 BOOST_MESSAGE( endpoint_.address() );
}

class AsyncResolveHandler
{
public :
 AsyncResolveHandler( int errorcode ) : address_(&quot;&quot;), port_(0), errorcode_(errorcode) {}
 AsyncResolveHandler( std::string addr, int port = 0 ) : address_(addr), port_(port) {}
 void operator() (const boost::system::error_code&amp; e, tcp::resolver::iterator itr )
 {
  if ( !e )
  {
   tcp::endpoint endpoint_ = *itr;
   BOOST_CHECK_EQUAL( endpoint_.address().to_string(), address_ );
   if ( port_ != 0 )
   {
    BOOST_CHECK_EQUAL( endpoint_.port(), port_ );
   }
  }
  else
  {
   BOOST_CHECK_EQUAL( e.value(), errorcode_ );
  }
 }
 std::string address_;
 int port_;
 int errorcode_;
};

BOOST_AUTO_TEST_CASE( test_async_resolver )
{
 boost::asio::io_service io_service;

 tcp::resolver resolver(io_service);

 boost::system::error_code error;

 // host -&gt; ip
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // localhost -&gt; 127.0.0.1
 {
  tcp::resolver::query query(&quot;localhost&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;127.0.0.1&quot;));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // http
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;http&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,80));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();

 }

 // ftp
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;ftp&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,21));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // telnet
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;telnet&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(&quot;123.214.172.49&quot;,23));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // unknown host
 {
  tcp::resolver::query query(&quot;reiot1.com&quot;,&quot;&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(boost::asio::error::host_not_found));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }

 // unknown service
 {
  tcp::resolver::query query(&quot;reiot.cafe24.com&quot;,&quot;test&quot;);
  resolver.async_resolve(query,AsyncResolveHandler(boost::asio::error::service_not_found));
  BOOST_CHECK_EQUAL(io_service.run_one(error),1);
  BOOST_CHECK_MESSAGE(!error,error.message());
  io_service.reset();
 }
}

</code></pre></div>
	
</article>
			
			<ul class="pager">
			
			  	<li class="previous">
			    	<a href="/page/20/">&larr; Older</a>
			  	</li>
		  	
		  	
				<li class="next">
					<a href="/page/20">Newer &rarr;</a>
				</li>
		  	
			</ul>
		</div>
		<div class="span3">
			<ul class="nav nav-list well">
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2008/02/18/getting-real/">Getting Real</a>
	</li>
	
	<li>
		<a href="/2008/02/10/boost-serialization/">boost::serialization</a>
	</li>
	
	<li>
		<a href="/2008/02/09/boost_asio_iostream/">boost::asio iostream</a>
	</li>
	
	<li>
		<a href="/2008/02/09/boost-test-thread-safe/">boost::test thread safe</a>
	</li>
	
	<li>
		<a href="/2008/02/04/boostasio-tcp-resolver/">boost::asio TCP resolver</a>
	</li>
	
</ul>
		</div>
	</div>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
	

  </body>
</html>