<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="A social game developer wandering strange dungeons...">
	<meta name="author" content="Ray Yun">
  <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="/assets/js/google-code-prettify/prettify.css" rel="stylesheet">
    <link href="/assets/css/droppress.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top navbar-inverse">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
            <form class="navbar-search pull-right">
              <input type="text" class="search-query" placeholder="Title Search">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	

	<div class="row">
		<div class="span9">
			
				<div>
	<div class="page-header">
		<h1><a href="/2012/04/21/250k-node-connections/">Node.js로 25만 동접 만들기</a> <small>2012-04-21</small></h1>
	</div>
	<div><p>via <a href="http://blog.caustik.com/">caustik's blog</a></p>
<h2><a href="http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/">node.js 를 10만 동접으로 스케일링하기</a></h2>
<ul>
<li>10만 동접을 처리하는데 CPU 점유율 40%, (virtual) 메모리 1.4G 를 차지함. 이 정도면 rackspace 2G 클라우드 서버일 경우 시간당 0.1$ 로 가능함.</li>
<li>각 연결은 5초에 한번 메시지를 보냄. 대략 초당 4만개의 JSON 패킷이 보내짐. 응답성도 좋음. </li>
</ul>
<p>이런 성능을 위한 설정은:</p>
<ul>
<li>Nagle 알고리즘을 사용안함: 빠른 응답성을 위해 커널 내부에 네트워크 버퍼링을 사용하지 않고 즉시 보내지도록 함. socket.setNoDelay().</li>
<li>v8의 idle 가비지 컬렉션을 끄기 위해 --nouse-idle-notification 옵션 사용: JS 객체가 2백만개 정도 되면 몇 초마다 가비지 컬렉션 때문에 1초 가까이 랙이 걸림. 실제로 객체들을 순회하는 데만 이 정도의 시간이 소모됨. <br />
[역주] 소스 코드를 보면 --expose_gc 옵션으로 실행해서 gc()를 실행할 수 있게 한 다음, /debug/gc 메시지를 보내서 가비지 컬렉션을 하게 되는데, 이걸 실행하는 순간 랙은 뭘 해도 피할 수 없음. ㅠㅠ </li>
</ul>
<h2><a href="http://blog.caustik.com/2012/04/10/node-js-w250k-concurrent-connections/">node.js 로 25만 동접 만들기</a></h2>
<ol>
<li>
<p>가장 최근 태그된 v8 리비전의 성능이 그나마 낫다.</p>
</li>
<li>
<p>25만 연결은 v8의 1.4기가 힙 메모리 제한 하에서의 최대치. 이 상황에서도 CPU 사용량이나 메모리 사용량이 낮은 걸 본다면, 충분히 더 나아질 수 있을 듯.</p>
</li>
<li>
<p>여러 번 테스트해본 결과, SVN의 가장 최근에 태그된 리비전이 그나마 제일 안정적이었음</p>
</li>
<li>
<p>클러스터 모듈의 워커들을 이용</p>
</li>
<li>
<p>100개의 아마존 EC2 서버들로부터 초당 10만개의 JSON HTTP GET 요청을 보냄. </p>
</li>
<li>클러스터 모듈을 사용해서 일시적인 요청(?) 처리의 오버헤드를 줄임. (35만 연결 중 10만개 정도가 일시적이었다) [역주] 자식 프로세스로 어떻게 뭘 분산하는지는 현재 미확인 </li>
<li>마스터는 이전과 동일. 워커는 CPU 당 하나씩 생성하고, 마스터와는 다른 포트를 사용해서 요청을 받아서 마스터로 포워딩함. 이렇게 한 이유는 오직 1.4기가 힙 제한 때문.</li>
</ol>
<h2><a href="http://blog.caustik.com/2012/04/11/escape-the-1-4gb-v8-heap-limit-in-node-js/">V8의 1.4GB 힙제한 벗어나기</a></h2>
<ul>
<li><code>ulimit -n 999999</code>: 소켓 오픈 개수 제한을 증가. 기본 1024.</li>
<li><code>--nouse-idle-notification</code>: 가바지 컬렉터가 자동적으로 실행되는 걸 막음. 30초마다 4초짜리 랙이 걸리고 싶지 않으면 사용해야 함. --expose-gc 로 gc() 함수를 자바스크립트에서 직접 호출. </li>
<li><code>--max-old-space-size=8192</code> : 메모리 제한 최대값을 임의로 설정. </li>
<li>최신 v8 소스를 약간 고쳐서 빌드: 메모리 관련 설정이나 가비지 컬렉터 실행 부분을 수정. </li>
</ul>
<p>최근엔 1.4G 제한을 넘어서 2.2G 까지도 사용할 수 있었음. :)</p>
<p>[역주] node.js 서버 실행시 넘기는 파라미터:</p>
<blockquote>
<p>node --trace-gc --expose-gc --nouse-idle-notification --max-new-space-size=2048 --max-old-space-size=8192 sprites.js</p>
</blockquote>
<h2>총평</h2>
<ul>
<li>게임 서버를 개발시 이슈가 되는, 응답성, 동접 처리 등의 문제를 node.js 개발자들도 만나기 시작함. 의외로 메모리 제한이 문제가 된다는 게 특이했음. node.js 개발진은 메모리 제약은 클러스터 모듈로 분산해서 해결하는 걸 추천하는 듯. </li>
<li>가비지 컬렉팅 문제는 응답성이 중요한 액션 게임을 개발할 경우 심각할 수 있음. (4초나 랙이 걸린다니! 그것도 30초마다!) 그래도 소셜 게임 수준은 걱정하지 않아도 될 듯. </li>
</ul></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/node.js/"><span class="label"><span class="icon icon-tag"></span> node.js</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2012/04/16/python-generator/">Python Iterator vs. Generator</a> <small>2012-04-16</small></h1>
	</div>
	<div><h2>iterator</h2>
<p>임의의 sequence 를 순회하는데 필요한 정보를 담은 오브젝트.<br />
iter() 함수를 통해서 생성하고, next() 함수를 이용해서 index 를 증가시켜서 다음 객체를 리턴한다. 맨 끝에 도달하면 StopIteration 예외를 던진다.</p>
<p>즉 for x in seq 는 내부적으로 아래와 같다.</p>
<pre><code>it = iter(seq)
while 1:
  try:
    x = it.next()
  except StopIteration:
    break
</code></pre>

<p>임의의 클래스에 <strong>iter</strong>() 과 next() 함수를 정의하면, in 연산자로 iteration 이 가능하다.</p>
<pre><code>class MyCollection:
  def __init__(self, seq): self.idx=0; self.seq=seq
  def __iter__(self): return self
  def next(self):
    if self.idx &gt; len(self.seq): raise StopIteration
    self.idx += 1
    return self.seq[self.idx]
</code></pre>

<h2>generator function</h2>
<p>iterator 가 next() 호출을 통해서 값을 "리턴"하는 것과 달리, generator 는 next() 함수를 부르면 이전에 멈춘 곳부터 실행(resume)하다가 yield로 값을 리턴하고 다시 멈춤(pause)으로써, 결과적으로 값을 순차적으로 "생성"한다. 맨 끝에서는 역시 StopIteration 예외를 던진다.</p>
<h2>generator expression</h2>
<p><code>(x for x in seq)</code> 처럼 [] 대신 () 로 list comprehension 을 묶으면 generator 를 간단히 만들 수 있다.</p>
<p>리스트를 파라미터로 받는 함수에 그대로 넘길 수도 있다.</p>
<blockquote>
<p>sum(x for x in seq)</p>
</blockquote></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/python/"><span class="label"><span class="icon icon-tag"></span> python</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2012/04/04/appengine-pipeline/">AppEngine pipeline</a> <small>2012-04-04</small></h1>
	</div>
	<div><h3>개요</h3>
<p>Datastore 에 task 순서를 저장하고 순차적으로 하나씩 실행한다. <br />
task 1 의 리턴값이 task2 의 출력값이 된다.<br />
내부적으로 task queue 를 사용한다.</p>
<ul>
<li>run() 의 리턴값 또는 마지막 yield 값이 self.outputs.default.value 가 된다.</li>
<li>여러 개의 값을 리턴할 수도 있다.</li>
<li>값에 이름이 필요할 경우 output_names 와 fill() 함수를 이용할 것.</li>
</ul>
<pre><code>output = [ slot, ... ] 
</code></pre>

<h3>2개를 순차 실행</h3>
<p>task2 에서 task1 을 yield 로 호출할 것.</p>
<pre><code>class Task1(pipeline.Pipeline):
  def run(self, input):
    return input*2

class Task2(pipeline.Pipeline):
  def run(self, input):
    result = yield Task1(input)
    return input+1
</code></pre>

<p>이때 x 는 Future 객체다. x 의 값을 읽어오려면 또다른 yield 로만 가능하다. </p>
<h3>common 모듈</h3>
<p>각종 다양한 파이프라인 기능을 지원한다.</p>
<h3>callback(), get_callback_task(), get_callback_url()</h3>
<p>어떤 태스크들은 사람이 중간에 개입해서 이메일의 링크를 클릭하거나, delay 처럼 일정 시간 후에 태스크큐를 통해서 비동기적으로 수행될 필요가 있다. </p>
<p>이때 콜백 함수가 호출된다. </p>
<h3>finalize()</h3>
<p>아직 결과값이 저장되지는 않은 상태다. </p>
<h3>output_names &amp; fill()</h3>
<p>하나의 값이 아니라 여러 개의 값을 이름 기반으로 넘겨야 할 때</p>
<pre><code>output_names = ['aa', 'bb']
…
self.fill(self.outputs.aa, 11)
self.fill(self.outputs.bb, 'bbbbb')
</code></pre>

<p>와 같은 방식으로 저장한다.</p>
<h3>with pipeline.After()</h3>
<p>futures 를 파라미터로 받아서 해당 태스크가 모두 끝난 경우 with 아래 문을 실행한다.</p>
<h3>common.Append()</h3>
<p>여러 개의 태스크를 실행한 후 하나의 리스트로 리턴한다.</p>
<h3>raise pipeline.Retry, Abort</h3>
<p>예외는 위와 같이 넘길 것</p>
<h3>yield common.Log.info()</h3>
<p>비동기 로그 남기기</p></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/appengine/"><span class="label"><span class="icon icon-tag"></span> appengine</span></a>
	
		<a href="/tag/pipeline/"><span class="label"><span class="icon icon-tag"></span> pipeline</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2012/04/02/nosql-research/">NoSQL 조사</a> <small>2012-04-02</small></h1>
	</div>
	<div><p><a href="http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis">NoSQL DB 비교</a>라는 문서를 기준으로 각 데이터베이스의 특성을 간략 조사해봤다.</p>
<h3>mongodb</h3>
<p>10gen 이라는 회사에서 운영. 오픈 소스. 컬럼 그룹 기반.</p>
<ul>
<li>C++ based</li>
<li>SQL과의 호환성(쿼리, 인덱스)</li>
<li>protocol: BSON &amp; custom</li>
<li>storage: memory mapped file</li>
<li>sharding</li>
<li>query: javascript expression</li>
<li>server script: javascript</li>
<li>다이나믹 쿼리가 필요한 경우</li>
<li>map/reduce 보다 index 가 많은 경우</li>
<li>데이터가 많을 때 성능이 중요한 경우</li>
<li>couch db 에 비해서 데이터가 자주 변하는 경우</li>
</ul>
<h3>Riak</h3>
<ul>
<li>Erlang &amp; C (+ JS) based</li>
<li>fault tolerance 가 최우선</li>
<li>Protocol: HTTP/REST</li>
<li>map/reduce: by JS &amp; Erlang</li>
</ul>
<h3>CouchDB</h3>
<ul>
<li>Erlang based</li>
<li>DB 안정성이 최우선. 손쉬운 사용.</li>
<li>Protocol: HTTP/REST</li>
<li>자주 바뀌지 않는 데이터</li>
<li>데이터 버전관리가 중요한 경우</li>
<li>ex&gt; CMS, CRM</li>
</ul>
<h3><a href="http://redis.io/">Redis</a></h3>
<p>key-value store. github, disqus, digg, stackoverflow 에서 사용중이다.</p>
<h4>특징</h4>
<ul>
<li>C/C++ based</li>
<li>속도가 최우선</li>
<li>Protocol: telnet like?</li>
<li>disk backed in memory db ??</li>
<li>disk swap 지원 안함</li>
<li>set, list, hash, sorted set 등 다양한 타입 지원</li>
<li>트랜잭션도 있다..</li>
<li>데이터 용량 == 메모리에 올라 갈 정도의 크기여야 한다</li>
<li>자주 데이터가 바뀌지만 크기는 예측 가능한 분야에 적절</li>
<li>ex&gt; 주가, 분석, 실시간 데이터, 실시간 통신..</li>
</ul>
<h4>데이터 안정성</h4>
<p>via <a href="http://redis.io/topics/persistence#snapshotting">스냅샷</a></p>
<h5>저장 방식</h5>
<ul>
<li>RDB(snapshot): 큰 파일 하나에 DB 전체를 저장.</li>
<li>AOF(Append Only File): 변경 사항(command)을 로그 파일에 계속 추가함. 서버가 뜰 때 이걸 쭈욱 읽어서 원본 데이터를 만들어낸다.</li>
<li>둘 다 끄면 캐시 모드가 됨. 서버 끄면 사라짐.</li>
<li>둘 다 적용하면, 마지막 rdb 다음부터의 AOF 를 읽어서 만들어냄</li>
</ul>
<h5>RDB 의 장점</h5>
<ul>
<li>특정 시각의 데이터를 하나의 파일에 담았다</li>
<li>백업/복구에 용이: 주기적으로 RDB를 만들어서 외부에 백업하기 쉽다</li>
<li>성능면에서 최고</li>
<li>빠른 재시작</li>
</ul>
<h5>RDB 단점</h5>
<ul>
<li>데이터 손실 가능성: 파워 나감</li>
<li>주기적으로 여러 RDB를 만들어야 된다.</li>
<li>저장할 때마다 fork 한다. 이때 I/O 가 멈추거나 CPU가 스파이크 친다.</li>
<li>물론 AOF 도 fork 를 하긴 한다.. 대신 조정이 가능.</li>
</ul>
<h5>AOF 장점</h5>
<ul>
<li>보다 안정적. fsync 정책을 튜닝 가능(매 초마다, 모든 쿼리 마다)</li>
<li>기본 정책은 1초마다. 백그라운드 쓰레드가 실행함.</li>
<li>append only 라서 데이터 커럽션이 없다. 마지막 데이터가 깨질 경우에도 쉽게 고칠 수 있다.</li>
<li>로그가 너무 커지면 자동적으로 다른 파일로 분할한다.</li>
<li>로그 포맷이 이해하기 쉽다.</li>
</ul>
<h5>AOF 단점</h5>
<ul>
<li>RDB 보다 파일 용량이 크다</li>
<li>RDB 보다 느리다</li>
<li>데이터가 꼬일 확률이 존재한다. 과거에 그런 버그가 있었다. 근데 아직 버그 리포트는 없다.</li>
</ul>
<h5>결론</h5>
<ul>
<li>둘 다 사용해야 함</li>
<li>스냅샷: dump.rdb 를 남김.</li>
<li>초 단위 주기. 또는 데이터셋의 변화량 단위.<br />
 ex&gt; save 60 1000 === 60초 마다, 1000 개의 변화 마다</li>
<li>fork 해서 자식 프로세스가 dump.rdb 를 저장하면 기존 파일을 변경</li>
<li>AOS:</li>
</ul>
<h3>cassandra</h3>
<p>페이스북이 개발해서 오픈소스화. 지금은 아파치에서 관리중. 페이스북/트위터/Digg 에서 사용. 컬럼 그룹 형태의 데이터 모델. 데이터 일관성 잘 지원한다.</p>
<ul>
<li>자바 기반</li>
<li>읽기 보다는 쓰기를 많이 할 때</li>
<li>모든 컴포넌트가 다 자바일때</li>
<li>은행, 금융.</li>
</ul>
<h3>couchbase(membase)</h3>
<p>via <a href="http://www.couchbase.com/couchbase-server/features">Features</a></p>
<p>membase 가 couchbase 로 통합됨</p>
<ul>
<li>Erlang &amp; C 기반</li>
<li>memcache 호환성 + 영속성 + 클러스터링 이 중요</li>
<li>존나 빠름</li>
<li>디스크 영속성</li>
<li>web GUI</li>
<li>DB를 끄지 않고 업그레이드 가능</li>
<li>데이터 접근 속도가 중요할 때, 많은 접근이 있을 경우, 높은 가용성 필요할 때</li>
<li>징가 같은 highly concurrent web app</li>
</ul>
<h3>HBase</h3>
<ul>
<li>google big table 의 오픈 소스 클론</li>
</ul>
<h2>총평</h2>
<h3>유력한 후보들</h3>
<ul>
<li>mongodb: 팔방미인. blob</li>
<li>redis: 로그 &amp; 캐시</li>
<li>couchbase(membase): 메모리 기반 but 용량 한계. 근데 node.js 클라 없다.</li>
</ul>
<h3>무시할 놈들</h3>
<ul>
<li>couchdb: 데이터가 자주 바뀐다…</li>
<li>cassandra: 자바 기반</li>
<li>riak: 머임..</li>
<li>hbase: 즐..</li>
</ul></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/nosql/"><span class="label"><span class="icon icon-tag"></span> nosql</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2012/02/26/libuv/">libUV 분석</a> <small>2012-02-26</small></h1>
	</div>
	<div><h2>개요</h2>
<p>node.js의 플랫폼 레이어로 여러 플랫폼에서의 비동기 입출력을 추상화하고, 완료될 때 콜백을 실행할 수 있게 해준다.</p>
<p>see also <a href="https://github.com/joyent/libuv">GitHub</a></p>
<h2>입출력 타입</h2>
<p>include/uv.h 에 보면 다음과 같은 입출력 타입이 지원된다.</p>
<ul>
<li>TCP, UDP 소켓</li>
<li>IPC, named Pipe(부모-자식 프로세스간 통신)</li>
<li>타이머, 고해상도 타이머, idle 이벤트</li>
<li>쓰레드풀링(QueueUserWorkItem)</li>
</ul>
<p>이 정도면 능히 게임 서버를 만들 수 있는 수준이다?</p>
<h2>입출력 핸들과 처리 함수들</h2>
<p>일단, 비동기 입출력 타입들은 전용 핸들과 초기화/소멸 함수를 가진다.</p>
<ul>
<li>uv_tcp_t: uv_tcp_init(), uv_tcp_endgame()</li>
<li>uv_udp_t: uv_udp_init(), uv_udp_endgame()</li>
</ul>
<p>또한 각종 이벤트에 대해서 요청/완료 함수가 존재한다. 예를 들어 TCP 소켓 입출력에 대해서는 Accept/Connect/Read/Write 이벤트가 존재하는데 아래와 같은 함수들이 대응되어 있다.</p>
<ul>
<li>uv_tcp_accept =&gt; uv_process_tcp_accept_req</li>
<li>uv_tcp_read_start =&gt; uv_process_tcp_read_req</li>
<li>uv_tcp_write =&gt; uv_process_tcp_write_req</li>
<li>uv_tcp_connect =&gt; uv_process_tcp_connect_req</li>
</ul>
<p>특이한 것은 Loop Watcher 로 분류되는, idle/prepare/check 이벤트들이다. idle은 서버에 아무런 입출력이 없을 때 호출된다. prepare/check 는 이벤트 루프를 커스터마이징하기 위한 함수인데 거의 쓸 일은 없을 듯.</p>
<h2>메인 이벤트 루프</h2>
<pre><code>// src/core.cc
do {
     // 현재 시간 설정
   uv_update_time((loop));

   // 완료된 타이머 이벤트 실행
   uv_process_timers((loop));

   // 요청도 없고 타이머도 없으면 idle 이벤트 실행
    if ((loop)-&gt;pending_reqs_tail == NULL &amp;&amp; (loop)-&gt;endgame_handles == NULL){
      uv_idle_invoke((loop));
   }

   // 완료된 입출력을 정리하고 지정된 콜백을 실행
   uv_process_reqs((loop));

   // 끊긴 연결 등의 핸들을 정리
   uv_process_endgames((loop));

   // pre-poll 콜백들을 호출
   uv_prepare_invoke((loop));

   // GetQueuedCompletionStatus 를 실행해서 입출력 완료를 대기
   // 현재 처리할 이벤트가 없으면 계속 대기
   poll((loop), (loop)-&gt;idle_handles == NULL &amp;&amp;
                 (loop)-&gt;pending_reqs_tail == NULL &amp;&amp;
                 (loop)-&gt;endgame_handles == NULL &amp;&amp;
                 (loop)-&gt;refs &gt; 0);

    // post-poll 콜백들을 호출
    uv_check_invoke((loop));
  } while (0);
</code></pre>

<h2>메모리 관리</h2>
<ul>
<li>TCP read : <a href="http://stackoverflow.com/questions/4988168/wsarecv-and-wsabuf-questions">zero byte receive</a>라는 기법을 이용한다. WSARecv 에 길이가 0인 빈 버퍼를 넘기고, 실제로 뭔가 오면 WSARecv 로 다시 읽는 방식이다. locked page 를 줄일 수 있어서 I/O 가 많은 서버들이 자주 쓴다고 한다. 참고로 WSARecv/WSASend 에 넘긴 메모리는 커널 드라이버가 접근해야 하므로 lock 이 걸리게 되는데 물리적인 최대값이 있다.(램의 1/8??)</li>
</ul>
<p>전통적인 게임 서버들은 하나에 프로세스가 여러 개의 쓰레드를 가지고, 세션당 1개의 입력 버퍼를 두는 1-recv 기법을 사용한다. 반면 node.js 는 클러스터링을 염두에 둔 탓인지, 메모리를 최소하는 전략을 채택한 듯하다.</p>
<ul>
<li>TCP write: N-send 를 사용한다. 즉 보낼 게 있을 때마다 버퍼가 만들어지거나 이미 존재하는 객체의 포인터를 이용한다는 뜻이다. 구조적으로는 gather write 가 가능할 거 같은데 코드에서는 없는 듯하다.</li>
</ul>
<p>대신 브로드캐스팅을 해도 복사는 없으므로 한편으론 괜찮을지도.</p>
<h2>평가</h2>
<p>게임 서버 프로그래머로서 발견할 수 있는 문제는,</p>
<ul>
<li>CPU 연산이 많은 경우 모든 실행이 멈춘다. 해결책은<ul>
<li>process.nextTick() 으로 잘게 자른다. (또는 코루틴이 도입될 때까지 기다린다 ㅋㅋ) yield 같은 게 있으면 좋을텐데...</li>
<li>그래도 크다면 pipe 나 소켓을 통해 다른 프로세스로 task 를 넘기고 받을 것. 게임의 핵심 로직은 별도 프로세스로 분리하는 게 더 좋을 듯.</li>
</ul>
</li>
<li>캐릭터 이동이나 대규모 전투 같이 크기는 작지만 I/O의 절대 갯수가 많을 경우, 성능 저하가 좀 있을 것 같다.<ul>
<li>왜냐하면 I/O 갯수만큼 GQCS를 호출해야 하니까. 이건 nv_run 코드를 패치하는 방법도 있지만..</li>
<li>어쨌거나 기본적으로 작게 분산해서 하나하나를 가볍게 가져가는 형태가 될 것이다.</li>
</ul>
</li>
</ul>
<p>만약 node.js 만으로 리얼타임 MMO 게임 서버군을 구성한다면…</p>
<ul>
<li>frontend servers: 클라이언트와의 인증, 입출력을 전담. 메시지가 도달하면 backend 의 적당한 서버로 IPC(pipe or socket)를 통해 보낸다.</li>
<li>backend servers: game server(sharding), AI, chat, guild, shop 등 역할별로 분산해서 지연을 최소화한다.</li>
<li>CPU 를 많이 사용해야 한다면 C++ native 로 전환해가는 방법도 좋다.</li>
</ul>
<p>그 외에 고민해야 될 것들이라면</p>
<ul>
<li>적당한 데이터베이스/캐시 미들웨어: membase?</li>
<li>node 프로세스 관리 도구 및 모니터링</li>
</ul></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/node.js/"><span class="label"><span class="icon icon-tag"></span> node.js</span></a>
	
	</p>
</div>
			
			<div class="pagination pagination-centered">
				<ul>
				
					<li><a href="/page/0/">&laquo;</a></li>
				
				
				  	<li >
				  	
				  		<a href="/">1</a>
				  	
				  	</li>
		  		
				  	<li class="active">
				  	
				    	<a href="/page/2/">2</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/3/">3</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/4/">4</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/5/">5</a>
				    
				  	</li>
		  		
				  	<li >
				  	
				    	<a href="/page/6/">6</a>
				    
				  	</li>
		  		
				
					<li><a href="/page/7/">&raquo;</a></li>
				
		  		</ul>
			</div>
		</div>
		<div class="span3">
			<ul class="nav nav-list well dsq-widget">
	<li>
		
		<a href="http://facebook.com/reiot" style="display: inline-block"><img src="/assets/img/facebook.png" /></a>
		
		
		<a href="http://twitter.com/reiot" style="display: inline-block"><img src="/assets/img/twitter.png" /></a>
		
	    <a href="atom.xml" style="display: inline-block"><img src="/assets/img/rss.png" /></a>
	</li>
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2012/04/21/250k-node-connections/">Node.js로 25만 동접 만들기</a>
	</li>
	
	<li>
		<a href="/2012/04/16/python-generator/">Python Iterator vs. Generator</a>
	</li>
	
	<li>
		<a href="/2012/04/04/appengine-pipeline/">AppEngine pipeline</a>
	</li>
	
	<li>
		<a href="/2012/04/02/nosql-research/">NoSQL 조사</a>
	</li>
	
	<li>
		<a href="/2012/02/26/libuv/">libUV 분석</a>
	</li>
	
	<li class="nav-header dsq-widget-title">
		Recent Comments
	</li>
	<script type="text/javascript" src="http://reiot.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script>
</ul>
		</div>
	</div>

	<footer>
	<p class="pull-right">
		<a href="http://github.com/Reiot/droppress" class="btn btn-success btn-mini">powered by DropPress 0.0.1</a>
	</p>
</footer>

</div> <!-- /container -->


    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/google-code-prettify/prettify.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/droppress.js"></script>
	

  
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-247024-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
  

  </body>
</html>