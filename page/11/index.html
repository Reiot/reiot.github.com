<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
	<title>Rebooting Reiot</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="A social game developer wandering strange dungeons...">
	<meta name="author" content="Ray Yun">

    <!-- Le styles -->
	
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">
    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
        font-family: 'Helvetica Neue', '맑은 고딕', Helvetica, Arial, sans-serif;
      }
      .tag-cloud, .category-cloud {
        line-height: 250%;
      }
    </style>
    <link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
	

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="/assets/ico/apple-touch-icon-57-precomposed.png">
  </head>

  <body>

    <div class="navbar navbar-fixed-top navbar-inverse">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Rebooting Reiot</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Home</a></li>
              <li><a href="/archives/">Archives</a></li>
              <li><a href="/category/">Categories</a></li>
              <li><a href="/tag/">Tags</a></li>
			  
            </ul>
            <form class="navbar-search pull-left">
              <input type="text" class="search-query" placeholder="Title Search">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

	
<div class="container">

	

	<div class="row">
		<div class="span9">
			
				<div>
	<div class="page-header">
		<h1><a href="/2009/02/17/tasklist-taskkill/">Tasklist/Taskkill</a> <small>2009-02-17</small></h1>
	</div>
	<div><p>[caption id="" align="alignnone" width="500" caption="tasklist"]<a href="http://seer.entsupport.symantec.com/docs/images/253904/tasklist.jpg"><img alt="tasklist" src="http://seer.entsupport.symantec.com/docs/images/253904/tasklist.jpg" /></a>[/caption]</p>
<p>터미널에서 프로세스 관리자가 뜨지 않을 경우, 다른 터미날에서 띄운 프로세스를 죽이기가 참 난감할 때가 있다. 다행스럽게도 유닉스의 ps/kill 조합을 윈도우에서도 지원한다.</p>
<pre><code>- tasklist
- tasklist /SVC : 서비스 프로세스 리스트
- taskkill /PID &lt;pid&gt;: PID로 죽이기
- taskkill /F /IM &lt;name&gt; : (강제로) 이름으로 죽이기
</code></pre>
<p>가장 하일라이트는, 원격 컴퓨터의 프로세스 죽이기인데, 정말로 잘 되는지 회사에서 테스트해봐야겠다. ;)<br />
```<br />
tasklist /S <server> /U <username> /P <password> /FI "IMAGENAME eq <em>Server</em>.exe"</p>
<p>taskkill /S <server> /U <username> /P <password> /IM <process name>```</p></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/process/"><span class="label"><span class="icon icon-tag"></span> process</span></a>
	
		<a href="/tag/console/"><span class="label"><span class="icon icon-tag"></span> console</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2009/02/17/boost-preprocessor/">boost::preprocessor</a> <small>2009-02-17</small></h1>
	</div>
	<div><p>boost::preprocessor 는 템플릿을 이용한 메타프로그래밍에 있어서, 템플릿 파라미터들의 반복 같은 "<strong>문자열 토큰들의 패턴 처리</strong>"를 매크로를 이용해서 손쉽게 처리해주는 라이브러리이다. 보다 상세한 용법은 <a href="http://www.boost.org/doc/libs/1_38_0/libs/preprocessor/doc/index.html">공식 홈페이지</a> 혹은  <a href="http://rein.upnl.org/wordpress/archives/486">레인님 블로그</a>와 <a href="http://ricanet.com/new/view.php?id=blog/080607">리카넷 블로그</a>를 참조하기 바란다.</p>
<p>이걸 이용해서 <a href="http://reiot.cafe24.com/2009/01/20/boost-tuple-based-serialization/">몇 주전에 포스팅한 boost::tuple 의 직렬화 코드</a>를 만들어봤다. 원래 계획과는 좀 많이 바뀌긴 했는데, 구글로 검색해보니 <a href="http://uint32t.blogspot.com/2008/03/update-serializing-boosttuple-using.html">tuple 을 boost::serialization 으로 직렬화하는 예제</a>가 를 (상당 부분!) 참조했음을 밝힌다.</p>
<p>남은 작업은 여기에 vector 와 list 를 자동으로 직렬화하는 건데, 어째 아무리 검색해봐도 is_vector 라든지 is_list 같은 넘이 없어서 일단은 포기. 결국 mpl 을 뒤져봐야 할지도 모르겠다. </p>
<!--more-->

<pre><code>
#include &quot;stdafx.h&quot;

#include &lt;boost/tuple/tuple.hpp&gt;

#include &lt;string&gt;

#include &lt;vector&gt;

#include &lt;string&gt;
#include &lt;gtest/gtest.h&gt;
using namespace boost;
using namespace std;
#include &lt;boost/preprocessor/repetition.hpp&gt;
typedef unsigned short strlen_t;
template&lt; class V &gt;
int to_binary( char* buf, const V &amp; v )
{
  size_t len = sizeof(v);
  memcpy(buf,(const void*)&amp;v,len);
  return len;
}
template&lt;class T&gt;
int from_binary( const char * buf, T &amp; t )
{
  size_t len = sizeof(t);
  memcpy((void*)&amp;t,buf,len);
  return len;
}
template&lt;&gt;
int to_binary( char* buf, const string &amp; s )
{
  strlen_t sz = (strlen_t)s.size();
  memcpy(buf,&amp;sz,sizeof(sz));
  if ( sz &gt; 0 )
  {
  memcpy(buf+sizeof(sz),s.c_str(),sz);
  }
  return sizeof(sz)+sz;
}
template&lt;&gt;
int from_binary( const char * buf, string &amp; str )
{
  strlen_t sz;
  memcpy((void*)&amp;sz,buf,sizeof(sz));
  if ( sz &gt; 0 )
  {
  str.assign(buf+sizeof(sz),sz);
  assert(str.size()==sz);
  }
  return sizeof(sz)+sz;
}
template&lt;&gt;
int to_binary( char* buf, const wstring &amp; s )
{
  strlen_t sz = (strlen_t)s.size();
  memcpy(buf,&amp;sz,sizeof(sz));
  if ( sz &gt; 0 )
  {
  memcpy(buf+sizeof(sz),s.c_str(),sz*sizeof(wchar_t));
  }
  return sizeof(sz)+sz*sizeof(wchar_t);
}
template&lt;&gt;
int from_binary( const char * buf, wstring &amp; str )
{
  strlen_t sz;
  memcpy((void*)&amp;sz,buf,sizeof(sz));
  if ( sz &gt; 0 )
  {
  str.assign((wchar_t*)(buf+sizeof(sz)),sz);
  assert(str.size()==sz);
  }
  return sizeof(sz)+sz*sizeof(wchar_t);
}
#define TO_BINARY(z,which,unused) \
  byte_written = to_binary( buf + offset, t.get&lt;which&gt;() );\
  if ( byte_written &lt; 0 ) { return which; }\
  offset += byte_written;
#define TUPLE_TO_BINARY(z,nargs,unused) \
  template&lt; BOOST_PP_ENUM_PARAMS(nargs,typename T) &gt; \
  int tuple_to_binary( const boost::tuple&lt; BOOST_PP_ENUM_PARAMS(nargs,T) &gt; &amp; t, char * buf, size_t max_len ) \
  { \
  int offset = 0; \
  int byte_written = 0; \
  BOOST_PP_REPEAT_FROM_TO(0,nargs,TO_BINARY,~); \
  return offset; \
  }
BOOST_PP_REPEAT_FROM_TO(1,6,TUPLE_TO_BINARY,~);
#define FROM_BINARY(z,which,unused) \
  byte_read = from_binary( buf + offset, t.get&lt;which&gt;() );\
  if ( byte_read &lt; 0 ) { return which; }\
  offset += byte_read;
#define BINRY_TO_TUPLE(z,nargs,unused) \
  template&lt; BOOST_PP_ENUM_PARAMS(nargs,typename T) &gt; \
  int binary_to_tuple( boost::tuple&lt; BOOST_PP_ENUM_PARAMS(nargs,T) &gt; &amp; t, char * buf, size_t max_len ) \
{ \
  int offset = 0; \
  int byte_read = 0; \
  BOOST_PP_REPEAT_FROM_TO(0,nargs,FROM_BINARY,~); \
  return offset; \
}
BOOST_PP_REPEAT_FROM_TO(1,6,BINRY_TO_TUPLE,~);
//template&lt; class T0&gt;
//int binary_to_tuple( boost::tuple&lt;t0&gt; &amp; t, const char * buf, size_t len )
//{
//  int offset = 0;
//
//  int byte_read = from_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_read;
//
//  return offset;
//}
//
//template&lt; class T0 &gt;
//int tuple_to_binary( const boost::tuple&lt;t0&gt; &amp; t, char * buf, size_t max_len )
//{
//  int offset = 0;
//  int byte_written = 0;
//
//  byte_written = to_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_written;
//
//  return offset;
//}
//
//
//template&lt; class T0, class T1&gt;
//int tuple_to_binary( const boost::tuple&lt;t0,T1&gt; &amp; t, char * buf, size_t max_len )
//{
//  int offset = 0;
//  int byte_written = 0;
//
//  byte_written = to_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_written;
//
//  return offset;
//}
//
//
//template&lt; class T0, class T1, class T2&gt;
//int tuple_to_binary( const boost::tuple&lt;t0,T1,T2&gt; &amp; t, char * buf, size_t max_len )
//{
//  int offset = 0;
//  int byte_written = 0;
//
//  byte_written = to_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;2&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -2;
//  }
//  offset += byte_written;
//
//  return offset;
//}
//
//
//template&lt; class T0, class T1, class T2, class T3&gt;
//int tuple_to_binary( const boost::tuple&lt;t0,T1,T2,T3&gt; &amp; t, char * buf, size_t max_len )
//{
//  int offset = 0;
//  int byte_written = 0;
//
//  byte_written = to_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;2&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -2;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;3&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -3;
//  }
//  offset += byte_written;
//
//  return offset;
//}
//
//template&lt; class T0, class T1, class T2, class T3, class T4 &gt;
//int tuple_to_binary( const boost::tuple&lt;t0,T1,T2,T3,T4&gt; &amp; t, char * buf, size_t max_len )
//{
//  int offset = 0;
//  int byte_written = 0;
//
//  //{
//  //  size_t sz0 = sizeof( tuples::element&lt;0,TUPLE&gt;::type );
//  //  assert( sz0 == sizeof(int) );
//  //  size_t sz1 = sizeof( tuples::element&lt;1,TUPLE&gt;::type );
//  //  assert( sz1 == sizeof(char) );
//  //  size_t sz2 = sizeof( tuples::element&lt;2,TUPLE&gt;::type );
//  //  assert( sz2 == sizeof(string) );
//  //  size_t sz3 = sizeof( tuples::element&lt;3,TUPLE&gt;::type );
//  //  assert( sz3 == sizeof(float) );
//  //  size_t sz4 = sizeof( tuples::element&lt;4,TUPLE&gt;::type );
//  //  assert( sz4 == sizeof(bool) );
//  //}
//
//  byte_written = to_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;2&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -2;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;3&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -3;
//  }
//  offset += byte_written;
//
//  byte_written = to_binary( buf + offset, t.get&lt;4&gt;() );
//  if ( byte_written &lt; 0 )
//  {
//  // error
//  return -4;
//  }
//  offset += byte_written;
//
//  return offset;
//}
//template&lt; class T0&gt;
//int binary_to_tuple( boost::tuple&lt;t0&gt; &amp; t, const char * buf, size_t len )
//{
//  int offset = 0;
//
//  int byte_read = from_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_read;
//
//  return offset;
//}
//
//template&lt; class T0, class T1&gt;
//int binary_to_tuple( boost::tuple&lt;t0,T1&gt; &amp; t, const char * buf, size_t len )
//{
//  int offset = 0;
//
//  int byte_read = from_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_read;
//
//  return offset;
//}
//
//template&lt; class T0, class T1, class T2&gt;
//int binary_to_tuple( boost::tuple&lt;t0,T1,T2&gt; &amp; t, const char * buf, size_t len )
//{
//  int offset = 0;
//
//  int byte_read = from_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;2&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -2;
//  }
//  offset += byte_read;
//
//  return offset;
//}
//
//template&lt; class T0, class T1, class T2, class T3&gt;
//int binary_to_tuple( boost::tuple&lt;t0,T1,T2,T3&gt; &amp; t, const char * buf, size_t len )
//{
//  int offset = 0;
//
//  int byte_read = from_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;2&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -2;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;3&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -3;
//  }
//  offset += byte_read;
//
//  return offset;
//}
//
//template&lt; class T0, class T1, class T2, class T3, class T4 &gt;
//int binary_to_tuple( boost::tuple&lt;t0,T1,T2,T3,T4&gt; &amp; t, const char * buf, size_t len )
//{
//  int offset = 0;
//
//  int byte_read = from_binary( buf + offset, t.get&lt;0&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return 0;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;1&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -1;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;2&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -2;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;3&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -3;
//  }
//  offset += byte_read;
//
//  byte_read = from_binary( buf + offset, t.get&lt;4&gt;() );
//  if ( byte_read &lt; 0 )
//  {
//  // error
//  return -4;
//  }
//  offset += byte_read;
//
//  return offset;
//}
#define TUPLE_TO_BINARY_TO_TUPLE(t,t1) \
  char buf[1024];\
  int len = tuple_to_binary(t,buf,1024);\
  int len2 = binary_to_tuple(t1,buf,len);\
  EXPECT_EQ( len2 , len )
TEST(tuple_to_binary,test1)
{
  typedef tuple&lt;int&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = 1024;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
}
TEST(tuple_to_binary,boolean)
{
  typedef tuple&lt;bool,bool&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = true;
  t.get&lt;1&gt;() = false;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
  EXPECT_EQ( t.get&lt;1&gt;() , t1.get&lt;1&gt;() );
}
TEST(tuple_to_binary,wstring)
{
  typedef tuple&lt;string,wstring&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = &quot;Hello&quot;;
  t.get&lt;1&gt;() = L&quot;World&quot;;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
  EXPECT_EQ( t.get&lt;1&gt;() , t1.get&lt;1&gt;() );
}
TEST(tuple_to_binary,test2_empty_string)
{
  typedef tuple&lt;wstring,wstring&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = L&quot;Hello&quot;;
  t.get&lt;1&gt;() = L&quot;&quot;;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
  EXPECT_EQ( t.get&lt;1&gt;() , t1.get&lt;1&gt;() );
}
TEST(tuple_to_binary,test2)
{
  typedef tuple&lt;int,char&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = 1024;
  t.get&lt;1&gt;() = 'A';
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
  EXPECT_EQ( t.get&lt;1&gt;() , t1.get&lt;1&gt;() );
}
TEST(tuple_to_binary,test3)
{
  typedef tuple&lt;int,char,string&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = 1024;
  t.get&lt;1&gt;() = 'A';
  t.get&lt;2&gt;() = &quot;Hello World&quot;;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
  EXPECT_EQ( t.get&lt;1&gt;() , t1.get&lt;1&gt;() );
  EXPECT_EQ( t.get&lt;2&gt;() , t1.get&lt;2&gt;() );
}
TEST(tuple_to_binary,test4)
{
  typedef tuple&lt;int,char,string,float&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = 1024;
  t.get&lt;1&gt;() = 'A';
  t.get&lt;2&gt;() = &quot;Hello World&quot;;
  t.get&lt;3&gt;() = 12.34f;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
  EXPECT_EQ( t.get&lt;1&gt;() , t1.get&lt;1&gt;() );
  EXPECT_EQ( t.get&lt;2&gt;() , t1.get&lt;2&gt;() );
  EXPECT_EQ( t.get&lt;3&gt;() , t1.get&lt;3&gt;() );
}
TEST(tuple_to_binary,test5)
{
  typedef tuple&lt;int,char,string,float,bool&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;() = 1024;
  t.get&lt;1&gt;() = 'A';
  t.get&lt;2&gt;() = &quot;Hello World&quot;;
  t.get&lt;3&gt;() = 12.34f;
  t.get&lt;4&gt;() = false;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;() , t1.get&lt;0&gt;() );
  EXPECT_EQ( t.get&lt;1&gt;() , t1.get&lt;1&gt;() );
  EXPECT_EQ( t.get&lt;2&gt;() , t1.get&lt;2&gt;() );
  EXPECT_EQ( t.get&lt;3&gt;() , t1.get&lt;3&gt;() );
  EXPECT_EQ( t.get&lt;4&gt;() , t1.get&lt;4&gt;() );
}
TEST(tuple_to_binary,struct)
{
  struct my_struct
  {
  int i;
  char c;
  float f;
  bool b;
  };

  typedef tuple&lt;my_struct&gt; my_tuple;
  my_tuple t, t1;
  t.get&lt;0&gt;().i = 1024;
  t.get&lt;0&gt;().c = 'A';
  t.get&lt;0&gt;().f = 12.34f;
  t.get&lt;0&gt;().b = false;
  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
  EXPECT_EQ( t.get&lt;0&gt;().i  , t1.get&lt;0&gt;().i  );
  EXPECT_EQ( t.get&lt;0&gt;().c  , t1.get&lt;0&gt;().c  );
  EXPECT_EQ( t.get&lt;0&gt;().f  , t1.get&lt;0&gt;().f  );
  EXPECT_EQ( t.get&lt;0&gt;().b  , t1.get&lt;0&gt;().b  );
}
//TEST(tuple_to_binary,vector)
//{
//  struct my_struct
//  {
//  int i;
//  char c;
//  float f;
//  bool b;
//  };
//
//  typedef vector&lt;my_struct&gt; my_structs;
//  typedef tuple&lt;my_structs&gt; my_tuple;
//
//  my_tuple t, t1;
//
//  for ( size_t i = 0 ; i &lt; 10 ; i ++ )
//  {
//  my_struct s;
//  s.i = 1024;
//  s.c = 'A';
//  s.f = 12.34f;
//  s.b = false;
//
//  t.get&lt;0&gt;().push_back(s);
//  }
//
//  TUPLE_TO_BINARY_TO_TUPLE(t,t1);
//
//  const my_structs &amp; slist = t.get&lt;0&gt;();
//  const my_structs &amp; slist1 = t1.get&lt;0&gt;();
//
//  EXPECT_EQ( slist1.size(), slist.size() );
//  for ( size_t j = 0 ; j &lt; slist1.size() ; j ++ )
//  {
//  const my_struct &amp; s = slist[j];
//  const my_struct &amp; s1 = slist1[j];
//
//  EXPECT_EQ( s1.i  , s.i  );
//  EXPECT_EQ( s1.c  , s.c  );
//  EXPECT_EQ( s1.f  , s.f  );
//  EXPECT_EQ( s1.b  , s.b  );
//  }
//}
int main(int argc, char **argv) {
  cout &lt;&lt; &quot;Running main() from gtest_main.cc\n&quot;;
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</code></pre></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/boost/"><span class="label"><span class="icon icon-tag"></span> boost</span></a>
	
		<a href="/tag/preprocessor/"><span class="label"><span class="icon icon-tag"></span> preprocessor</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2009/02/08/earl-grey/">Earl Grey</a> <small>2009-02-08</small></h1>
	</div>
	<div><table style="width:auto;" border="0">
<tbody>
<tr>
<td><a href="http://picasaweb.google.com/lh/photo/EY-Ym9sex9547IPeZxkRxA?feat=embedwebsite">![http://lh3.ggpht.com/_eFJUY9IzSSs/SY7efiJ2ZtI/AAAAAAAAAHA/_G7GJC2ySDY/s400/SANY0042.JPG](http://lh3.ggpht.com/_eFJUY9IzSSs/SY7efiJ2ZtI/AAAAAAAAAHA/_G7GJC2ySDY/s400/SANY0042.JPG)</a></td>
</tr>
</tbody></table>

<p>얘가 최근 영입한 그레이(♂). 스코티쉬 폴드인데, 유명한 홍차 이름인 얼 그레이에서 이름을 따왔다. 똥꼬발랄하고 선배 냥이들이 많이 귀찮아한다.<br />
<table style="width:auto;" border="0"><br />
<tbody><br />
<tr><br />
<td><a href="http://picasaweb.google.com/lh/photo/HNhn36_UOIMobFZawSdIow?feat=embedwebsite"><img alt="http://lh3.ggpht.com/_eFJUY9IzSSs/SY7fXRsrXZI/AAAAAAAAAIQ/HMBpkjqwPZI/s400/SANY0036.JPG" src="http://lh3.ggpht.com/_eFJUY9IzSSs/SY7fXRsrXZI/AAAAAAAAAIQ/HMBpkjqwPZI/s400/SANY0036.JPG" /></a></td><br />
</tr><br />
</tbody></table><br />
이놈이 밤마다 시끄럽게 하는 24시간 발정묘 보리(♂). 코리안 똥고양이의 후손으로,  쌀-보리의 그 보리다. 와이프가 맨날 이쁘다고 해서 요즘은 이뻐보이기도 하지만... 하긴 퇴근할 때 마중나오는 놈은 보리 밖에 없긴 하다. 당연히 쉬귀군의 룬보다는 한참 날씬하다. (푸훗)<br />
<table style="width:auto;" border="0"><br />
<tbody><br />
<tr><br />
<td><a href="http://picasaweb.google.com/lh/photo/TvwqxYaWG4rairUQ1OnVtg?feat=embedwebsite"><img alt="http://lh3.ggpht.com/_eFJUY9IzSSs/SY7iED5QewI/AAAAAAAAALo/uOLDbCG_T8o/s400/SANY0096.JPG" src="http://lh3.ggpht.com/_eFJUY9IzSSs/SY7iED5QewI/AAAAAAAAALo/uOLDbCG_T8o/s400/SANY0096.JPG" /></a></td><br />
</tr><br />
</tbody></table><br />
러시안 블루 아삼(♂). 역시 홍차 이름에서 따왔다. 진정한 고양이답게 날렵하고 점프력도 좋고 잘 울지도 않지만, 성격이 좀 까칠하다. 나랑은 어째 잘 맞는지, 부르면 가슴 위로 올라와서 머리를 부비는 애교도 부린다.</p>
<p>더 많은 사진들은 <a href="http://picasaweb.google.com/Reiot94/yiFktC#">여기</a>에 있으니 구경해보시기 바란다. 그나저나 내 평생 고양이를 3마리나 키우게 될 줄은 몰랐다.</p></div>
	<br />
	<p>
	
		<a href="/category/stories/"><span class="label label-info"><span class="icon icon-folder-open"></span> stories</span></a>
	
	
		<a href="/tag/cat/"><span class="label"><span class="icon icon-tag"></span> cat</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2009/01/27/google-app-engine-overview/">Google App Engine Overview</a> <small>2009-01-27</small></h1>
	</div>
	<div><p>google app engine 은 파이썬 2.5 기반의 웹 개발 프레임워크이다. 사실 수많은 웹 개발환경이 많고 많은데 유독 이놈이 눈에 띄는 건, 기본적으로 구글에서 제공하는 다양한 분산 기반의 서비스들을 손쉽게 사용할 수 있기 때문이다.</p>
<p>아마도 구글 앱스를 사용중인 회사에서 인트라넷이나 백오피스 웹서비스를 만들어야 한다면 이놈을 쓰면 편해질 것 같다. 대충 훝어본 <a href="http://code.google.com/intl/ko-KR/appengine/docs/python/apis.html">Service API</a> 들을 요약해보겠다.</p>
<h3>Datastore</h3>
<p>구글 데이터 저장 인프라(?)에 정보를 저장하고 읽어오는 API.  객체 기반 쿼리와 SQL을 닮은 GQL 기반 쿼리를 제공한다. yaml 로 인덱스도 정의할 수 있고, FK와 트랜잭션도 지원한다.</p>
<pre><code>class Person(db.Model):
    first_name = db.StringProperty()
    last_name = db.StringProperty()
    city = db.StringProperty()
    birth_year = db.IntegerProperty()
    height = db.IntegerProperty()

q = Person.all()
q.filter(&quot;last_name =&quot;, &quot;Smith&quot;)
q.filter(&quot;height &lt;&quot;, 72)
q.order(&quot;-height&quot;)

# The GqlQuery interface prepares a query using a GQL query string.
q = db.GqlQuery(&quot;SELECT * FROM Person &quot; +
    &quot;WHERE last_name = :1 AND height &lt; :2 &quot; +
    &quot;ORDER BY height DESC&quot;,
    &quot;Smith&quot;, 72)
</code></pre>

<h3>Memcache</h3>
<p>매번마다 DB에서 읽어오면 성능이 떨어지니까, 어느 정도 변화가 적은 애들은 DB에서 읽어온 다음 Key-Value 기반의 메모리 캐시에다가 저장했다가 필요할 때마다 재빨리 읽어온다. 별거 아닌 것처럼 보이지만, 이게 분산 서버에서 모두 참조가 가능하다.. 어쨌거나 문자열키로 특정 객체를 꺼내오는 이런 패턴은 게임 서버에도 자주 써야 할 것 같다. (요즘은 변수 선언하는게 어찌나 귀찮은지..)</p>
<pre><code>def get_data():
    data = memcache.get(&quot;key&quot;)
    if data is not None:
        return data
    else:
        data = self.query_for_data()
        memcache.add(&quot;key&quot;, data, 60)
        return data
</code></pre>

<h3>URL Fetch</h3>
<p>다른 웹서버에다가 URL 기반 요청을 해서 결과를 읽어올 수 있다. 즉, 다른 웹서비스들과의 연동이 가능하다는 이야기. </p>
<pre><code>url = &quot;http://www.google.com/&quot;
result = urlfetch.fetch(url)
if result.status_code == 200:
    doSomethingWithResult(result.content)
</code></pre>

<h3>Mail</h3>
<p>손쉽게 메일을 보낼 수 있다. 파일 첨부도 가능하다고는 하나, 단순하니까 예제는 생략.</p>
<h3>Images</h3>
<p>업로드된 이미지의 크기 변경, 회전, 상하좌우 뒤집기, 자르기, 컨트라스트/색상 보정 등의 조작이 가능하다. 이것도 있어보이는 기능이지만 일단 생략.</p>
<h3>Google Accounts</h3>
<p>구글 계정과의 연동 지원. 별명, 이메일 주소 등을 얻어오는 기능이다.</p>
<h3>기타 구글 Data API 연동</h3>
<p>이게 가장 핵심적인 기능인데, 대충 아래와 같은 API 들을 연동할 수 있다. (그런데 이걸 갖고 뭘 어떻게 할 것인가가 사실은 제일 중요하겠지..)</p>
<ul>
<li><a href="http://code.google.com/apis/gdata/auth.html#AuthSub">Authentication</a></li>
<li><a href="http://code.google.com/apis/base/pythondevguide.html">Google Base</a></li>
<li><a href="http://code.google.com/apis/calendar/developers_guide_python.html">Calendar</a></li>
<li><a href="http://code.google.com/apis/contacts/developers_guide_python.html">Contacts</a></li>
<li><a href="http://code.google.com/apis/documents/developers_guide_python.html">Documents</a></li>
<li><a href="http://code.google.com/apis/picasaweb/developers_guide_python.html">Picasa Web Albums</a></li>
<li><a href="http://code.google.com/apis/spreadsheets/developers_guide_python.html">Spreadsheets</a></li>
<li><a href="http://code.google.com/apis/youtube/developers_guide_python.html">YouTube</a></li>
</ul>
<p>레일즈 등 다른 웹 프레임워크에 비해서 좀 부족한 점이 많지만,  구글의 다양한 서비스들과의 연동과 분산에 강한 웹 서비스를 만들어야 한다면 좋은 선택이 될 것 같다. 사실 웹 시뮬레이션 게임을 만들때 좋을 것 같아서 살펴봤는데, 역시 GUI 표현이 걸림돌이 될 것 같다. <a href="http://code.google.com/intl/ko-KR/apis/chart/">차트 API</a> 정도라면 비지니스 관련 웹서비스는 어째 될 것 같은데, 게임은 좀...  </p>
<p>API 목록을 보다 보니 특이한 서비스가 좀 많다. 다들 한번쯤 구경해보면 좋을지도?</p>
<ul>
<li><a href="http://code.google.com/intl/ko-KR/apis/health/">Google Health API</a></li>
<li><a href="http://code.google.com/intl/ko-KR/apis/gra/">Google Radio Automation API</a></li>
<li><a href="http://code.google.com/intl/ko-KR/apis/visualization/documentation/gallery.html">Google Visualization API</a></li>
</ul></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/google/"><span class="label"><span class="icon icon-tag"></span> google</span></a>
	
		<a href="/tag/appengine/"><span class="label"><span class="icon icon-tag"></span> appengine</span></a>
	
		<a href="/tag/python/"><span class="label"><span class="icon icon-tag"></span> python</span></a>
	
	</p>
</div>
			
				<div>
	<div class="page-header">
		<h1><a href="/2009/01/27/erlide/">Erlide</a> <small>2009-01-27</small></h1>
	</div>
	<div><p><a href="http://www.eclipse.org/"> </a><a href="http://www.eclipse.org/"><img alt="Eclipse logo" src="http://erlide.sourceforge.net/img/rea_eclipse_pos_logo_fc_sm.jpg" /></a></p>
<p><a href="http://www.eclipse.org/">이클립스</a>의 얼랭 개발환경(perspective)인 <a href="http://erlide.sourceforge.net/">erlide</a>를 사용하면, 매번마다 c(module) 로 컴파일하는 번거로움에서 벗어날 수 있다. 그<strong>냥 Save 만 하면, 알아서 코드를 컴파일하고 경고나 오류를 보여주기 때문이다. </strong>일단 <a href="http://erlide.sourceforge.net/erlide.html">매뉴얼</a>에 써 있는 대로 설정하고 나면, 이클립스 IDE의 기능들을 간단히 쓸 수 있으므로, 얼랭 초보라면 반드시 eclipse 부터 설치하기를 권장한다.</p>
<p>어차피 매뉴얼에 다 나오는 내용인데, 핵심 기능들만 간단하게만 소개하자면</p>
<pre><code>- gen_server, gen_fsm 등 OTP 기본 템플릿 제공
- F3 - 함수 정의/선언으로 바로가기
- Ctrl + I - 자동 들여쓰기
- Ctrl + Space - 자동 완성
- Alt + O - 개요 보기
- Ctrl + Up/Down - 콘솔창에서 히스토리 기능
- 브레이크 포인트는 라인 맨 앞을 더블클릭
- 디버깅 끝낼 때에는 perspective 를 다시 얼랭으로 전환할 것
</code></pre>
<p>특히 놀라운 것은, (사실 erl 콘솔에서도 볼 수 있지만) Process List View 에서 보면 무려 36개의 얼랭 프로세스들이 떠 있다는 점이다. 루아나 파이썬처럼 그냥 달랑 스크립트만 실행되는 게 아니라는 건 짐작하고 있었지만, 조금은 부하가 걱정될 정도로많이 떠 있긴 하다.</p></div>
	<br />
	<p>
	
		<a href="/category/programming/"><span class="label label-info"><span class="icon icon-folder-open"></span> programming</span></a>
	
	
		<a href="/tag/erlang/"><span class="label"><span class="icon icon-tag"></span> erlang</span></a>
	
	</p>
</div>
			
			<ul class="pager">
			
			  	<li class="previous">
			    	<a href="/page/12/">&larr; Older</a>
			  	</li>
		  	
		  	
				<li class="next">
					<a href="/page/12">Newer &rarr;</a>
				</li>
		  	
			</ul>
		</div>
		<div class="span3">
			<ul class="nav nav-list well dsq-widget">
	<li class="nav-header">
		Recent Posts
	</li>
	
	<li>
		<a href="/2009/02/17/tasklist-taskkill/">Tasklist/Taskkill</a>
	</li>
	
	<li>
		<a href="/2009/02/17/boost-preprocessor/">boost::preprocessor</a>
	</li>
	
	<li>
		<a href="/2009/02/08/earl-grey/">Earl Grey</a>
	</li>
	
	<li>
		<a href="/2009/01/27/google-app-engine-overview/">Google App Engine Overview</a>
	</li>
	
	<li>
		<a href="/2009/01/27/erlide/">Erlide</a>
	</li>
	
	<li class="nav-header dsq-widget-title">
		Recent Comments
	</li>
	<script type="text/javascript" src="http://reiot.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script>
</ul>
		</div>
	</div>

</div> <!-- /container -->


    <footer>
      <p class="pull-right">
        <a href="http://github.com/Reiot/droppress" class="btn btn-success btn-mini">powered by DropPress 0.0.1</a>
      </p>
    </footer>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
	
    <script src="/assets/js/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/title_search.js"></script>
	

  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-247024-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>

  </body>
</html>